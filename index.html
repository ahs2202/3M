<!DOCTYPE html>
<html lang="en">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-427H1D2L7D"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-427H1D2L7D');
</script>
<head>
    <!-- Required meta tags (add the responsive viewport meta tag) -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description"
        content="Molecular Mimicry Map of SARS-CoV-2 web application">
    <title>Molecular Mimicry Map of SARS-CoV-2</title>
    
    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="https://www.ebi.ac.uk/pdbe/pdb-component-library/css/pdbe-molstar-light-1.1.0.css">
    <!--Bootstrap CSS library-->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <!--Google Icon CSS library-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!-- JS -->
    <!-- IntervalTree package for searching matched records efficiently (binary-search-bounds and interval-tree-1d packages, browserified and minified) -->
    <script>require=function t(i,r,n){function e(h,o){if(!r[h]){if(!i[h]){var u="function"==typeof require&&require;if(!o&&u)return u(h,!0);if(s)return s(h,!0);var f=new Error("Cannot find module '"+h+"'");throw f.code="MODULE_NOT_FOUND",f}var l=r[h]={exports:{}};i[h][0].call(l.exports,(function(t){return e(i[h][1][t]||t)}),l,l.exports,t,i,r,n)}return r[h].exports}for(var s="function"==typeof require&&require,h=0;h<n.length;h++)e(n[h]);return e}({"binary-search-bounds":[function(t,i,r){"use strict";function n(t,i,r,n,e){var s=["function ",t,"(a,l,h,",n.join(","),"){",e?"":"var i=",r?"l-1":"h+1",";while(l<=h){var m=(l+h)>>>1,x=a[m]"];return e?i.indexOf("c")<0?s.push(";if(x===y){return m}else if(x<=y){"):s.push(";var p=c(x,y);if(p===0){return m}else if(p<=0){"):s.push(";if(",i,"){i=m;"),r?s.push("l=m+1}else{h=m-1}"):s.push("h=m-1}else{l=m+1}"),s.push("}"),e?s.push("return -1};"):s.push("return i};"),s.join("")}function e(t,i,r,e){return new Function([n("A","x"+t+"y",i,["y"],e),n("P","c(x,y)"+t+"0",i,["y","c"],e),"function dispatchBsearch",r,"(a,y,c,l,h){if(typeof(c)==='function'){return P(a,(l===void 0)?0:l|0,(h===void 0)?a.length-1:h|0,y,c)}else{return A(a,(c===void 0)?0:c|0,(l===void 0)?a.length-1:l|0,y)}}return dispatchBsearch",r].join(""))()}i.exports={ge:e(">=",!1,"GE"),gt:e(">",!1,"GT"),lt:e("<",!0,"LT"),le:e("<=",!0,"LE"),eq:e("-",!0,"EQ",!0)}},{}],"interval-tree-1d":[function(t,i,r){"use strict";var n=t("binary-search-bounds");function e(t,i,r,n,e){this.mid=t,this.left=i,this.right=r,this.leftPoints=n,this.rightPoints=e,this.count=(i?i.count:0)+(r?r.count:0)+n.length}i.exports=function(t){if(!t||0===t.length)return new d(null);return new d(p(t))};var s=e.prototype;function h(t,i){t.mid=i.mid,t.left=i.left,t.right=i.right,t.leftPoints=i.leftPoints,t.rightPoints=i.rightPoints,t.count=i.count}function o(t,i){var r=p(i);t.mid=r.mid,t.left=r.left,t.right=r.right,t.leftPoints=r.leftPoints,t.rightPoints=r.rightPoints,t.count=r.count}function u(t,i){var r=t.intervals([]);r.push(i),o(t,r)}function f(t,i){var r=t.intervals([]),n=r.indexOf(i);return n<0?0:(r.splice(n,1),o(t,r),1)}function l(t,i,r){for(var n=0;n<t.length&&t[n][0]<=i;++n){var e=r(t[n]);if(e)return e}}function c(t,i,r){for(var n=t.length-1;n>=0&&t[n][1]>=i;--n){var e=r(t[n]);if(e)return e}}function g(t,i){for(var r=0;r<t.length;++r){var n=i(t[r]);if(n)return n}}function a(t,i){return t-i}function v(t,i){var r=t[0]-i[0];return r||t[1]-i[1]}function P(t,i){var r=t[1]-i[1];return r||t[0]-i[0]}function p(t){if(0===t.length)return null;for(var i=[],r=0;r<t.length;++r)i.push(t[r][0],t[r][1]);i.sort(a);var n=i[i.length>>1],s=[],h=[],o=[];for(r=0;r<t.length;++r){var u=t[r];u[1]<n?s.push(u):n<u[0]?h.push(u):o.push(u)}var f=o,l=o.slice();return f.sort(v),l.sort(P),new e(n,p(s),p(h),f,l)}function d(t){this.root=t}s.intervals=function(t){return t.push.apply(t,this.leftPoints),this.left&&this.left.intervals(t),this.right&&this.right.intervals(t),t},s.insert=function(t){var i=this.count-this.leftPoints.length;if(this.count+=1,t[1]<this.mid)this.left?4*(this.left.count+1)>3*(i+1)?u(this,t):this.left.insert(t):this.left=p([t]);else if(t[0]>this.mid)this.right?4*(this.right.count+1)>3*(i+1)?u(this,t):this.right.insert(t):this.right=p([t]);else{var r=n.ge(this.leftPoints,t,v),e=n.ge(this.rightPoints,t,P);this.leftPoints.splice(r,0,t),this.rightPoints.splice(e,0,t)}},s.remove=function(t){var i=this.count-this.leftPoints;if(t[1]<this.mid)return this.left?4*(this.right?this.right.count:0)>3*(i-1)?f(this,t):2===(o=this.left.remove(t))?(this.left=null,this.count-=1,1):(1===o&&(this.count-=1),o):0;if(t[0]>this.mid)return this.right?4*(this.left?this.left.count:0)>3*(i-1)?f(this,t):2===(o=this.right.remove(t))?(this.right=null,this.count-=1,1):(1===o&&(this.count-=1),o):0;if(1===this.count)return this.leftPoints[0]===t?2:0;if(1===this.leftPoints.length&&this.leftPoints[0]===t){if(this.left&&this.right){for(var r=this,e=this.left;e.right;)r=e,e=e.right;if(r===this)e.right=this.right;else{var s=this.left,o=this.right;r.count-=e.count,r.right=e.left,e.left=s,e.right=o}h(this,e),this.count=(this.left?this.left.count:0)+(this.right?this.right.count:0)+this.leftPoints.length}else this.left?h(this,this.left):h(this,this.right);return 1}for(s=n.ge(this.leftPoints,t,v);s<this.leftPoints.length&&this.leftPoints[s][0]===t[0];++s)if(this.leftPoints[s]===t){this.count-=1,this.leftPoints.splice(s,1);for(o=n.ge(this.rightPoints,t,P);o<this.rightPoints.length&&this.rightPoints[o][1]===t[1];++o)if(this.rightPoints[o]===t)return this.rightPoints.splice(o,1),1}return 0},s.queryPoint=function(t,i){if(t<this.mid){if(this.left)if(r=this.left.queryPoint(t,i))return r;return l(this.leftPoints,t,i)}if(t>this.mid){var r;if(this.right)if(r=this.right.queryPoint(t,i))return r;return c(this.rightPoints,t,i)}return g(this.leftPoints,i)},s.queryInterval=function(t,i,r){var n;if(t<this.mid&&this.left&&(n=this.left.queryInterval(t,i,r)))return n;if(i>this.mid&&this.right&&(n=this.right.queryInterval(t,i,r)))return n;return i<this.mid?l(this.leftPoints,i,r):t>this.mid?c(this.rightPoints,t,r):g(this.leftPoints,r)};var y=d.prototype;y.insert=function(t){this.root?this.root.insert(t):this.root=new e(t[0],null,null,[t],[t])},y.remove=function(t){if(this.root){var i=this.root.remove(t);return 2===i&&(this.root=null),0!==i}return!1},y.queryPoint=function(t,i){if(this.root)return this.root.queryPoint(t,i)},y.queryInterval=function(t,i,r){if(t<=i&&this.root)return this.root.queryInterval(t,i,r)},Object.defineProperty(y,"count",{get:function(){return this.root?this.root.count:0}}),Object.defineProperty(y,"intervals",{get:function(){return this.root?this.root.intervals([]):[]}})},{"binary-search-bounds":"binary-search-bounds"}]},{},[]);</script>
    <!--For Using utility functions-->
    <script src="https://cdn.jsdelivr.net/npm/lodash@4.17.19/lodash.min.js"></script>
    <script> lodash = _.noConflict(); // load script of lodash </script> 
    <!--Plotly-->
    <script src="https://cdn.plot.ly/plotly-1.58.4.js"></script>
<!--     1.54.7.min.js"></script> -->
    <!--PDB Mol*-->
    <script type="text/javascript" src="https://www.ebi.ac.uk/pdbe/pdb-component-library/js/pdbe-molstar-plugin-1.1.0.js"></script>
    <!--For loading large csv files-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.2.0/papaparse.min.js"></script>
    <!--Python's Numpy-like Library, NumJS-->
    <script src="https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.15.1/dist/numjs.min.js"></script>
    <!--D3 to draw tables-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
    <!--chroma to draw colormaps-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.1.0/chroma.min.js"></script>
    <!--hotkeys to add keyboard shortcuts-->
    <script src="https://cdn.jsdelivr.net/npm/hotkeys-js@3.8.1/dist/hotkeys.min.js" integrity="sha256-4nmnbhmVpr2Rg64+7ysAr93+vQrfc0UvHWwm4W6uXJM=" crossorigin="anonymous"></script>
    
    <!--Datatable for efficient visualization of tabular data-->
    <!--full: jquery.dataTables.js, jquery.dataTables.css-->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.21/css/jquery.dataTables.min.css">
    <script type="text/javascript" charset="utf8" src="https://cdn.datatables.net/1.10.21/js/jquery.dataTables.min.js" crossorigin="anonymous"></script>
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.1/dist/umd/popper.min.js" integrity="sha384-9/reFTGAW83EW2RDu2S0VKaIzap3H66lZH81PoYlFhbGU+6BZp6G7niu735Sk7lN" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha384-B4gt1jrGC7Jh4AgTPSdUtOBvfO8shuf57BaghqFfPlYxofvL8/KUEfYiJOMMV+rV" crossorigin="anonymous"></script>
    <!-- dataframe.js for useful dataframe functions -->
    <script src="https://cdn.jsdelivr.net/npm/dataframe-js@1.4.3/dist/dataframe.min.js" integrity="sha256-ncD0rnpkULRQhB+hFzhFCQ4KBu+NKVYEQHyhxsUA29Q=" crossorigin="anonymous"></script>
    <!-- FileSaver.js to save js object as local files -->
    <script src="https://cdn.jsdelivr.net/npm/filesaver.js@1.3.4/FileSaver.min.js" integrity="sha256-5IjlS/EkXaEXRrVOMusSOlmQsyFy3DvCD5QC5mJZubU=" crossorigin="anonymous"></script>
    <!-- Html2Canvas.js to save current view as a PNG file -->
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.0.0-rc.7/dist/html2canvas.min.js" integrity="sha256-Ax1aqtvxWBY0xWND+tPZVva/VQZy9t1Ce17ZJO+NTRc=" crossorigin="anonymous"></script>
    <!-- Pako.js to parse base64 gzipped text file downloaded from remote location -->
    <script src="https://cdn.jsdelivr.net/npm/pako@1.0.11/dist/pako.min.js" integrity="sha256-Kc+gVCuYZLZkDP3MjxWxhNtkMbUy2ycCo86X5fKn/Bw=" crossorigin="anonymous"></script>
    <!-- Bootstrap-Toggle.js more more animated toggle button -->
    <link href="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/css/bootstrap4-toggle.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/gh/gitbrent/bootstrap4-toggle@3.6.1/js/bootstrap4-toggle.min.js"></script>
<!--   Tagify for search bar interaction   -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@yaireo/tagify@3.21.5/dist/tagify.css" integrity="sha256-JQCBuvZzuXrKFdHRTVW23P/DqnFsfvbI3kraGJhPyNA=" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/@yaireo/tagify@3.21.5/dist/tagify.min.js" integrity="sha256-6QmUlbXKkm+RVqvqtIzhhDQ3cqRkuREeUhNJDnL2ujM=" crossorigin="anonymous"></script>
    
    <!--To use font-awesome icons -->
<!--     <script src="https://kit.fontawesome.com/b773d81884.js" crossorigin="anonymous"></script> -->
    <!-- Fussy search package for alignment of given peptide sequences to consensus sequence -->
<!--     <script src="https://cdn.jsdelivr.net/npm/fuse-js-latest@3.1.0/dist/fuse.min.js" integrity="sha256-7f3wLI5WWMPufBdf3U8CNW6K7WYPoO83Iqvr+dd6k4Q=" crossorigin="anonymous"></script> -->
    <!--React and React-Bootstrap library-->
<!--     <script src="https://unpkg.com/react/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-bootstrap@next/dist/react-bootstrap.min.js" crossorigin></script>
    <script>var Alert = ReactBootstrap.Alert;</script> -->
    <style>
      * { box-sizing: border-box; }
        /* Create two equal columns that floats next to each other */
        .column {
          float: left;
          width: 50%;
          padding: 10px;
          height: 450px; /* Should be removed. Only for demonstration */
          position:relative;
        }
        /* Clear floats after the columns */
        .responsive_row_with_two_columns:after {
          float:left;
          content: "";
          display: table;
          clear: both;
        }
        /* Responsive layout - makes the two columns stack on top of each other instead of next to each other */
        @media screen and (max-width: 700px) {
          .column {
            width: 100%;
          }
        }
        .deconstructed_pancake_box { /* example in https://web.dev/one-line-layouts/ */
            flex: 1 1 450px;
            margin: 5px;
        }
        .deconstructed_pancake_parent {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        .container_molstar {
          height: 600px; /* Should be modified */
          position:relative;
        }
        #container_d3_table_metrics{
          display: grid;
          grid-template-rows: auto 1fr auto;
          position:relative;
        }
        #plotly_graph_molecular_mimicry_map{
            float:left;
            width:100%;
            padding: 5px;
            height:575px;
            position:relative;
            overflow:hidden;
        }
        .graph_for_selection{
            float:left;
            width:100%;
            height:350px;
            position:relative;
        }
/*    custom bootstrap button color   */
        .bg-custom-navbar{  /* custom navbar color and gradient (color representing lupus awareness color) */
            background-image: linear-gradient( 15deg, #46137a 0%, #f08dee 100%);
        }
        .bg-custom-navbar-secondary{  /* custom navbar color and gradient for secondary navbar (color representing lupus awareness color) */
            background-image: linear-gradient( 20deg, #004d4d 0%, #00e0e0 100%);
        }
        .bg-custom-navbar-hidden{  /* custom navbar color and gradient (color representing lupus awareness color) */
            border-left: 6px solid #ccc;
            border-bottom: 3px solid #ccc;
            color: #000;
            border-color: #6b0596;
            background-color: #f8f7fa;
/*             '#fce6ff; #dfdae6; #f3f0f7; */
        }
        .bg-custom-navbar-top{  /* custom navbar color and gradient (color representing lupus awareness color) */
            background-image: linear-gradient( 0deg, #ababab 0%, #f7f7f7 100%);
        }
        /* CSS for D3 Table */
        table { border-collapse: collapse; color: #333; background-color: #F7F6F3; margin: auto; } /* place the table in the middle of div */
        table thead { font-weight: bold; background-color: #CCC; cursor: default; text-align: center; }
        table tbody tr:hover { background-color: #FFC; }
        td { border: solid 1px #CCC; padding: 0 1ex; }
        .table_even { color: #284775; background-color: White; }
        .table_left { text-align: left; }
        .table_center { text-align: center; }
        .table_right { text-align: right; }
        .table_add { color: green; }
        .table_minus { color: red; }
        
        #button_scroll_to_the_top { /* CSS for Scroll Back To Top Button */
          display: none; /* Hidden by default */
          position: fixed; /* Fixed/sticky position */
          bottom: 20px; /* Place the button at the bottom of the page */
          right: 30px; /* Place the button 30px from the right */
          z-index: 99; /* Make sure it does not overlap */
          border: none; /* Remove borders */
          outline: none; /* Remove outline */
          background-color: DarkViolet; /* Set a background color */
          color: white; /* Text color */
          cursor: pointer; /* Add a mouse pointer on hover */
          padding: 15px; /* Some padding */
          border-radius: 10px; /* Rounded corners */
          font-size: 18px; /* Increase font size */
        }
/*     for tidy organization of buttons     */
        .btn { 
            margin-bottom: 0px !important;
        }
        #button_scroll_to_the_top:hover {
          background-color: #555 ; /* Indigo Add a dark-grey background on hover */
        }
        .helpIcon
        {
          cursor: pointer;
          padding-top:12px;
        }
        i.icon-white {
            color: white;
            display:inline-flex;
            vertical-align:middle;
        }
        i.icon-black {
            color: black;
            display:inline-flex;
            vertical-align:middle;
        }
        /* for labeled buttons */
        .btn-label {position: relative;left: -12px;display: inline-block;padding: 6px 12px;background: rgba(0,0,0,0.1);border-radius: 3px 0 0 3px;}
        .btn-labeled {padding-top: 0;padding-bottom: 0;}
        .btn { margin-bottom:10px; }
        /* for  div. displayed during loading (https://stackoverflow.com/questions/54439548/display-loading-symbol-while-waiting-for-a-result-with-plot-ly-dash) */
        @keyframes fadein {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 0.5;
            }
        }
        ._plotly-loading-callback {
          font-family: sans-serif;
          padding-top: 50px;
          color: rgb(90, 90, 90);

          /* The banner */
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          text-align: center;
          cursor: progress;

          opacity: 0;
          background-color: rgb(250, 250, 250);
          /* Delay animation by 1s to prevent flashing 
             and smoothly transition the animation over 0.5s 
           */
          -moz-animation: fadein 0.5s ease-in 1s forwards; /* Firefox */
          -webkit-animation: fadein 0.5s ease-in 1s forwards; /* Safari and Chrome */
          -o-animation: fadein 0.5s ease-in 1s forwards; /* Opera */
            animation: fadein 0.5s ease-in 1s forwards;
        }
        /* Add an extra .carousel parent class to increase specificity
           avoiding the use of !important flag. */
        .carousel-caption {
            color: black;
        }
        .carousel .carousel-indicators li {
            background-color: #fff;
            background-color: rgba(70, 70, 70, 0.25);
        }

        .carousel .carousel-indicators .active {
            background-color: #444;
        }
        .carousel .carousel-indicators li {
            background-color: #fff;
            background-color: rgba(70, 70, 70, 0.25);
        }

        .carousel .carousel-indicators .active {
            background-color: #444;
        }
        .carousel-control-next,
        .carousel-control-prev {
            filter: invert(100%);
        }
        /* for loading SVG images */
/*         .loader{
          margin: 0 0 2em;
          height: 100px;
          width: 100%;
          text-align: center;
          padding: 1em;
          margin: 0 auto 1em;
          display: inline-block;
          vertical-align: top;
        } */
/*  https://gitbrent.github.io/bootstrap4-toggle/ custom settings  */
          .toggle.ios, .toggle-on.ios, .toggle-off.ios { border-radius: 20rem; }
          .toggle.ios .toggle-handle { border-radius: 20rem; }
    </style>
    <!-- icon of the document -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2020%2020'%3E%3Ctext%20x='0'%20y='16'%20style='filter:%20invert(100%);'%3E⚕️%3C/text%3E%3C/svg%3E" type="image/svg+xml" />
</head>

<body>
 <!-- where captured current view is stored as a data URL  -->
<a id="anchor-current-view" href="#" hidden></a>
</div>
<!-- start of the current view container -->
<div id="molecularmimicrymap-current-view">
<nav class="navbar navbar-expand-lg navbar-dark bg-custom-navbar"> <!-- sticky-top -->
    <a class="navbar-brand mb-0 h1">Molecular Mimicry Map of SARS-CoV-2</a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav_top" aria-controls="navbarNav_top" aria-expanded="false" aria-label="Toggle top navigation"><span class="navbar-toggler-icon"></span></button>
    <div class="collapse navbar-collapse" id="navbarNav_top">
        <ul class="navbar-nav">
            <li class="nav-item active">
                <a class="nav-link" type="button" data-toggle="collapse" data-target="#introduction" aria-controls="introduction" aria-expanded="false" aria-label="Toggle introduction" onclick="Toggle_Introduction_Modal( )">Introduction</a>
            </li>
<!--             <li class="nav-item active">
                <a class="nav-link" type="button" data-toggle="collapse" data-target="#container_fileLoader" aria-controls="container_fileLoader" aria-expanded="false" aria-label="Toggle container_fileLoader">Files</a>
            </li> -->
<!--             <li class="nav-item">
                <a class="nav-link">Citation</a>
            </li>
            <li class="nav-item">
                <a class="nav-link">Feedback</a>
            </li> -->
            <li class="nav-item">
                <select class="custom-select w-auto mx-2 my-0" id="select_dataset" title="select dataset" onchange="Load_Dataset( )">
                    <option selected value="NCBI_Virus_human_host_SARS_CoV_2">8,138 SARS-CoV-2 Genomes (NCBI-Virus, 06/26/2020)</option>
                    <option value="gisaid.allprot1114.valid.nonredundant">196,352 SARS-CoV-2 Genomes (GISAID, 11/14/2020)</option>
                    <option value="non_SARS_CoV_2_coronavirus_20201214.valid.nonredundant">184 Common Cold Coronavirus Genomes (NCBI-Virus)</option>
                    <option value="cr.gisaid.allprot1114.and.non_SARS_CoV_2_coronavirus_20201214">Cross-Reactivity Between SARS-CoV-2 and Other Viruses</option>
                </select>
            </li>
            <li class="nav-item">
                <div class="form-check form-check-inline" id="toggle_alignment_mode_container">
                    <input id="toggle_alignment_mode" type="checkbox" checked data-toggle="toggle" data-on="Alignment to Virus" data-off="Alignment to Human" data-onstyle="secondary" data-offstyle="light" data-style="ios" data-width="14rem" data-height="calc(1.5em + .75rem + 2px)" onchange="Load_Dataset( )">
                </div>
            </li>
        </ul>
        <button type="button" class="btn btn-light bth-sm ml-auto mr-1 my-0" aria-label="capture current view and download it as a PNG file" data-tooltip="tooltip" data-placement="left" data-html="true" title="Capture <b>current view</b> and download it as a PNG file" onclick="DownloadCurrentView( )"><i class="material-icons icon-black" style="font-size:25px">camera_alt</i></button>
        <button type="button" class="btn btn-light bth-sm ml-1 mr-1 my-0" aria-label="show keyboard shortcuts" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to show <b>keyboard shortcuts</b>" onclick="$( '#modal_keyboard_shortcuts' ).modal( 'show' )"><i class="material-icons icon-black" style="font-size:25px">keyboard</i></button>
        <button type="button" class="btn btn-light bth-sm ml-1 my-0" aria-label="toggle tooltips" data-tooltip-always-active="tooltip" data-placement="bottom" data-html="true" title="Press to <b>on/off</b> help messages on mouse over (hover) of certain buttons" onclick="Toggle_Tooltips( )"><i class="material-icons icon-black" style="font-size:25px">help_outline</i></button>
    </div>
</nav>
<button onclick="Scroll_to_the_Top( )" id="button_scroll_to_the_top" title="Go to top">Top</button>
<div>
    <div class="collapse" id="container_fileLoader"><div><input type="file" id="file-selector" multiple></div></div>
</div>
<div id="molecular_mimicry_map">
    <div id="container_molecular_mimicry_map">
        <div id="controlBox_plotly_graph_molecular_mimicry_map">
            <div class="pos-f-t">
                <nav class="navbar navbar-dark bg-custom-navbar">
                    <form class="form-inline">
                        <button class="navbar-toggler mr-2" type="button" data-toggle="collapse" data-target="#navbarToggleExternalContent__plotly_graph_molecular_mimicry_map" aria-controls="navbarToggleExternalContent__plotly_graph_molecular_mimicry_map" aria-expanded="false" aria-label="Toggle navigation" data-tooltip="tooltip" data-placement="right" data-html="true" title="Press to change default graph settings and turn on/off tracks"><i class="material-icons icon-white" style="font-size:20px;cursor:pointer">settings</i></button>
                        <a class="mb-0" style="color:white; font-size:0.8em" id="text_number_of_records"></a>
                    </form>
                    
                    <form class="form-inline">
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="left" data-html="true" title="Press to <b>on/off</b> the <i>legend</i> of the graph" id="button_toggle_legend_MolecularMimicryMap" onclick="Toggle_Legend_MolecularMimicryMap( )"><i class="material-icons icon-black" style="font-size:20px">list</i></button>
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>on/off</b> displaying <i>record details</i> on hover (mouse over). It will <b>also disable click events</b>." id="button_toggle_hovermode_MolecularMimicryMap" onclick="Toggle_Hovermode_MolecularMimicryMap( )"><i class="material-icons icon-black" style="font-size:20px">article</i></button>
                        
                        <button class="btn btn-light btn-sm active ml-1 mr-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> B-cell cross-reactivity prediction data" aria-label="Press to toggle B-cell cross-reactivity prediction data" id="toggle_BCellCrossReactivityPrediction_MolecularMimicryMap" onclick="Toggle_BCellCrossReactivityPrediction_MolecularMimicryMap( )" autocomplete="off" aria-pressed="true">B-Cell Cross-Reactivity</button>
                        <button class="btn btn-light btn-sm active ml-0 mr-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> T-cell cross-reactivity prediction data" aria-label="Press to toggle T-cell cross-reactivity prediction data" id="toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" onclick="Toggle_TCellCrossReactivityPrediction_MolecularMimicryMap( )" autocomplete="off" aria-pressed="true">T-Cell Cross-Reactivity</button>
                        <button class="btn btn-light btn-sm active mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> SARS-CoV-2 virus protein annotations and InterPro protein domain annotations" aria-label="Press to toggle SARS-CoV-2 virus protein annotations and InterPro protein domain annotations" id="toggle_ProteinAnnotation_MolecularMimicryMap" onclick="Toggle_ProteinAnnotation_MolecularMimicryMap( )" autocomplete="off" aria-pressed="true">Protein Annotations</button>
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> immuno prediction data" aria-label="Press to toggle visibility of immunogenicity prediction of reference SARS-CoV-2 proteins" id="toggle_vaccine_metrics_MolecularMimicryMap" onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off" aria-pressed="false">Vaccine Metrics</button>
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> <i>immunogenicity prediction data</i> (MHC binding prediction) and <i>number of mutated proteins</i> for each mutation" aria-label="Press to toggle immunogenicity prediction data (MHC binding prediction) and number of mutated proteins for each mutation" id="toggle_iedb_epitope_MolecularMimicryMap" onclick="Toggle_IEDB_Epitope_MolecularMimicryMap( )" autocomplete="off" aria-pressed="false">IEDB Epitopes</button>
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> potential (peptide) <b>vaccine candidates</b>." aria-label="Press to toggle potential (peptide) vaccine candidates." id="toggle_vaccine_design_MolecularMimicryMap" onclick="Toggle_VaccineDesign_MolecularMimicryMap( )" autocomplete="off" aria-pressed="false">Vaccine Candidates</button>
                        <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="collapse" data-toggle="button" data-target="#navbar_vaccine_design" id="btn_for_opening_navbar_vaccine_design" aria-expanded="false" aria-controls="navbar_vaccine_design" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a panel for <i>designing (peptide) vaccine candidates</i> against SARS-CoV-2 virus, considering <b>both</b> <i>immunogenicity</i> <b>and</b> <i>potential molecular mimicry</i> between the virus and human. (could be important for people predisposed to autoimmune diseases)" aria-label="Press to toggle a panel for designing a (peptide) vaccine candidate against SARS-CoV-2 virus, considering both immunogenicity and potential molecular mimicry between the virus and human.">Vaccine Design Panel</button>
                    </form>
                </nav>
                <div class="collapse" id="navbarToggleExternalContent__plotly_graph_molecular_mimicry_map">
                    <div class="bg-custom-navbar-hidden p-4">
                        <h4 class="text-black">Molecular Mimicry Map of SARS-CoV-2 Graph Setting Panel</h4>
                        <p>
                            <h5 class="text-muted">General Setting</h5>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Plot height is</span></div>
                                    <input type="text" class="form-control" aria-label="height of the plot in pixel" id="input_plot_height_MolecularMimicryMap" title="input field for setting the height of Molecular Mimicry Map plot in pixels" value="750">
                                    <div class="input-group-append"><span class="input-group-text">pixels</span></div>
                                </div>
                            </div>
                        </p>
                        <p>
                            <h5 class="text-muted">B Cell Cross-Reactivity Prediction Data</h5>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Y axis represents</span></div>
                                    <select class="custom-select w-auto" id="select_YAxis_BCellCrossReactivity" title="select y-axis values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="score_blosum_weighted">Sum of Accessibility-Weighted BLOSUM62 Scores</option>
                                        <option value="sum_of_weights">Sum of Relative Surface Accessible Areas</option>
                                        <option value="avg_score_blosum_weighted" selected>Average Accessibility-Weighted BLOSUM62 Score</option>
                                        <option value="score_similarity_ss8">Secondary Structure Similarity</option>
                                        <option value="correl_coeffi_acc">Correlation Coefficient of Accessibility</option>
                                        <option value="correl_coeffi_phi">Correlation Coefficient of Phi (ϕ)</option>
                                        <option value="correl_coeffi_psi">Correlation Coefficient of Psi (Ψ)</option>
                                        <option value="duplicate_counts">Duplicate Counts</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Size of point (or width of line) represents</span></div>
                                    <select class="custom-select w-auto" id="select_Size_BCellCrossReactivity" title="select size (line thickness) values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="score_blosum_weighted">Sum of Accessibility-Weighted BLOSUM62 Scores</option>
                                        <option value="sum_of_weights" selected>Sum of Relative Surface Accessible Areas</option>
                                        <option value="avg_score_blosum_weighted">Average Accessibility-Weighted BLOSUM62 Score</option>
                                        <option value="score_similarity_ss8">Secondary Structure Similarity</option>
                                        <option value="correl_coeffi_acc">Correlation Coefficient of Accessibility</option>
                                        <option value="correl_coeffi_phi">Correlation Coefficient of Phi (ϕ)</option>
                                        <option value="correl_coeffi_psi">Correlation Coefficient of Psi (Ψ)</option>
                                        <option value="duplicate_counts">Duplicate Counts</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Opacity of point represents</span></div>
                                    <select class="custom-select w-auto" id="select_Opacity_BCellCrossReactivity" title="select opacity values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="score_blosum_weighted">Sum of Accessibility-Weighted BLOSUM62 Scores</option>
                                        <option value="sum_of_weights">Sum of Relative Surface Accessible Areas</option>
                                        <option value="avg_score_blosum_weighted">Average Accessibility-Weighted BLOSUM62 Score</option>
                                        <option value="score_similarity_ss8">Secondary Structure Similarity</option>
                                        <option value="correl_coeffi_acc" selected>Correlation Coefficient of Accessibility</option>
                                        <option value="correl_coeffi_phi">Correlation Coefficient of Phi (ϕ)</option>
                                        <option value="correl_coeffi_psi">Correlation Coefficient of Psi (Ψ)</option>
                                        <option value="duplicate_counts">Duplicate Counts</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Plot top</span></div>
                                    <input type="text" class="form-control" aria-label="the number of alignments for plotting" id="input_n_alignments_for_plotting_BCellCrossReactivity" title="input field for setting the number of alignments for plotting B Cell Cross-Reactivity prediciton data" value="1000">
                                    <div class="input-group-append"><span class="input-group-text">most significant</span></div>
                                    <select class="custom-select w-auto" id="select_redundancy_level_BCellCrossReactivity" title="select redundancy level of B cell cross-reactivity prediction data">
                                        <option value="nonredundant_position">select redundancy level</option>
                                        <option value="all" disabled>alignments (100%)</option>
                                        <option value="nonredundant_sequence">non-redundant alignments with unique aligned sequences (~15%)</option>
                                        <option value="nonredundant_position" selected>non-redundant alignments with unique aligned positions (~5%)</option>
                                    </select>
                                    <div class="input-group-prepend"><label class="input-group-text" for="select_windowSize_BCellCrossReactivity">for window size of</label></div>
                                    <select class="custom-select w-auto" id="select_windowSize_BCellCrossReactivity" title="window size for B cell cross-reactivity prediction data">
                                        <option value="30">select window size</option>
                                        <option value="5">5</option>
                                        <option value="8">8</option>
                                        <option value="11">11</option>
                                        <option value="14">14</option>
                                        <option value="17">17</option>
                                        <option value="20">20</option>
                                        <option value="25">25</option>
                                        <option value="30" selected>30</option>
                                        <option value="35">35</option>
                                        <option value="45">45</option>
                                        <option value="55">55</option>
                                        <option value="70">70</option>
                                        <option value="85">85</option>
                                        <option value="100">100</option>
                                        <option value="125">125</option>
                                        <option value="150">150</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_windowSize_BCellCrossReactivity">amino acids.</label></div>
                                </div>
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><label class="input-group-text" for="select_representation_of_an_alignment_BCellCrossReactivity">Represent each alignment with a</label></div>
                                    <select class="custom-select w-auto" id="select_representation_of_an_alignment_BCellCrossReactivity" title="select a representation of an alignment in B cell cross-reactivity prediction data">
                                        <option value="1">select a representation</option>
                                        <option value="0" selected>point (faster)</option>
                                        <option value="1">line (slower)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_representation_of_an_alignment_BCellCrossReactivity">on a</label></div>
                                    <select class="custom-select w-auto" id="select_graphic_format_BCellCrossReactivity" title="select a graphic format of representations of B cell cross-reactivity prediction data">
                                        <option value="0">select a graphic format</option>
                                        <option value="0" selected>bitmap (faster)</option>
                                        <option value="1">vector (scalable, but slower)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_graphic_format_BCellCrossReactivity">image.</label></div>
                                </div>
                            </div>
                        </p>
                        <p>
                            <h5 class="text-muted">T Cell Cross-Reactivity Prediction Data</h5>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Y axis represents</span></div>
                                    <select class="custom-select w-auto" id="select_YAxis_TCellCrossReactivity" title="select y-axis values for plotting">
                                        <option value="score_blosum">Sum of BLOSUM62 Scores</option>
                                        <option value="average_score_blosum" selected>Average BLOSUM62 Score</option>
                                        <option value="score_geometric_mean">-Log of Geometric Average of Predicted Binding Affinities (IC50) of Human and Virus Peptides</option>
                                        <option value="duplicate_counts">Duplicate Counts</option>
                                    </select>
                                </div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><span class="input-group-text">Plot top</span></div>
                                    <input type="text" class="form-control" aria-label="the number of alignments for plotting" id="input_n_alignments_for_plotting_TCellCrossReactivity" title="input field for setting the number of alignments for plotting T Cell Cross-Reactivity prediciton data" value="1000">
                                    <div class="input-group-append"><span class="input-group-text">most significant</span></div>
                                    <select class="custom-select w-auto" id="select_redundancy_level_TCellCrossReactivity" title="select redundancy level of T cell cross-reactivity prediction data">
                                        <option value="nonredundant_aligned_position">select redundancy level</option>
                                        <option value="all">alignments (100%)</option>
                                        <option value="nonredundant_aligned_sequence">non-redundant alignments with unique aligned sequences (~95%)</option>
                                        <option value="nonredundant_aligned_position" selected>non-redundant alignments with unique aligned positions (~55%)</option>
                                    </select>
                                    <div class="input-group-prepend"><label class="input-group-text" for="select_MHC_class_TCellCrossReactivity">for MHC class I and II molecules.</label></div>
                                </div>
                                <div class="input-group mx-2 my-2">
                                    <div class="input-group-prepend"><label class="input-group-text" for="select_representation_of_an_alignment_TCellCrossReactivity">Represent each pair of predicted binding scores with a</label></div>
                                    <select class="custom-select w-auto" id="select_representation_of_an_alignment_TCellCrossReactivity" title="select a representation for a pair of predicted binding scores in T cell cross-reactivity prediction data">
                                        <option value="1">select a representation</option>
                                        <option value="0" selected>point (Y down/up)</option>
                                        <option value="1">point (star-triangle down/up)</option>
                                        <option value="2">point (bowtie/hourglass)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_representation_of_an_alignment_TCellCrossReactivity">(human/virus) on a</label></div>
                                    <select class="custom-select w-auto" id="select_graphic_format_TCellCrossReactivity" title="select a graphic format of representations of T cell cross-reactivity prediction data">
                                        <option value="0">select a graphic format</option>
                                        <option value="0" selected>bitmap (faster)</option>
                                        <option value="1">vector (scalable, but slower)</option>
                                    </select>
                                    <div class="input-group-append"><label class="input-group-text" for="select_graphic_format_TCellCrossReactivity">image.</label></div>
                                </div>
                            </div>
                        </p>
                        <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="DrawMolecularMimicryMap( ); Loading_Screen( false );">Load and Draw</button></p>
                        <p>
                            <h4 class="text-muted">Tracks</h4>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary ml-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_count_non_consensus_residue" checked onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">Mutation Counts</label></div>
                                <select class="custom-select w-auto mr-2 my-2" id="select_vaccine_metric_count_non_consensus_residue" title="select country for displaying mutation counts (counts of non-consensus residues)">
                                    <option value="count_non_consensus_residue">select country</option>
                                    <option value="count_non_consensus_residue" selected>global</option>
                                    <option value="count_non_consensus_residue__USA">USA</option>
                                    <option value="count_non_consensus_residue__Australia">Australia</option>
                                    <option value="count_non_consensus_residue__India">India</option>
                                </select>
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary mx-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_relative_accessible_surface_area" onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">Accessible Surface</label></div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary mx-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_iedb_t_cell_assay" onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">IEDB Positive T-Cell Assay Counts</label></div>
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary ml-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_mhc_i_binding_prediction" checked onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">MHC-I Binding Peptide Counts (MHCflurry)</label></div>
                                <select class="custom-select w-auto mr-2 my-2" id="select_vaccine_metric__mhc_i_binding_peptide_count" title="select a minimum allele frequency threshold for defining common MHC-I alleles">
                                    <option value="count_peptide_binding_common_mhc_i_alleles__537_alleles__min_allele_frequency_0.001">allele frequency (# alleles)</option>
                                    <option value="count_peptide_binding_common_mhc_i_alleles__8_alleles__min_allele_frequency_0.5">0.5 (8)</option>
                                    <option value="count_peptide_binding_common_mhc_i_alleles__100_alleles__min_allele_frequency_0.1">0.1 (100)</option>
                                    <option value="count_peptide_binding_common_mhc_i_alleles__308_alleles__min_allele_frequency_0.01">0.01 (308)</option>
                                    <option value="count_peptide_binding_common_mhc_i_alleles__537_alleles__min_allele_frequency_0.001" selected>0.001 (537)</option>
                                </select>
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary mx-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_mhc_i_processing_score" onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">MHC-I Ligand Processing Score Pred. (MHCflurry)</label></div>
                            </div>
                            <div class="btn-toolbar" role="toolbar">
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary mx-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_iedb_b_cell_assay" onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">IEDB Positive B-Cell Assay Counts</label></div>
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary ml-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_mhc_ii_binding_prediction" checked onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">MHC-II Binding Peptide Counts (netMHCIIpan)</label></div>                  
                                <select class="custom-select w-auto mr-2 my-2" id="select_vaccine_metric__mhc_ii_binding_peptide_count" title="select a minimum allele frequency threshold for defining common MHC-II alleles">
                                    <option value="count_peptide_binding_common_mhc_ii_alleles__1668_alleles__min_allele_frequency_0.001">allele frequency (# alleles)</option>
                                    <option value="count_peptide_binding_common_mhc_ii_alleles__19_alleles__min_allele_frequency_0.5">0.5 (19)</option>
                                    <option value="count_peptide_binding_common_mhc_ii_alleles__273_alleles__min_allele_frequency_0.1">0.1 (273)</option>
                                    <option value="count_peptide_binding_common_mhc_ii_alleles__865_alleles__min_allele_frequency_0.01">0.01 (865)</option>
                                    <option value="count_peptide_binding_common_mhc_ii_alleles__1668_alleles__min_allele_frequency_0.001" selected>0.001 (1668)</option>
                                </select>
                                <div class="btn-group-toggle" data-toggle="buttons"><label class="btn btn-outline-secondary mx-2 my-2"><input type="checkbox" id="checkbox_toggle_vaccine_metric_bepipred" onclick="VaccineMetrics_Apply_Visibility( )" autocomplete="off">Linear B-Cell Epitope Pred. Score (BepiPred)</label></div>
                            </div>
                        </p>
                    </div>
                </div>
            </div>
        </div>
        <div id="navbar_vaccine_design" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar">
                <div class="btn-toolbar" role="toolbar">
                    <div class="input-group ml-1 mr-1 my-1">
                        <div class="input-group-prepend"><label class="input-group-text" for="select_yaxis_plot_vaccine_design">Y-axis:</label></div>
                        <select class="custom-select w-auto" id="select_yaxis_plot_vaccine_design" title="select yaxis for visualization of vaccine candidates" onchange="Draw_DesignedVaccineTrace( 'update_name_y_axis' )">
                            <option value="random_value">select y-axis value</option>
                            <option value="number_of_overlapped_potential_b_cell_cross_reactive_epitopes">number of overlapped predicted B-cell cross-reactive epitopes</option>
                            <option value="number_of_overlapped_potential_t_cell_cross_reactive_epitopes" selected>number of overlapped predicted T-cell cross-reactive MHC epitopes</option>
                            <option value="count_non_consensus_residue">number of mutated proteins</option>
                            <option value="avg_processing_score_mhc_i">MHC-I processing score (MHCflurry)</option>
                            <option value="score_linear_bcell_epitope_prediction__bepipred">B cell epitope pred. score (BepiPred)</option>
                            <option value="random_value">random</option>
                            <option value="count_peptide_binding_common_mhc_i_alleles__537_alleles__min_allele_frequency_0.001">number of overlapped predicted MHC-I epitopes (min allele freq. 0.001)</option>
                            <option value="count_peptide_binding_common_mhc_ii_alleles__1668_alleles__min_allele_frequency_0.001">number of overlapped predicted MHC-II epitopes (min allele freq. 0.001)</option>
                            <option value="relative_accessible_surface_area">relative accessible surface area</option>
                        </select>
                        <div class="input-group-prepend"><label class="input-group-text" for="input_y_axis_range_max">from 0 to</label></div>
                        <input type="text" class="form-control" aria-label="An input box for the max value of the Y-axis range of potential vaccine candidate track" id="input_y_axis_range_max" data-tooltip="tooltip" data-placement="top" data-html="true" title="An <b>max value of</b> the Y-axis range of potential vaccine candidate track" placeholder="max value" onchange="Draw_DesignedVaccineTrace( 'update_float_y_axis_range_max' )">
                    </div>
                </div>
                <form class="form-inline">
                    <button class="btn btn-labeled btn-warning mx-2 my-1" type="button" onclick="AnalyzeVaccineDesign( );Draw_DesignedVaccineTrace( 'new_analysis' )" aria-expanded="false" aria-controls="container_file_vaccine_design" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to load a FASTA file containing peptide vaccine candidates<br><em>the file is not uploaded to any server, but analyzed locally in this browser</em>"><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">refresh</i></span>Analyze with Current View</button> 
                    <button class="btn btn-labeled btn-light mx-2 my-1" type="button" onclick="$( '#modal_choose_fasta' ).modal( 'show' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to load a FASTA file containing peptide vaccine candidates<br><em>the file is not uploaded to any server, but analyzed locally in this browser</em>"><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">publish</i></span>Choose Fasta</button> 
                    <button class="btn btn-labeled btn-light mx-2 my-1" type="button" onclick="$( '#modal_generate_peptides' ).modal( 'show' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>retrieve every peptides</b> from the <i>consensus SARS-CoV-2 proteome</i> for vaccine design in addition to using already developed peptide vaccine candidates."><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">line_style</i></span>Generate Peptides</button>
                    <button class="btn btn-labeled btn-light mx-2 my-1" type="button" onclick="$( '#modal_select_peptides' ).modal( 'show' )" data-html="true" data-tooltip="tooltip" data-placement="bottom" title="Press to <b>select</b> peptides"><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">rule</i></span>Select Peptides</button>
                    <button class="btn btn-labeled btn-light mx-2 my-1" type="button" onclick="Download_Analysis_Result__Vaccine_Design( )" data-html="true" data-tooltip="tooltip" data-placement="bottom" title="Press to <b>download</b> analysis result in a <i>CSV</i> file"><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">get_app</i></span>Download Result</button> 
                </form>
                <button type="button" class="close" aria-label="Close navbar_vaccine_design" data-toggle="collapse" data-target="#navbar_vaccine_design"><span aria-hidden="true">&times;</span></button>
            </nav>
        </div>
        <div id="container_searchbox_main">
            <input name='tags' id='searchbox_main' placeholder='Enter Gene Symbol' value='' data-blacklist='.NET,PHP'>
        </div>
        <div id="container_graph_molecular_mimicry_map">
            <div id="plotly_graph_molecular_mimicry_map"></div>
            <div id="container_d3_table_metrics">
                </div>
            </div>
        </div>
    </div>
    <div>
        <nav class="navbar navbar-dark bg-custom-navbar">
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarToggleExternalContent_supplementary_graph_setting_panel" aria-controls="navbarToggleExternalContent_supplementary_graph_setting_panel" aria-expanded="false" aria-label="Toggle supplementary plot setting panel" data-tooltip="tooltip" data-placement="right" data-html="true" title="Press to <b>select or remove columns</b> in for <i>parallel coordinate graphs</i> for filtering cross-reactivity prediction data"><i class="material-icons icon-white" style="font-size:20px;cursor:pointer">settings</i></button>
            <form class="form-inline">
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="plotly_graph_b_cell_cross_reactivity" onclick="Toggle_Exclusive_Tabs( '#plotly_graph_b_cell_cross_reactivity' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a parallel coordinate graph for <i>filtering</i> B-cell cross-reactivity prediction data" aria-label="Press to toggle a parallel coordinate graph for filtering B-cell cross-reactivity prediction data">B-Cell Cross-Reactivity Filter</button>
                <button id="btn_toggle_mhc_cross_reactivity_metrics" class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="plotly_graph_t_cell_cross_reactivity" onclick="Toggle_Exclusive_Tabs( '#plotly_graph_t_cell_cross_reactivity' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a parallel coordinate graph for <i>filtering</i> T-cell cross-reactivity prediction data" aria-label="Press to toggle a parallel coordinate graph for filtering T-cell cross-reactivity prediction data">T-Cell Cross-Reactivity Filter</button>
                <button id="btn_toggle_human_protein_metrics" class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="plotly_graph_human_protein" onclick="Toggle_Exclusive_Tabs( '#plotly_graph_human_protein' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a parallel coordinate graph for <i>filtering</i> human proteins" aria-label="Press to toggle a parallel coordinate graph for filtering human proteins">Human Protein Filter</button>
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" aria-controls="#container_datatable_panel_MolecularMimicryMap" aria-expanded="false" onclick="Toggle_Exclusive_Tabs( '#container_datatable_panel_MolecularMimicryMap' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a panel for exploring associated data using a <i>data table</i>. Data records associated with <b>a specific human protein can be highlighted</b> by entering the <i>UniProt accession</i> of the protein" aria-label="Press to toggle a panel for exploring associated data using a data table. Data records associated with a specific human protein can be highlighted by entering the UniProt accession of the protein">Data Tables</button>
<!--                 <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="collapse" data-toggle="button" data-target="#container_d3_table_metrics" aria-expanded="false" aria-controls="container_d3_table_metrics">Record Details</button> -->
                <button id="btn_toggle_gene_expression_panel" class="btn btn-light btn-sm mx-1 my-0" type="button" aria-expanded="false" aria-controls="container_expression_panel_MolecularMimicryMap" onclick='Toggle_Panel( "#container_expression_panel_MolecularMimicryMap" )' data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> a panel showing <b>mRNA expression</b> of the selected human protein" aria-label="Press to toggle a panel showing mRNA expression of the selected human protein">Expression</button>
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="collapse" data-toggle="button" data-target="#container_plotly_table_sequence" aria-expanded="false" aria-controls="container_plotly_table_sequence"data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> <i>a table</i> showing <b>predicted/experimental structural properties</b> of aligned human and SARS-CoV-2 virus proteins" aria-label="">Aligned Sequences</button>
                <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="collapse" data-toggle="button" data-target="#container_PDB" aria-expanded="false" aria-controls="container_PDB"data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> <i>molecule structure viewers</i> displaying aligned human and SARS-CoV-2 virus <i>protein structures</i>. Aligned residues were colored between <i>red to green</i> based on the <b>BLOSUM62 score</b> of the alignment at each position." aria-label="Press to toggle molecule structure viewers displaying aligned human and SARS-CoV-2 virus protein structures">Aligned Structures</button> 
            </form>
        </nav>
        <div class="collapse" id="navbarToggleExternalContent_supplementary_graph_setting_panel">
            <div class="bg-custom-navbar-hidden p-4">
                <h4 class="text-muted" style="display: inline-block;">Molecular Mimicry Map of SARS-CoV-2<h4>
                <h4 class="text-black"> Supplementary Graph Setting Panel</h4>
                <p>
                    <h5 class="text-muted">B Cell Cross-Reactivity Prediction Metrics</h5>
                    <div class="form-group">
                        <label for="selectmultiple_BCellCrossReactivityMetrics">Select columns <i class="material-icons" style="font-size:20px;cursor:pointer" data-toggle="tooltip" data-placement="right" title="Press ⌘ or Control Key to multi-select">help</i></label>
                        <select multiple class="form-control" id="selectmultiple_BCellCrossReactivityMetrics" size="9">
                            <option selected value="-log10( e-value )">-log10( e-value )</option>
                            <option selected value="score_blosum">score_blosum</option>
                            <option selected value="score_blosum_weighted">score_blosum_weighted</option>
                            <option value="avg_score_blosum_weighted">avg_score_blosum_weighted</option>
                            <option selected value="sum_of_weights">sum_of_weights</option>
                            <option selected value="score_similarity_ss8">score_similarity_ss8</option>
                            <option selected value="correl_coeffi_acc">correl_coeffi_acc</option>
                            <option selected value="correl_coeffi_phi">correl_coeffi_phi</option>
                            <option selected value="correl_coeffi_psi">correl_coeffi_psi</option>
                            <option value="correl_p_value_acc">correl_p_value_acc</option>
                            <option value="correl_p_value_phi">correl_p_value_phi</option>
                            <option value="correl_p_value_psi">correl_p_value_psi</option>
                            <option selected value="duplicate_counts">duplicate_counts</option>
                            <option selected value="identity">identity</option>
                            <option value="source_is_blastp">source_is_blastp</option>
                            <option value="structure_id_target_is_a_homology_modeling_result">structure_id_target_is_a_homology_modeling_result</option>
                            <option selected value="window_size">window_size</option>
                        </select>
                    </div>
                </p>
                <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="UpdateBCellCrossReactivityPredMetricsPlot( )">Load and Draw</button></p>
                <p>
                    <h5 class="text-muted">T Cell Cross-Reactivity Prediction Metrics</h5>
                    <div class="form-group">
                        <label for="selectmultiple_TCellCrossReactivityMetrics">Select columns <i class="material-icons" style="font-size:20px;cursor:pointer" data-toggle="tooltip" data-placement="right" title="Press ⌘ or Control Key to multi-select">help</i></label>
                        <select multiple class="form-control" id="selectmultiple_TCellCrossReactivityMetrics" size="8">
                            <option selected value="mhc_class">mhc_class</option>
                            <option selected value="score_blosum">score_blosum</option>
                            <option selected value="log10( score_geometric_mean_query )">log10( score_geometric_mean_query )</option>
                            <option selected value="log10( score_geometric_mean_target )">log10( score_geometric_mean_target )</option>
                            <option selected value="window_size">window_size</option>
                            <option value="-log10( e-value )">-log10( e-value )</option>
                            <option selected value="duplicate_counts">duplicate_counts</option>
                            <option value="source_is_blastp">source_is_blastp</option>
                        </select>
                    </div>
                </p>
                <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="UpdateTCellCrossReactivityPredMetricsPlot( )">Load and Draw</button></p>
                <p>
                    <h5 class="text-muted">Human Protein Metrics</h5>
                    <div class="form-group">
                        <label for="selectmultiple_HumanProteinMetrics">Select columns <i class="material-icons" style="font-size:20px;cursor:pointer" data-toggle="tooltip" data-placement="right" title="Press ⌘ or Control Key to multi-select">help</i></label>
                        <select multiple class="form-control" id="selectmultiple_HumanProteinMetrics" size="8">
                            <option value="Adipose Tissue (n=1204) (log10)">Adipose Tissue (n=1204) (log10)</option>
                            <option value="Adrenal Gland (n=258) (log10)">Adrenal Gland (n=258) (log10)</option>
                            <option value="Bladder (n=21) (log10)">Bladder (n=21) (log10)</option>
                            <option selected value="Blood (n=929) (log10)">Blood (n=929) (log10)</option>
                            <option selected value="Blood Vessel (n=1335) (log10)">Blood Vessel (n=1335) (log10)</option>
                            <option selected value="Brain (n=2642) (log10)">Brain (n=2642) (log10)</option>
                            <option value="Breast (n=459) (log10)">Breast (n=459) (log10)</option>
                            <option value="Cervix Uteri (n=19) (log10)">Cervix Uteri (n=19) (log10)</option>
                            <option value="Colon (n=779) (log10)">Colon (n=779) (log10)</option>
                            <option value="Esophagus (n=1445) (log10)">Esophagus (n=1445) (log10)</option>
                            <option value="Fallopian Tube (n=9) (log10)">Fallopian Tube (n=9) (log10)</option>
                            <option value="Heart (n=861) (log10)">Heart (n=861) (log10)</option>
                            <option value="Kidney (n=89) (log10)">Kidney (n=89) (log10)</option>
                            <option value="Liver (n=226) (log10)">Liver (n=226) (log10)</option>
                            <option selected value="Lung (n=578) (log10)">Lung (n=578) (log10)</option>
                            <option value="Muscle (n=803) (log10)">Muscle (n=803) (log10)</option>
                            <option selected value="Nerve (n=619) (log10)">Nerve (n=619) (log10)</option>
                            <option value="Ovary (n=180) (log10)">Ovary (n=180) (log10)</option>
                            <option value="Pancreas (n=328) (log10)">Pancreas (n=328) (log10)</option>
                            <option value="Pituitary (n=283) (log10)">Pituitary (n=283) (log10)</option>
                            <option value="Prostate (n=245) (log10)">Prostate (n=245) (log10)</option>
                            <option value="Salivary Gland (n=162) (log10)">Salivary Gland (n=162) (log10)</option>
                            <option value="Skin (n=1809) (log10)">Skin (n=1809) (log10)</option>
                            <option value="Small Intestine (n=187) (log10)">Small Intestine (n=187) (log10)</option>
                            <option value="Spleen (n=241) (log10)">Spleen (n=241) (log10)</option>
                            <option value="Stomach (n=359) (log10)">Stomach (n=359) (log10)</option>
                            <option value="Testis (n=361) (log10)">Testis (n=361) (log10)</option>
                            <option value="Thyroid (n=653) (log10)">Thyroid (n=653) (log10)</option>
                            <option value="Uterus (n=142) (log10)">Uterus (n=142) (log10)</option>
                            <option value="Vagina (n=156) (log10)">Vagina (n=156) (log10)</option>
                            
                            <option selected value="AAgAtlas___n_PubMed_ID">AAgAtlas___n_PubMed_ID</option>
                            <option selected value="IEDB___n_unique_epitopes">IEDB___n_unique_epitopes</option>
                            <option selected value="n_counts">n_counts</option>
                            <option value="seq_length">seq_length</option>
                        </select>
                    </div>
                </p>
                <p><button type="button" class="btn btn-secondary btn-block mx-2 my-2" onclick="UpdateHumanProteinMetricsPlot( )" id="button_update_human_protein_metrics_plot">Load and Draw</button></p>
            </div>
        </div>
        <div id="plotly_graph_b_cell_cross_reactivity" class="collapse graph_for_selection"></div>
        <div id="plotly_graph_t_cell_cross_reactivity" class="collapse graph_for_selection"></div>
        <div id="plotly_graph_human_protein" class="collapse graph_for_selection"></div>
        <div id="container_datatable_panel_MolecularMimicryMap" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar">
                <a class="navbar-brand mb-0 h5">Data Tables</a>
                <div class="btn-toolbar" role="toolbar">
                    <div class="input-group mr-2 ml-1 my-0">
<!--                         <div class="input-group-prepend"><label class="input-group-text" for="input_n_records_for_datatable">Display top</label></div>
                        <input type="text" class="form-control" aria-label="the number of records in the datatable to display" id="input_n_records_for_datatable" title="input field for setting the number of records for display a datatable" value="1000">
                        <div class="input-group-append"><span class="input-group-text">records for</span></div> -->
                        <select class="custom-select w-auto" id="select_datatable" title="select datatable">
                            <option value="B-cell cross-reactivity prediction">select datatable</option>
                            <option value="B-cell cross-reactivity prediction" selected>B-cell cross-reactivity prediction</option>
                            <option value="T-cell cross-reactivity prediction">T-cell cross-reactivity prediction</option>
<!--                             <option value="human proteins">human proteins</option> -->
                            <option value="MHC alleles">MHC alleles</option>
                        </select>
                        <div class="input-group-append"><span class="input-group-text">datatable</span></div>
                    </div>
                    <button type="button" class="btn btn-light mx-0 my-0" id="button_display_datatable" aria-pressed="false" onclick="Display_DataTable( )" autocomplete="off">Show</button>
                    <button class="btn btn-light ml-1 mr-2 my-0" type="button" onclick="Download_DataTable( )" data-tooltip="tooltip" data-placement="bottom" title="Press to download current datatable as a CSV file"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">get_app</i></button> 
                </div>
<!--        currently searching using the search box above the datatable is not supported       -->
<!--                 <form class="form-inline">
                    <input class="form-control" type="search" placeholder="Highlight Value" aria-label="Highlight Value" id="input_highlight_value">
                    <button class="btn btn-light mx-2 my-0" type="button" onclick="Highlight_MolecularMimicryMap( )">Highlight</button>
                    <button class="btn btn-light mx-2 my-0" type="button" onclick="Clear_Highlight_MolecularMimicryMap( )">Clear Highlight</button>
                </form> --> 
                <button type="button" class="close" aria-label="Close container_datatable_panel_MolecularMimicryMap" data-toggle="collapse" data-target="#container_datatable_panel_MolecularMimicryMap"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="container_datatable_MolecularMimicryMap"><table id="datatable_MolecularMimicryMap" class="display" width="100%"></table></div>
        </div>
        <div id="container_expression_panel_MolecularMimicryMap" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar">
                <a class="navbar-brand mb-0 h5">Expression</a>
                <div class="btn-toolbar" role="toolbar">
                </div>
                <form class="form-inline">
                    <div class="form-check form-check-inline">
                        <input id="checkbox__show__plotly_scrnaseq" type="checkbox" class="mr-2" checked data-toggle="toggle" data-on="Single-cell Expression" data-off="Single-cell Expression" data-onstyle="secondary" data-offstyle="light" data-size="sm" data-style="ios" data-width="200" onchange="Toggle_Panel( '#container_plotly_scrnaseq' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>single-cell-level expression</i> of a human protein" aria-label="">
                    </div>
                    <div class="form-check form-check-inline">
                        <input id="checkbox__show__plotly_gtex" type="checkbox" class="mr-2" checked data-toggle="toggle" data-on="GTEx Tissue" data-off="GTEx Tissue" data-onstyle="secondary" data-offstyle="light" data-size="sm" data-style="ios" data-width="120" onchange="Toggle_Panel( '#container_plotly_gtex' )" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>tissue-level expression</i> of a human protein" aria-label="">
                    </div>
<!--                     <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" onclick="Toggle_Panel( '#container_plotly_gtex' )" aria-expanded="false" aria-controls="container_plotly_gtex" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>tissue-level expression</i> of a human protein" aria-label="">GTEx Tissue</button>
                    <button class="btn btn-light btn-sm mx-1 my-0" type="button" data-toggle="button" onclick="Toggle_Panel( '#container_plotly_scrnaseq' )" aria-expanded="false" aria-controls="container_plotly_scrnaseq" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>toggle</b> graphs displaying <i>single-cell-level expression</i> of a human protein" aria-label="">Single-cell Expression</button> -->
<!--                     <input class="form-control" type="search" placeholder="Enter Gene Symbol" aria-label="Draw plot of a gene symbol" id="input_gene_symbol_expression">
                    <button class="btn btn-light mx-2 my-0" type="button" onclick="Highlight_MolecularMimicryMap( )">Plot</button> -->
                </form>
                <button type="button" class="close" aria-label="Close container_expression_panel_MolecularMimicryMap" data-toggle="collapse" data-target="#container_expression_panel_MolecularMimicryMap"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="container_plotly_scrnaseq" class="collapse show">
                <nav class="navbar navbar-dark bg-custom-navbar-secondary">
                    <div data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>open an interactive single-cell expression viewer</b> to further explore the expression of the gene at a single cell resolution" style="margin-right: 15px">
                        <a class="navbar-brand my-0" style="font-size: 1em; font-weight: bold; margin-right: 0px !important" id="expression_panel__link_to_cellxgene" href="" target="_blank" rel="noopener noreferrer">Single Cell Expression</a>
                        <i class="material-icons icon-white" style="font-size:17px;cursor:pointer">launch</i>
                    </div>
                    <div data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press to <b>open a link</b> to the publication of the current <i>single cell RNA-Seq</i> study">
                        <a class="navbar-brand my-0" style="font-size: 0.75em; font-weight: bold; margin-right: 0px !important" id="expression_panel__link_to_publication" href="" target="_blank" rel="noopener noreferrer" >Publication</a>
                        <i class="material-icons icon-white" style="font-size:14px;cursor:pointer">launch</i>
                    </div>
                    <div class="btn-toolbar mr-auto ml-auto my-0" role="toolbar">
                        <div class="input-group">
                            <select id="select__category_dataset__plotly_scrnaseq" class="form-control mr-2 w-auto" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" onchange="PlotExpression_scRNA_Seq_Update_Select_Options( )">
                                <option value="patient_donors" selected>Patient Donors</option>
                                <option value="cell_line">Lung Cell Line</option>
                                <option value="healthy_donors" >Healthy Donors</option>
                            </select>
                            <select id="select__name_dataset__plotly_scrnaseq" class="form-control mr-2 w-auto" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" onchange="PlotExpression_scRNA_Seq( )">
                                <option value="" selected>Select Category</option>
                            </select>
                            <div class="form-check form-check-inline">
                                <input id="checkbox__covid_status__plotly_scrnaseq" type="checkbox" class="mr-2" checked data-toggle="toggle" data-on="Cell Type" data-off="COVID-19 Status" data-onstyle="secondary" data-offstyle="danger" data-size="sm" data-style="ios" data-width="150" onchange="PlotExpression_scRNA_Seq( )">
                            </div>
                            <div class="form-check form-check-inline">
                                <input id="checkbox__proportion__plotly_scrnaseq" type="checkbox" checked data-toggle="toggle" data-on="Expression" data-off="Proportion" data-onstyle="success" data-offstyle="warning" data-size="sm" data-style="ios" data-width="100" onchange="PlotExpression_scRNA_Seq( )">
                            </div>
                            <div class="form-check form-check-inline">
                                <input id="checkbox__ignore_cells_with_zero_counts__plotly_scrnaseq" type="checkbox" checked data-toggle="toggle" data-on="All Cells" data-off="Only Positive Cells" data-onstyle="primary" data-offstyle="info" data-size="sm" data-style="ios" data-width="150" onchange="PlotExpression_scRNA_Seq( )">
                            </div>
                        </div>
                    </div>
                </nav>
                <div id="plotly_graph_scrnaseq_expression"></div>
            </div>
            <div id="container_plotly_gtex" class="collapse show">
                <nav class="navbar navbar-dark bg-custom-navbar-secondary">
                    <div data-toggle="tooltip" data-placement="bottom" data-html="true" title="Press to <b>open the GTEx portal</b> to explore the expression of the gene further"><a id="expression_panel__link_to_GTEx_portal" class="navbar-brand my-0" style="font-size: 1.1em; font-weight: bold; margin-right: 0px !important" href="" target="_blank" rel="noopener noreferrer">GTEx Expression</a><i class="material-icons icon-white" style="font-size:17px;cursor:pointer">launch</i></div>
                </nav>
                <div id="plotly_graph_gtex"></div>
            </div>
        </div>
        <div id="container_plotly_table_sequence" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar" style="padding-top: 5px; padding-bottom: 5px">
                <a class="navbar-brand mb-0 h5">Aligned Sequences</a>
                <form class="form-inline">
                </form>
                <button type="button" class="close" aria-label="Close container_plotly_table_sequence" data-toggle="collapse" data-target="#container_plotly_table_sequence"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="plotly_table_sequence" style="height:100px;"></div>
            <div id="description_clicked_position__table_sequence" style="text-align: center; border-top: 2px solid #6b0596; background-color: #f8f7fa; color: #000"></div>
        </div>
        <div id="container_PDB" class="collapse">
            <nav class="navbar navbar-dark bg-custom-navbar" style="padding-top: 5px; padding-bottom: 5px">
                <a class="navbar-brand mb-0 h5">Aligned Structures</a>
                <form class="form-inline">
                    <div class="input-group-prepend mx-2 my-0" style="height:30px"><a id="text_protein_structure_virus" class="input-group-text" target="_blank" rel="noopener noreferrer" href="">Virus Protein Structure</a></div>
                    <select class="form-control my-0" id="select_PDB_virus_protein_structure" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Select how to visualize the alignment result on the SARS-CoV-2 virus protein" onchange="Select_View_of_PDB_Virus_Protein( )">
                        <option value="Clear">Clear</option>
                        <option selected value="BLOSUM62 Score">BLOSUM62 Score</option>
                        <option value="BLOSUM62 Score with Side Chains">BLOSUM62 Score with Side Chains</option>
                    </select>
                    <div class="input-group-prepend mx-2 my-0" style="height:30px"><a id="text_protein_structure_human" class="input-group-text" target="_blank" rel="noopener noreferrer" href="">Human Protein Structure</a></div>
                    <select class="form-control my-0" id="select_PDB_human_protein_structure" style="text-align: center; height:30px; line-height: 0px; padding-top: 0px; padding-bottom: 0px;" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Select how to visualize the alignment result on the human protein" onchange="Select_View_of_PDB_Human_Protein( )">
                        <option value="Clear">Clear</option>
                        <option selected value="BLOSUM62 Score">BLOSUM62 Score</option>
                        <option value="BLOSUM62 Score with Side Chains">BLOSUM62 Score with Side Chains</option>
                    </select>
                </form>
                <button type="button" class="close" aria-label="Close container_PDB" data-toggle="collapse" data-target="#container_PDB"><span aria-hidden="true">&times;</span></button>
            </nav>
            <div id="PDB_Viewer" class="deconstructed_pancake_parent">
                <div class="container_molstar deconstructed_pancake_box" id="PDB_Viewer_Virus_Protein"></div>
                <div class="container_molstar deconstructed_pancake_box" id="PDB_Viewer_Human_Protein"></div>
            </div>
        </div>
    </div>
</div>
</div> 
<!-- end of current view container -->
<div class="modal fade" id="modal_choose_fasta" tabindex="-1" role="dialog" aria-labelledby="modal_choose_fasta" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="label_modal_choose_fasta">Choose FASTA files for Peptide Vaccine Candidate Inputs</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            </div>
            <div class="modal-body">
                <p>
                    <h5 class="text-muted mb-3">Load Local Fasta Files</h5>
                    <div class="card border-secondary mx-auto mb-2" style="max-width: 35rem;">
                        <div class="card-body text-secondary">
                            <h5 class="card-title">Usage of files</h5>
                            <p class="card-text">Files will be loaded and processed locally in the internet browser and will not be uploaded to any kind of servers.</p>
                            <br>
                            <h5 class="card-title">Loading Multiple FASTA Files</h5>
                            <p class="card-text">When multiple files are be given, duplicated header lines of peptide will be appended by "_dup_{duplicate index}".</p>
                        </div>
                    </div>
                    <div class="custom-file" id="container_file_vaccine_design">
                        <input type="file" class="custom-file-input" id="file_vaccine_design_fasta" multiple>
                        <label class="custom-file-label" for="file_vaccine_design_fasta">Choose FASTA file(s)</label>
                    </div>
                </p>
                <br>
                <p>
                    <h5 class="text-muted mb-3">Load Peptide Vaccine Candidates from <i>OptiVax</i></h5>
                    <p>OptiVax citation:<br><a href="https://doi.org/10.1016/j.cels.2020.06.009">Liu, G., Carter, B., Bricken, T., Jain, S., Viard, M., Carrington, M., & Gifford, D. K. (2020). Computationally Optimized SARS-CoV-2 MHC Class I and II Vaccine Formulations Predicted to Target Human Haplotype Distributions. Cell systems, 11(2), 131–144.e6.</a></p>
                    <button type="button" class="btn btn-success ml-auto mr-0 my-1" onclick="LoadOptiVax( )">Load OptiVax</button>
                </p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Done</button>
            </div>
        </div>
    </div>
</div>

<div class="modal fade" id="modal_select_peptides" tabindex="-1" role="dialog" aria-labelledby="modal_select_peptides" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="label_modal_select_peptides">Select Peptides for Peptide-Based Vaccine Design</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            </div>
            <div class="modal-body">
                <p>
                    <h5 class="text-muted">Automatic Selection through Thresholding</h5>
                    <div class="form-inline mb-2">
                        <div class="btn-group btn-group-toggle mx-2 my-1" data-toggle="buttons" id="radio__Vaccine_Design__Selection_Thresholding_Mode__Include_or_Exclude">
                            <label class="btn btn-labeled btn-outline-success active"><input type="radio" id="radio__Vaccine_Design__Selection_Thresholding_Mode__Include" value="Include" autocomplete="off" checked><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">done</i></span>Include</label>
                            <label class="btn btn-labeled btn-outline-danger"><input type="radio" id="radio__Vaccine_Design__Selection_Thresholding_Mode__Exclude" value="Exclude" autocomplete="off"><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">clear</i></span>Exclude</label>
                        </div>
                        <div class="btn-group btn-group-toggle mx-2 my-1" data-toggle="buttons" id="radio__Vaccine_Design__Selection_Thresholding_Mode__Above_or_Below">
                            <label class="btn btn-labeled btn-outline-info active"><input type="radio" id="radio__Vaccine_Design__Selection_Thresholding_Mode__Above" value="Above" autocomplete="off" checked><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">arrow_upward</i></span>Above</label>
                            <label class="btn btn-labeled btn-outline-info"><input type="radio" id="radio__Vaccine_Design__Selection_Thresholding_Mode__Below" value="Below" autocomplete="off"><span class="btn-label"><i class="material-icons icon-black" style="font-size:20px;cursor:pointer">arrow_downward</i></span>Below</label>
                        </div>
                        <input type="text" class="form-control" aria-label="length of peptides to generate" id="input_threshold_select_peptides" placeholder="a threshold value">
                        <button type="button" class="btn btn-secondary ml-auto mr-auto" style="margin-bottom:0px;" onclick="Retrieve_Selection_of_Peptides( )">Retrieve Selection</button>
                    </div>
                    <div id="modal_select_peptides_alert_container"></div>
                    <div class="btn-toolbar" role="toolbar">
                        <button type="button" id="button_apply_change_select_peptides" class="btn btn-success ml-auto mr-1 my-1" disabled onclick="Update_Selection_of_Peptides( 'apply' )">Apply</button>
                        <button type="button" id="button_undo_last_change_modal_select_peptides" class="btn btn-danger mr-auto ml-0 my-1" disabled onclick="Update_Selection_of_Peptides( 'undo_last_change' )">Undo Last Change</button>
                    </div>
                </p>
                <br>
                <p>
                    <h5 class="text-muted">Manual Selection Setting</h5>
                    <form class="form-inline">
                        <div class="btn-group btn-group-toggle mx-2 my-1" data-toggle="buttons" id="radio__Vaccine_Design__Select_Mode" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Press <b>Include/Exclude</b> to include/exclude vaccine candidate through clicking and selecting.">
                            <label class="btn btn-outline-info active">
                            <input type="radio" id="radio__Vaccine_Design__Select_Mode__Show_Info_Peptide" value="Show_Info" autocomplete="off" checked>Show Info.</label>
                            <label class="btn btn-outline-success">
                            <input type="radio" id="radio__Vaccine_Design__Select_Mode__Include_Peptide" value="Include" autocomplete="off">Include</label>
                            <label class="btn btn-outline-danger">
                            <input type="radio" id="radio__Vaccine_Design__Select_Mode__Exclude_Peptide" value="Exclude" autocomplete="off">Exclude</label>
                        </div>
                        <div class="input-group-append"><span class="input-group-text"> when click/select peptides with mousepointer/lasso/box.</span></div>
                    </form>
                </p>
                <div id="div_display_current_number_of_selected_peptides"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Done</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="modal_generate_peptides" tabindex="-1" role="dialog" aria-labelledby="modal_generate_peptides" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="label_modal_generate_peptides">Generate Peptides for Peptide-Based Vaccine Design</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            </div>
            <div class="modal-body">
                
                <h5 class="text-muted">Generate peptides from the consensus SARS-CoV-2 protein sequences</h5>
                <div class="form-inline mb-2">
                    <div class="input-group-prepend"><span class="input-group-text">Peptides are</span></div>
                    <input type="text" class="form-control" aria-label="length of peptides to generate" id="input_window_size_generate_peptides" value="25">
                    <div class="input-group-append"><span class="input-group-text">amino acids in length.</span></div>
                    <button type="button" class="btn btn-secondary ml-1" style="margin-bottom:0px;" onclick="Retrieve_Peptides( )">Generate</button>
                </div>
                <div id="modal_generate_peptides_alert_container"></div>
                <div id="div_display_current_number_of_peptides">Total number of peptides: </div>
                <div class="btn-toolbar" role="toolbar">
                    <button type="button" class="btn btn-success ml-auto mr-1 my-1" onclick="Update_Peptides( 'append' )">Append</button>
                    <button type="button" class="btn btn-danger mr-auto ml-0 my-1" onclick="Update_Peptides( 'replace' )">Replace</button>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Done</button>
            </div>
        </div>
    </div>
</div>
<div class="modal fade" id="modal_keyboard_shortcuts" tabindex="-1" role="dialog" aria-labelledby="modal_keyboard_shortcuts" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="label_modal_generate_peptides">Keyboard Shortcuts</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            </div>
            <div class="modal-body">
                <h5 class="text-muted mb-2" style="font-size:20px">General</h5>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>s</kbd><b>(screenshot)</b> to capture <b>the current view</b> and download it as a PNG file</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>i</kbd><b>(introduction)</b> to toggle the introduction and instructions</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>a</kbd><b>(information on hover)</b> to toggle the click/hover events of the main graph.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>h</kbd><b>(help messages)</b> to toggle tooltip messages that are shown when mouse pointers are on buttons.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>u</kbd><b>(UP)</b> to move to the top of the page.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>d</kbd><b>(Down)</b> to move to the bottom of the page.</p>
                <br>
                <h5 class="text-muted mb-2" style="font-size:20px">Peptide Vaccine Design</h5>
                <p>Press <kbd>a</kbd><b>(add)</b> when clicking/selecting peptides to include peptides in the selection.</p>
                <p>Press <kbd>r</kbd><b>(remove)</b> when clicking/selecting peptides to exclude peptides from the selection.</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>r</kbd><b>(reset)</b> to reset selection of peptides.</p>
                <br>
                <h5 class="text-muted mb-2" style="font-size:20px">Panel Control</h5>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>b</kbd><b>(B-cell Cross Reactivity Pred.)</b> to show/hide the parallel coordinates plot showing B-cell cross reactivity prediction metrics</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>g</kbd><b>(T-cell Cross Reactivity Pred.)</b> to show/hide the parallel coordinates plot showing T-cell cross reactivity prediction metrics</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>p</kbd><b>(Human <i>P</i>rotein)</b> to show/hide the parallel coordinates plot for filtering human proteins</p>
                <p>Press <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> + <kbd>t</kbd><b>(Table)</b> to show/hide the DataTable panel</p>
                <br>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-dismiss="modal">Okay</button>
            </div>
        </div>
    </div>
</div>
<!-- fullscreen introduction modal -->
<div id="modal_introduction" class="modal fade show" tabindex="-1" role="dialog" aria-labelledby="modal_introduction" aria-hidden="true" style="padding-right: 0px!important;"> <!-- disable fading when the web page has been loaded -->
  <div class="modal-dialog" style="width: 100%!important;height: 100%!important;margin: 0!important;padding: 0!important;max-width:none !important;">
    <div class="modal-content" style="height: auto !important; min-height: 100% !important; border-radius: 0 !important;min-width: 100% !important;">
        <nav class="navbar navbar-expand-lg navbar-dark bg-custom-navbar"> <!-- sticky-top -->
            <a class="navbar-brand mb-0 h1">Molecular Mimicry Map of SARS-CoV-2</a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav_top" aria-controls="navbarNav_top" aria-expanded="false" aria-label="Toggle top navigation"><span class="navbar-toggler-icon"></span></button>
            <div class="collapse navbar-collapse" id="navbarNav_top">
                <ul class="navbar-nav">
<!--                     <li class="nav-item">
                        <a class="nav-link">Citation</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link">Feedback</a>
                    </li> -->
                </ul>
            </div>
        </nav>
            <div class="modal-header">
                <h1 class="modal-title">Introduction</h1>
                <button class="btn btn-link btn-lg mt-2 mr-auto" onclick="Toggle_Introduction_Modal();">Skip Introduction</button>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            </div>
            <div class="modal-body">
                <h2></h2>
                <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.cover.PNG" alt="introduction images" style="min-width:50%;max-width:90%;display: block;margin-left: auto;margin-right: auto;">
                <br>
                <div class="card mx-auto my-2" style="max-width: 60rem;">
                    <div class="card-body">
                        <h2 class="card-title">Abstract</h2>
                        <p class="card-text">The development of autoimmune diseases following SARS-CoV-2 infection, including multisystem inflammatory syndrome, has been reported, and several mechanisms have been suggested, including molecular mimicry. We developed a novel pipeline to identify cross-reactive epitopes between SARS-CoV-2 and human proteins using the structural properties of the proteins. Overall, by searching 4,911,245 proteins from 196,352 SARS-CoV-2 genomes, we identified 133 and 648 human proteins harboring potential cross-reactive B-cell and CD8+ T-cell epitopes, respectively. To demonstrate the robustness of our pipeline, we predicted the cross-reactive epitopes of coronavirus spike proteins, which were recognized by known cross-neutralizing antibodies. Using single-cell expression data, we identified PARP14 as a potential target of intermolecular epitope spreading between the virus and human proteins. Finally, we developed a web application (https://ahs2202.github.io/3M/) to interactively visualize our results. Overall, our immunoinformatic resources provide a foundation for the investigation of molecular mimicry in the pathogenesis of autoimmune and chronic inflammatory diseases following COVID-19.</p>
                    </div>
                    <div class="mr-auto ml-auto"><a href="https://doi.org/10.1101/2020.11.12.344424" style="font-size: 1.35em; font-weight: bold" target="_blank" rel="noopener noreferrer" class="btn btn-link btn-sm mx-1 my-0" role="button" data-toggle="button" data-tooltip="tooltip" data-placement="bottom" data-html="true" title="Click to view our BioRXiv preprint">BioRXiv preprint<i class="material-icons icon-black" style="font-size: 0.9em">launch</i></a></div>
                </div>
<!--                 <h5 class="text-muted">This program has been developed by Hyunsu An at Gwangju Institute of Science and Technology under the supervision of Professor JiHwan Park.</h5> -->
<!--                 <div class="card border-primary mx-auto my-2" style="max-width: 50rem;">
                    <div class="card-header">Instruction</div>
                    <div class="card-body text-primary">
                        <h5 class="card-title">basic usage</h5>
                        <p class="card-text">Click points to see details.</p>
                    </div>
                </div> -->
                <h1 class="modal-title">Usages</h1>
                <div id="carouselExampleIndicators" class="carousel slide" data-ride="carousel">
                    <ol class="carousel-indicators">
                        <li data-target="#carouselExampleIndicators" data-slide-to="0" class="active"></li>
                        <li data-target="#carouselExampleIndicators" data-slide-to="1"></li>
                        <li data-target="#carouselExampleIndicators" data-slide-to="2"></li>
                    </ol>
                    <div class="carousel-inner">
                        <div class="carousel-item active">
                            <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.usage_main_graph.PNG" class="d-block w-100 mx-auto" style="max-width: 1700px !important;" alt="Explore cross-reactive immune epitopes">
                            <div class="carousel-caption d-none d-md-block">
                                <h2>Explore cross-reactive immune epitopes</h2>
                                <p>Toggle <b>help messages</b> by pressing <kbd>Cmd</kbd> + <kbd>H</kbd><br>Keyboard shorcuts can be found at the upper right corner</p>
                            </div>
                        </div>
                        <div class="carousel-item">
                            <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.usage_filter.PNG" class="d-block w-100 mx-auto" style="max-width: 1700px !important;" alt="Filter cross-reactive immune epitopes">
                            <div class="carousel-caption d-none d-md-block">
                                <h2>Filter cross-reactive immune epitopes</h2>
                                <p>Multiple filters can be applied.<br>To remove a filter, click the filter again</p>
                            </div>
                        </div>
                        <div class="carousel-item">
                            <img src="https://ahs2202.github.io/3M/images/3M_of_SARS-CoV-2.usage_aligned_structures.PNG" class="d-block w-100 mx-auto" style="max-width: 1700px !important;" alt="Visualize Aligned Structures">
                            <div class="carousel-caption d-none d-md-block">
                                <h2>Visualize Aligned Structures</h2>
                                <p>Click a row in the aligned sequence table to highlight a pair of aligned residues on virus and human structures<br>When protein structure is not available, a black screen will be shown</p>
<!--                                 Change the representation of protein structure <i>(Control Panel > Components > Polymer > Actions > Add Representation > Molecular Surface)</i><br> -->
                            </div>
                        </div>
                    </div>
                    <a class="carousel-control-prev" href="#carouselExampleIndicators" role="button" data-slide="prev">
                        <span class="carousel-control-prev-icon" aria-hidden="true"></span>
                        <span class="sr-only">Previous</span>
                    </a>
                    <a class="carousel-control-next" href="#carouselExampleIndicators" role="button" data-slide="next">
                        <span class="carousel-control-next-icon" aria-hidden="true"></span>
                        <span class="sr-only">Next</span>
                    </a>
                </div>
                <h5 class="text-muted" style="text-align:center;">This program has been developed by Hyunsu An at Gwangju Institute of Science and Technology under the supervision of Professor JiHwan Park.</h5>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary btn-lg btn-block" data-dismiss="modal">Start!</button>
            </div>
        </div>
    </div>
</div>
<div id="loading_screen"></div>
<script>
// packages
var DragSort=function(t){var e,i=0,s={},r={},a=(e=window.MutationObserver||window.WebKitMutationObserver,function(t,i){t&&1===t.nodeType&&(e?new e((function(t,e){i(t)})).observe(t,{childList:!0,subtree:!1}):window.addEventListener&&t.addEventListener("DOMNodeInserted",i,!1))});function n(t,e){if(!t)return this;e=e||{},this.parentElm=t,this.uid=e.uid,this.settings={selector:"*",callbacks:{}},Object.assign(this.settings,e),this.setup(),a(this.parentElm,this.setup.bind(this)),this.bindEvents()}return n.prototype={namespace:"dragsort",setup(){[...this.parentElm.childNodes].forEach(t=>{if(1!=t.nodeType)return t.parentNode.removeChild(t);t.matches(this.settings.selector)&&(t.draggable=!0)}),this.gap=this.getItemsGap(this.parentElm.firstElementChild)},throttle(t,e){var i=!1,s=this;return function(r){i||(t.call(s,r),i=!0,setTimeout(()=>i=!1,e))}},getDraggableElm(t){var e=t.closest('[draggable="true"]');return this.uid==s.uid?e:null},dragstart(t,e){s=this;var i,r=this.getDraggableElm(e);r?(this.source=this.getInitialState(),this.target=this.getInitialState(),i=r.getBoundingClientRect(),this.source.elm=r,this.source.idx=this.getNodeIndex(r),this.source.size.width=i.width,this.source.size.height=i.height,t.dataTransfer.effectAllowed="move",setTimeout(this.afterDragStart.bind(this))):s={}},afterDragStart(){var t="vertical"==this.settings.mode?"height":"width";this.parentElm.classList.add(this.namespace+"--dragStart"),this.source.elm.style[t]=this.source.size[t]+"px",this.source.elm.classList.add(this.namespace+"--dragElem")},dragover(t){t.preventDefault(),t.stopPropagation();var e=t.target;if((e=this.getDraggableElm(e))&&this.target){var i=this.target.elm,s=this.target.hoverDirection;t.dataTransfer.dropEffect="move",this.target.hoverDirection=this.getTargetDirection(t),i==e&&s==this.target.hoverDirection||this.directionAwareDragEnter(t,e)}},dragenter(t,e){(e=this.getDraggableElm(e))&&this.target&&this.isValidElm(e)&&this.source.elm!=e&&this.source.elm&&(this.target.bounding=e.getBoundingClientRect())},directionAwareDragEnter(t,e){var i;t.preventDefault(),t.stopPropagation(),t.dataTransfer.dropEffect="none",this.isValidElm(e)&&this.source.elm!=e&&this.source.elm&&(t.dataTransfer.dropEffect="move",this.cleanupLastTarget(),this.target.elm=e,this.target.idx=this.getNodeIndex(e),e.classList.add("over"),i=Math.abs(this.target.idx-this.source.idx),this.source.elm.classList.toggle(this.namespace+"--hide",i>0),"vertical"==this.settings.mode?this.target.elm.style[this.target.hoverDirection?"marginBottom":"marginTop"]=this.source.size.height+this.gap+"px":this.target.elm.style[this.target.hoverDirection?"marginRight":"marginLeft"]=this.source.size.width+this.gap+"px")},dragend(t){if(clearTimeout(this.dragoverTimeout),this.dragoverTimeout=null,this.parentElm.classList.remove(this.namespace+"--dragStart"),!this.isValidElm(this.target.elm))return this.cleanup();var e=this.target.hoverDirection?this.target.elm.nextElementSibling:this.target.elm;return this.source.elm!=this.target.elm&&this.target.elm&&(this.target.elm.classList.add(this.namespace+"--noAnim"),this.cleanup(),this.parentElm.insertBefore(this.source.elm,e)),this.source.elm&&this.source.elm.classList.remove(this.namespace+"--dragElem",this.namespace+"--hide"),this.settings.callbacks.dragEnd(this.source.elm),this},isTargetLastChild(){return this.parentElm.lastElementChild==this.target.elm},getTargetDirection(t){if(this.target.bounding)return"vertical"==this.settings.mode?t.pageY>this.target.bounding.top+this.target.bounding.height/2?1:0:t.pageX>this.target.bounding.left+this.target.bounding.width/2?1:0},getNodeIndex(t){for(var e=0;t=t.previousSibling;)3==t.nodeType&&/^\s*$/.test(t.data)||e++;return e},isValidElm(t){return t&&t.nodeType&&t.parentNode==this.parentElm},cleanup(){s={},[...this.parentElm.children].forEach(t=>{t.removeAttribute("style"),setTimeout(()=>{t.classList.remove(this.namespace+"--over",this.namespace+"--noAnim",this.namespace+"--dragElem")},50)})},cleanupLastTarget(){this.target.elm&&(this.target.elm.classList.remove(this.namespace+"--hide",this.namespace+"--over"),this.target.elm.removeAttribute("style"))},getInitialState:()=>({elm:null,size:{}}),getItemsGap(t){var e=getComputedStyle(t);return"vertical"==this.settings.mode?parseInt(e.marginTop)+parseInt(e.marginBottom):parseInt(e.marginLeft)+parseInt(e.marginRight)},bindEvents(t){for(var e in this.listeners=this.listeners||{dragstart:t=>this.dragstart(t,t.target),dragenter:t=>this.dragenter(t,t.target),dragend:t=>this.dragend(t,t.target),dragover:this.throttle(this.dragover,350)},this.listeners)this.parentElm[t?"removeEventListener":"addEventListener"](e,this.listeners[e])},destroy(){this.cleanup(),this.bindEvents(!0),delete r[this.uid]}},function(t,e){return r[++i]=t._DragSort?r[t._DragSort]:new n(t,{...e,uid:i}),t._DragSort=i,r[i]}}();

    // define shortcuts 
    object_data_keydown = { dict_status: { } };
    function Record_KeyDown( event ) { // Record pressed keyborad keys, and trigger appropriate function when key is pressed.
        object_data_keydown.dict_status[ event.key ] = event.type; // record event.type for each key
    }
    window.addEventListener( "keyup", Record_KeyDown );
    window.addEventListener( "keypress", Record_KeyDown );
    window.addEventListener( "keydown", Record_KeyDown );
    
    hotkeys( 'ctrl+t,ctrl+a,ctrl+s,ctrl+r,ctrl+b,ctrl+g,ctrl+d,ctrl+h,ctrl+i,ctrl+u,ctrl+p,command+t,command+a,command+s,command+r,command+b,command+g,command+d,command+h,command+i,command+u,command+p', function ( event, handler ) {
        event.preventDefault( );
        switch ( handler.key ) {
            case 'ctrl+s': 
            case 'command+s': 
                DownloadCurrentView( ); 
                break;
            case 'ctrl+r': 
            case 'command+r': 
                // reset selection of peptides
                dataset.vaccine_design.selection.l_selected_current = ArrayFull( dataset.vaccine_design.dict_data[ "selected" ].length, true );
                dataset.vaccine_design.selection.l_selected_previous = dataset.vaccine_design.dict_data[ "selected" ];
                document.getElementById( "button_apply_change_select_peptides" ).disabled = true;
                document.getElementById( "button_undo_last_change_modal_select_peptides" ).disabled = false;
                dataset.vaccine_design.dict_data[ "selected" ] = dataset.vaccine_design.selection.l_selected_current;
                Draw_DesignedVaccineTrace( "update_selection" ); // update selection
                break;
            case 'ctrl+a': 
            case 'command+a': 
                $( "#button_toggle_hovermode_MolecularMimicryMap" ).click( );
                break;
            case 'ctrl+b': 
            case 'command+b': 
                Toggle_Exclusive_Tabs( '#plotly_graph_b_cell_cross_reactivity' );
                break;
            case 'ctrl+g': 
            case 'command+g': 
                Toggle_Exclusive_Tabs( '#plotly_graph_t_cell_cross_reactivity' );
                break;
            case 'ctrl+t': 
            case 'command+t': 
                Toggle_Exclusive_Tabs( '#container_datatable_panel_MolecularMimicryMap' );
                break;
            case 'ctrl+d': // scroll to the bottom of the page
            case 'command+d': 
                Scroll_to_the_Bottom( ); 
                break;
            case 'ctrl+p': 
            case 'command+p': 
                Toggle_Exclusive_Tabs( '#plotly_graph_human_protein' );
                break;
            case 'ctrl+h': 
            case 'command+h': 
                Toggle_Tooltips( ); 
                break;
            case 'ctrl+i': 
            case 'command+i': 
                Toggle_Introduction_Modal( ); 
                break;
            case 'ctrl+u': 
            case 'command+u': 
                Scroll_to_the_Top( ); 
                break;
            default: alert(event);
        }
    }); 
    function Toggle_Introduction_Modal( ) { 
        $( '#modal_introduction' ).modal( 'toggle' );
        document.getElementById( "modal_introduction" ).style[ "padding-right" ] = "0px";
    } // Toggle Modal for an Introduction 
    
    var object_data = { }; // an object containing data
    object_data.file = { };
    object_data.file.base_url = "https://raw.githubusercontent.com/ahs2202/3M/master/";
    object_data.file.dict_dir_file_to_parsed_data = { };
    object_data.data = { };
    object_data.data.dict_dir_file_to_dictarr = { };
    object_data.main = { };
    object_data.main.dataset = { }; // object storing loaded data of datasets
    object_data.main.gene = { };
    object_data.main.dictionary_human_gene_symbol_lower_case_to_color = { }; // colormap mapping gene_symbol to color
    object_data.main.dictionary_virus_species_to_color = { }; // colormap mapping str_virus_species to color
    object_data.setting = { };
    object_data.setting.plot = { };
    object_data.flag = { };
    object_data.plot = { BCell : { }, TCell : { }, MolecularMimicryMap : { } };
    var object_data_remote_file = { }; // define values for downloading files in remote locations
    object_data.file.l_n_records_for_each_step = [ 1000, 2000, 5000, 10000, 20000, 40000, 80000, 160000 ];
    object_data.file.dict_name_dataset_to_dict_bcell_crossreactivity_data_to_n_records = {
        'cr.gisaid.allprot1114.and.non_SARS_CoV_2_coronavirus_20201214': {'nonredundant_sequence': {'5': 40000, '8': 40000, '11': 40000, '14': 40000, '17': 40000, '20': 40000, '25': 40000, '30': 40000, '35': 40000, '45': 40000, '55': 40000, '70': 40000, '85': 40000, '100': 40000, '125': 40000, '150': 40000 },
        'nonredundant_position': {'5': 40000, '8': 40000, '11': 40000, '14': 40000, '17': 40000, '20': 40000, '25': 40000, '30': 40000, '35': 40000, '45': 40000, '55': 40000, '70': 40000, '85': 40000, '100': 40000, '125': 40000, '150': 40000}},
        'non_SARS_CoV_2_coronavirus_20201214.valid.nonredundant': {'nonredundant_position': {'5': 40000, '8': 40000, '11': 40000, '14': 40000, '17': 40000, '20': 40000, '25': 40000, '30': 20000, '35': 20000, '45': 39054, '55': 30920, '70': 22061, '85': 15532, '100': 10931, '125': 6509, '150': 3761},
        'nonredundant_sequence': {'5': 40000, '8': 40000, '11': 40000, '14': 40000, '17': 40000, '20': 40000, '25': 40000, '30': 40000, '35': 40000, '45': 40000, '55': 40000, '70': 20000, '85': 34737, '100': 24446, '125': 13576, '150': 7066}},
        'gisaid.allprot1114.valid.nonredundant': {'nonredundant_position': {'5': 40000, '8': 40000, '11': 40000, '14': 40000, '17': 40000, '20': 40000, '25': 40000, '30': 40000, '35': 40000, '45': 20000, '55': 38588, '70': 26000, '85': 16064, '100': 9917, '125': 4222, '150': 2052},
        'nonredundant_sequence': {'5': 40000, '8': 40000, '11': 40000, '14': 40000, '17': 40000, '20': 40000, '25': 40000, '30': 40000, '35': 40000, '45': 40000, '55': 40000, '70': 40000, '85': 40000, '100': 40000, '125': 20000, '150': 28706}},
        'NCBI_Virus_human_host_SARS_CoV_2': {'nonredundant_sequence': {'5': 22636, '8': 26133, '11': 28607, '14': 30387, '17': 31615, '20': 31979, '25': 31344, '30': 30205, '35': 29313, '45': 27691, '55': 24883, '70': 20278, '85': 15168, '100': 9864, '125': 6402, '150': 3241},
        'nonredundant_position': {'5': 19136, '8': 19931, '11': 19871, '14': 19531, '17': 18843, '20': 17697, '25': 15612, '30': 13858, '35': 12405, '45': 9906, '55': 7656, '70': 5069, '85': 3372, '100': 2106, '125': 1170, '150': 568}}};
    object_data.file.dict_name_dataset_to_dict_tcell_crossreactivity_data_to_n_records = {
        'non_SARS_CoV_2_coronavirus_20201214.valid.nonredundant': {'nonredundant_aligned_position': 35259, 'nonredundant_aligned_sequence': 20000, 'all': 20000},
        'gisaid.allprot1114.valid.nonredundant': {'nonredundant_aligned_sequence': 40000, 'all': 40000, 'nonredundant_aligned_position': 20000},
        'NCBI_Virus_human_host_SARS_CoV_2': {'nonredundant_aligned_sequence': 38824, 'nonredundant_aligned_position': 23868, 'all': 20000}};
    
    // when document is ready for interaction
    $(document).ready( function( ) {
        $('[data-toggle="tooltip"]').tooltip( ); // enable tooltips
        $('[data-tooltip="tooltip"]').tooltip( );
        $('[data-tooltip-always-active="tooltip"]').tooltip( );
        document.getElementById( 'button_toggle_hovermode_MolecularMimicryMap' ).click( ); // set initial status
        $( '#modal_introduction' ).modal( 'show' ); // show introduction modal
        Toggle_Tooltips( ); // set tooltips status
        object_plot_MolecularMimicryMap.hovermode = "closest"; // set initial status
        Initialize( );
    });
    async function Initialize( ) { // initialize the web application
        // initialize flags
        object_data.flag.vaccine_design_optivax_loaded = false;
        // load default dataset 
        await Load_Dataset( );
        console.log( "[Initialize] processing of parsed data completed:", Object.keys( object_data.file.dict_dir_file_to_parsed_data ) );
        Loading_Screen( false );
        // show an example potentially cross-reactive B-cell epitope after loading
        ClickCallBack_BCellCrossReactivity( 127 ); 
    }
    
    async function Load_Dataset( ) { // function triggered when setting for loading dataset is altered.
        // retrieve updated setting
        object_data.main.name_dataset = document.getElementById( 'select_dataset' ).value; // retrieve selected name_dataset
        object_data.flag.human_label_represents_virus = object_data.main.name_dataset.slice( 0, 3 ) == "cr." // set flag indicating whether 'human' label represent another virus proteins
        object_data.flag.cross_reactive_mhc_ligand_data_exist = object_data.main.name_dataset.slice( 0, 3 ) != "cr." // set the flag indicating whether prediction of cross-reactive MHC-ligands has been included in the dataset
        object_data.setting.name_acc_human = ( object_data.flag.human_label_represents_virus ) ? "value" : "Gene_Symbol"; // set column name contianing names of acc_human records
        if ( object_data.main.name_dataset.slice( 0, 3 ) == "cr." ) { // if a dataset of cross-reactivity between viruses has been selected
            document.getElementById( "toggle_alignment_mode" ).disabled = false; // enable the toggle button
            if ( ! $('#toggle_alignment_mode').prop( 'checked' ) ) {
                $( "#toggle_alignment_mode" ).bootstrapToggle( 'on' ); // only 'Alignment to virus' mode is available for coronavirus cross-reactivity dataset
                return -1; // exit (turning the toggle off will trigger another function call with different setting)
            }
            document.getElementById( "toggle_alignment_mode" ).disabled = true; // disable the toggle button
        } else if ( object_data.main.name_dataset.includes( "coronavirus" ) ) {
            document.getElementById( "toggle_alignment_mode" ).disabled = false; // enable the toggle button
            if ( $('#toggle_alignment_mode').prop( 'checked' ) ) {
                $( "#toggle_alignment_mode" ).bootstrapToggle( 'off' ); // only 'Alignment to human' mode is available for common cold coronavirus dataset
                return -1; // exit (turning the toggle off will trigger another function call with different setting)
            }
            document.getElementById( "toggle_alignment_mode" ).disabled = true; // disable the toggle button
        } else {
            document.getElementById( "toggle_alignment_mode" ).disabled = false; // enable the toggle button
        }
        object_data.flag.alignment_to_virus = document.getElementById( "toggle_alignment_mode" ).checked; // retrieve alignment mode
        
        let l_dir_file = [ ]; // retrieve list of files of remote locations for loading datasets
        if ( object_data.flag.alignment_to_virus ) { // show alignment to reference virus genomes
            Loading_Screen( true );
            object_data.main.l_name_dataset = [ object_data.main.name_dataset ]; // number of used dataset is 1
            console.log( "[Load_Dataset] " + object_data.main.name_dataset + " dataset selected" );
            let l_name_file = [ "BCellCrossReactivity.nonredundant_position.windowSize_30.top_1000.tsv.gz.base64.txt", 
                                "structural_property_virus__compact__for_web_application.tsv.gz.base64.txt", 
                                "structural_property_human__compact__for_web_application.tsv.gz.base64.txt",  
                                "alignment_virus_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                "alignment_human_virus__compact__for_web_application.tsv.gz.base64.txt", 
                                "alignment_human_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                "blosum62.tsv.gz.base64.txt", 
                                "acc_virus.tsv.gz.base64.txt", 
                                "acc_pdb.tsv.gz.base64.txt", 
                                "acc_human.tsv.gz.base64.txt",
                                "acc_virus_representative.tsv.gz.base64.txt", 
                                "interpro_virus.tsv.gz.base64.txt", 
                                "iedb_epitope_virus.tsv.gz.base64.txt" ]; 
            if ( ! object_data.flag.human_label_represents_virus ) { // if 'human' label represents actuall human proteins, add several files
                l_name_file.push( ... [ 
                    "TCellCrossReactivity.nonredundant_aligned_position.top_1000.tsv.gz.base64.txt", 
                    "algorithms.tsv.gz.base64.txt", 
                    "mhc_allele.tsv.gz.base64.txt", 
                    "gtex.tsv.gz.base64.txt", 
                    "scrnaseq.metadata.tsv.gz.base64.txt" ] );
            }
            let dir_folder = object_data.file.base_url + "data/base64/" + object_data.main.name_dataset + "/" // retrieve directory of the current folder of the current dataset
            l_dir_file = l_name_file.map( ( name_file ) => { return dir_folder + name_file; } ); // retrieve remote directory for the core data files for the visualization of records aligned to virus
        } else { // show alignment to human proteins
            object_data.main.l_name_dataset = object_data.main.name_dataset.includes( "coronavirus" ) ? [ object_data.main.name_dataset ] : [ object_data.main.name_dataset, 'non_SARS_CoV_2_coronavirus_20201214.valid.nonredundant' ]; // number of datasets can be either one (common cold coronavirus only) or two (comparison) // add common cold dataset as a second dataset (supplementary data) for comparison if SARS-CoV-2 virus is chosen
            for ( let i = 0; i < object_data.main.l_name_dataset.length; i ++ ) {
                let l_name_file = [ "TCellCrossReactivity.nonredundant_aligned_position.top_1000.tsv.gz.base64.txt", 
                                    "BCellCrossReactivity.nonredundant_position.windowSize_30.top_1000.tsv.gz.base64.txt", 
                                    "structural_property_virus__compact__for_web_application.tsv.gz.base64.txt", 
                                    "structural_property_human__compact__for_web_application.tsv.gz.base64.txt",  
                                    "alignment_virus_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                    "alignment_human_virus__compact__for_web_application.tsv.gz.base64.txt", 
                                    "alignment_human_pdb__compact__for_web_application.tsv.gz.base64.txt", 
                                    "mhc_allele.tsv.gz.base64.txt", 
                                    "blosum62.tsv.gz.base64.txt", 
                                    "algorithms.tsv.gz.base64.txt", 
                                    "acc_virus.tsv.gz.base64.txt", 
                                    "acc_pdb.tsv.gz.base64.txt", 
                                    "acc_human.tsv.gz.base64.txt",
                                    "interpro_human.tsv.gz.base64.txt", 
                                    "iedb_epitope_human.tsv.gz.base64.txt", 
                                    "gtex.tsv.gz.base64.txt", 
                                    "scrnaseq.metadata.tsv.gz.base64.txt" ];
                l_dir_file.push( ... l_name_file.map( ( name_file ) => { return object_data.file.base_url + "data/base64/" + object_data.main.l_name_dataset[ i ] + '/' + name_file; } ) ); // retrieve remote directories for the core data files for the visualization of records aligned to human
            }
        }
        await LoadRemoteData( l_dir_file ); // load files for the selected dataset 
        console.log( "[Load_Dataset] loading remote data completed" );
        await ParseData( ); // parse loaded data
        console.log( "[Load_Dataset] parsing data completed" );
        Loading_Screen( false );
    } // load selected dataset
//     <input name='tags' id='searchbox_main' placeholder='Enter Gene Symbol' value='PARP14' data-blacklist='.NET,PHP'>
    var searchbox_main = document.getElementById( 'searchbox_main' ), tagify_searchbox_main = { };
    object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached = false;
    function Tagify_color_tag( tag ) { // change colors of Tagify.js tag 
        let str_entry = tag.innerText
        if ( object_data.main.set_human_gene_symbol.has( str_entry ) ) { // if entry is human_gene_symbol (case insensitive)
            if ( object_data.flag.alignment_to_virus ) {
                if ( object_data.flag.human_label_represents_virus ) {
                    
                } else {
                    let color_hex_bg = object_data.main.dictionary_human_gene_symbol_lower_case_to_color[ str_entry.toLowerCase( ) ];
                    tag.style = ( ColorGetDarkness( color_hex_bg ) < 40 ) ? `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg} --tag-text-color white` : `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg}`;
                }
            } else {

            }
        }
        else if ( str_entry in object_data.main.dictionary_virus_species_to_color ) { // if entry is virus_species (case sensitive)
            if ( object_data.flag.alignment_to_virus ) {
                if ( object_data.flag.human_label_represents_virus ) {
                    let color_hex_bg = object_data.main.dictionary_virus_species_to_color[ str_entry ];
                    tag.style = ( ColorGetDarkness( color_hex_bg ) < 40 ) ? `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg} --tag-text-color white` : `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg}`;
                } else {
                    
                }
            } else {
                let color_hex_bg = object_data.main.dictionary_virus_species_to_color[ str_entry ];
                tag.style = ( ColorGetDarkness( color_hex_bg ) < 40 ) ? `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg} --tag-text-color white` : `--tag-bg: ${color_hex_bg}; --tag-hover: ${color_hex_bg}`;
            }
        }
    }
    function Tagify_Preview( str_entry ) { // show preview of the number of record
        // show preview of the number of record
        let dict_BCell = { },
            dict_TCell = { }; // initialize dictionary-based indices
        if ( object_data.main.set_human_gene_symbol.has( str_entry ) ) { // if entry is human_gene_symbol (case insensitive)
            str_entry = str_entry.toUpperCase( );
            dict_BCell = object_plot_BCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index;
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
                dict_TCell = object_plot_TCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index;
            }
        } else if ( str_entry in object_data.main.dictionary_virus_species_to_color ) { // if entry is virus_species (case sensitive)
            dict_BCell = object_plot_BCellCrossReactivity.dictionary_virus_species_to_l_index;
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
                dict_TCell = object_plot_TCellCrossReactivity.dictionary_virus_species_to_l_index;
            }
        }
        // compose a string showing preview of the current input 
        let str_preview = `${( str_entry in dict_BCell ) ? dict_BCell[ str_entry ].length : 0}/${object_plot_BCellCrossReactivity.arr_data_all.length} B-cell records`;
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
            str_preview = str_preview + `, ${( str_entry in dict_TCell ) ? dict_TCell[ str_entry ].length : 0}/${object_plot_TCellCrossReactivity.arr_data_all.length} T-cell records`;
        }
        document.getElementById( "text_number_of_records" ).innerText = str_preview;
    }
    function Initialize_SearchBox_Main( ) {
        if ( 'destroy' in tagify_searchbox_main ) {
            tagify_searchbox_main.destroy( ); // if tagify has been already attached, destroy the previous tagify element before initializing new one.
            object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached = false;
        }
        let l_name_dataset = object_data.main.l_name_dataset,
            l_whitelist = [ ], l_virus_species = [ ], set_human_gene_symbol = new Set( ), set_virus_species = new Set( );
        // retrieve unique elements for retrieving a whitelist
        for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
            let dataset = object_data.main.dataset[ l_name_dataset[ index_dataset ] ];
            dataset.l_virus_species.forEach( item => set_virus_species.add( item ) ); // collect unique elements using set // add virus species of a dataset (for the records of all human_proteins)
        }
        // collect unique elements using set // human proteins
        Object.keys( object_plot_BCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index ).forEach( item => set_human_gene_symbol.add( item ) ); 
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
            Object.keys( object_plot_TCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index ).forEach( item => set_human_gene_symbol.add( item ) ); 
        }
        // makes set of virus and human gene symbol available to external functions
        object_data.main.set_human_gene_symbol = set_human_gene_symbol;
        object_data.main.set_virus_species = set_virus_species;
        
        // convert sets to a list 
        l_whitelist.push( ... set_human_gene_symbol ); 
        l_whitelist.push( ... set_virus_species ); 
        // retrieve list of virus species
        l_virus_species.push( ... set_virus_species );
        // attach tagify to the search box
        tagify_searchbox_main = new Tagify( searchbox_main, {
            dropdown: { 
                maxItems: 7,
                enabled: 0,
                position: 'text', // enable minimal sizing of a dropdown list
                highlightFirst: true, // enable enhanced autocomplete feature
            },
            maxTags: 1000,
            editTags: false, // disable editing
            enforceWhitelist: true, whitelist: l_whitelist
        });
        for ( let i = 0; i < l_virus_species.length; i ++ ) {
            let str_virus_species = l_virus_species[ i ];
            if ( tagify_searchbox_main.isTagDuplicate( str_virus_species ) == 0 ) {
                tagify_searchbox_main.addTags( str_virus_species );
            }
        }
        
        // color existing elements
        tagify_searchbox_main.getTagElms( ).forEach( Tagify_color_tag );
        // Chainable event listeners
        tagify_searchbox_main
              .on( 'add', e => { 
            console.log( "onAddTag: ", e.detail.data.value );
            let str_entry = e.detail.data.value, // retrieve entry
                tag = e.detail.tag;
            // color newly added elements
            Tagify_color_tag( tag );
            // highlight record and draw plots for a human protein
            if ( set_human_gene_symbol.has( str_entry ) ) { // if entry is human_gene_symbol (case insensitive)
                let human_gene_symbol_upper_case = str_entry.toUpperCase( );
                if ( object_data.flag.alignment_to_virus ) {
                    Highlight_Records_MolecularMimicryMap( human_gene_symbol_upper_case, "dictionary_human_gene_symbol_upper_case_to_l_index" ); // highlight a human gene
                } else {
                    DrawMolecularMimicryMap_for_a_human_gene( human_gene_symbol_upper_case ); // draw plot of a human gene
                }
            }
            else if ( str_entry in object_data.main.dictionary_virus_species_to_color ) { // if entry is virus_species (case sensitive)
                if ( object_data.flag.alignment_to_virus ) {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_virus_species_to_l_index" ); // highlight a virus species
                } else {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_virus_species_to_l_index" ); // highlight a virus species
                }
            }
        } )
              .on( 'click', e => { 
            console.log( "onClickTag: ", e.detail.data.value );
            
            let str_entry = e.detail.data.value, // retrieve entry
                tag = e.detail.tag;
            // color newly added elements
            Tagify_color_tag( tag );
            // highlight record and draw plots for a human protein
            if ( set_human_gene_symbol.has( str_entry ) ) { // if entry is human_gene_symbol (case insensitive)
                let human_gene_symbol_upper_case = str_entry.toUpperCase( );
                if ( object_data.flag.alignment_to_virus ) {
                    Highlight_Records_MolecularMimicryMap( human_gene_symbol_upper_case, "dictionary_human_gene_symbol_upper_case_to_l_index" ); // highlight a human gene
                } else {
                    DrawMolecularMimicryMap_for_a_human_gene( human_gene_symbol_upper_case ); // draw plot of a human gene
                }
            }
            else if ( str_entry in object_data.main.dictionary_virus_species_to_color ) { // if entry is virus_species (case sensitive)
                if ( object_data.flag.alignment_to_virus ) {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_virus_species_to_l_index" ); // highlight a virus species
                } else {
                    Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_virus_species_to_l_index" ); // highlight a virus species
                }
            }
        } )
              .on( 'remove', e => { 
            console.log( "onRemoveTag: ", e.detail );
            let str_entry = e.detail.data.value;
            if ( object_data.main.highlight.str_entry == str_entry ) { // if the entry of the tag being removed is currently being highlighted, undo the highlighting
                if ( set_human_gene_symbol.has( str_entry ) ) { // if entry is human_gene_symbol (case insensitive)
                    let human_gene_symbol_upper_case = str_entry.toUpperCase( );
                    if ( object_data.flag.alignment_to_virus ) {
                        Highlight_Records_MolecularMimicryMap( human_gene_symbol_upper_case, "dictionary_human_gene_symbol_upper_case_to_l_index" ); // highlight a human gene
                    } else {

                    }
                }
                else if ( str_entry in object_data.main.dictionary_virus_species_to_color ) { // if entry is virus_species (case sensitive)
                    if ( object_data.flag.alignment_to_virus ) {
                        
                    } else {
                        Highlight_Records_MolecularMimicryMap( str_entry, "dictionary_virus_species_to_l_index" ); // highlight a virus species
                    }
                }
            }
        } )
              .on('input', e => { // preview during typing
            console.log( e );
            if ( ! isString( e.detail.value ) ) { return -1; }
            let str_entry = e.detail.value; // retrieve entry
            // show preview of the number of record 
            Tagify_Preview( str_entry );
        } )
              .on( "dropdown:hide", ( e ) => { 
            console.log( "dropdown:hide" ); 
            document.getElementById( "text_number_of_records" ).innerText = ""
        } )
              .on( "dropdown:show", ( e ) => { // preview during exploring dropdown options
            $( "#container_plotly_searchbox_main_preview" ).collapse( 'show' );
            console.log( "dropdown:show" );
            if ( ! object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached ) {
                let dropdown = document.querySelector( '.tagify__dropdown' ); // retrieve DOM of active dropdown
                let options = {
                    subtree: true,
                    attributes: true
                };
                let observer = new MutationObserver( function( mutations ) {
                    mutations.forEach( function( e ) {
                        if ( ( e.attributeName == 'class' ) & ( e.target.className == "tagify__dropdown__item tagify__dropdown__item--active" ) ) { // detect the innerHTML of the active element using MutationObserver
                            console.log( "dropdown active element:", e.target.innerHTML );
                            
                            let str_entry = e.target.innerHTML; // retrieve entry
                            // show preview of the number of  record and draw plots for a human protein
                            Tagify_Preview( str_entry );
                        }
                    });
                });
                observer.observe( dropdown, options );
                
                let dragsort = new DragSort( tagify_searchbox_main.DOM.scope, {
                    selector: '.' + tagify_searchbox_main.settings.classNames.tag,
                    callbacks: {
                        dragEnd: ( elm ) => { 
                            tagify_searchbox_main.updateValueByDOMTags( );
                            // color tags after the tags has been updated
                            tagify_searchbox_main.getTagElms( ).forEach( Tagify_color_tag );
                        }
                    }
                });
                object_data.flag.flag_tagify_searchbox_main_mutationobserver_attached = true; // set the flag to true after attaching mutationobserver to the dropdown list so that another observer is not attached.
            }
        })
    }
    
    function LoadRemoteTextFile( remoteFilePath ) { // load remote text file using xml_http_request (syncrhonous)
        let result = null;
        let xmlhttp = new XMLHttpRequest();
        xmlhttp.open( "GET", remoteFilePath, false );
        xmlhttp.send( );
        if ( xmlhttp.status == 200 ) {
            result = xmlhttp.responseText;
        }
        return result;
    }
    function ParseBase64GzippedText( str_base64_gzipped ) {
        let l_char = pako.inflate( new Uint8Array( atob( str_base64_gzipped ).split( '' ).map( function( x ) { return x.charCodeAt( 0 ); } ) ) ); // Decode base64 (convert ascii to binary) // Convert binary string to character-number array // Turn number array into byte-array // Convert gunzipped byteArray back to ascii string:
        let str_content = ""; // convert ASCII value to character and concatenate the characters into a string
        for ( let i = 0; i < l_char.length; i ++ ) {
            str_content += String.fromCharCode( l_char[ i ] );
        }
        return str_content;
    }
    var div_current_view = $("#molecularmimicrymap-current-view"); // global variable
    function DownloadCurrentView( ) {
         html2canvas( div_current_view.get( 0 ) ).then ( function ( canvas ) {
                var imgageData = canvas.toDataURL("image/png");
                // Now browser starts downloading it instead of just showing it
                var newData = imgageData.replace(/^data:image\/png/, "data:application/octet-stream");
                $("#anchor-current-view").attr("download", "MolecularMimicryMap of SARS-CoV-2.screenshot.png").attr("href", newData);
                $("#anchor-current-view").get( 0 ).click( ) // download image file
         });
    }
    
    // use dataframe-js
    var DataFrame = dfjs.DataFrame;
    // use interval-tree-1d
    var createIntervalTree = require( "interval-tree-1d" )
    // code for approximate string matching (for peptide sequence mapping) from https://gist.github.com/andrei-m/982927
    function Levenstein(a, b) { 
        var m = [], i, j, min = Math.min;
        if (!(a && b)) return (b || a).length;
        for (i = 0; i <= b.length; m[i] = [i++]);
        for (j = 0; j <= a.length; m[0][j] = j++);
        for (i = 1; i <= b.length; i++) {
            for (j = 1; j <= a.length; j++) {
                m[i][j] = b.charAt(i - 1) == a.charAt(j - 1)
                    ? m[i - 1][j - 1]
                    : m[i][j] = min(
                        m[i - 1][j - 1] + 1, 
                        min(m[i][j - 1] + 1, m[i - 1 ][j] + 1))
            }
        }
        return m[b.length][a.length];
    }
    function FuzzyContains(a, b, error) {
        var matchLength = a.length - b.length;
        var distanceToMatch = Levenstein(a, b) - matchLength;
        if(distanceToMatch - error > 0) {
          return false;
        } else {
          return true;
        }
    }
    // code for pseudorandom number generator (PRNG) with random seed from https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
    function xmur3(str) { // random seed generator
        for(var i = 0, h = 1779033703 ^ str.length; i < str.length; i++)
            h = Math.imul(h ^ str.charCodeAt(i), 3432918353),
            h = h << 13 | h >>> 19;
        return function() {
            h = Math.imul(h ^ h >>> 16, 2246822507);
            h = Math.imul(h ^ h >>> 13, 3266489909);
            return (h ^= h >>> 16) >>> 0;
        }
    }
    function mulberry32(a) { // a simple (PRNG) generator with a 32-bit state
        return function() {
          var t = a += 0x6D2B79F5;
          t = Math.imul(t ^ t >>> 15, t | 1);
          t ^= t + Math.imul(t ^ t >>> 7, t | 61);
          return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }
    }
    // function for sorting
    function SortFloat( a, b ) { return a - b; }
    function CheckInt(n) { // return true if 'n' is true
       return n % 1 === 0;
    }
    function CountOccurrence( entry, query ) { // count occurrence of specific string in a string
        return ( entry.match( new RegExp( query, 'g' ) ) || []).length;
    }
    function ArraySum( l ) { // return the sum of values of an array
        return l.reduce( (a, b) => a + b, 0 );
    }
    function ArrayStandardDeviation( array ) {
        let n = array.length
        let mean = array.reduce((a, b) => a + b) / n
        return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n)
    } // from https://stackoverflow.com/questions/7343890/standard-deviation-javascript
    // funrcions for UI
    function Loading_Screen( bool_add_loading_screen ) { // add or remove loading screen
        if ( ( ! bool_add_loading_screen ) && document.getElementById( "svg_during_loading" ) != null ) {
            document.getElementById( "svg_during_loading" ).remove( ); // remove loading screen once plot is drawn
        } else if ( bool_add_loading_screen && document.getElementById( "svg_during_loading" ) == null ) {
            $("#loading_screen").append( [
                '<div class="loader loader--style1 _plotly-loading-callback" title="data is being loaded..." id="svg_during_loading">',
                    '<svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewBox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve" rect="fill: #FF6700;" path>',
                        '<path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946',
                        's14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634',
                        'c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>',
                        '<path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0',
                        'C22.32,8.481,24.301,9.057,26.013,10.047z">',
                        '<animateTransform attributeType="xml"',
                          'attributeName="transform"',
                          'type="rotate"',
                          'from="0 20 20"',
                          'to="360 20 20"',
                          'dur="0.5s"',
                          'repeatCount="indefinite"/>',
                        '</path>',
                    '</svg>',
                '</div>' ].join( "" ) ); // display an SVG file during loading 
        }
    }
    function Dismissible_Alert( container, class_alert, message ) { // display a dismissible alert message of a given class_alert (eg. 'primary') at a given container with a given message 
        $( container ).append( [
            '<div class="alert alert-' + class_alert + ' alert-dismissible fade show" role="alert">',
              message,
              '<button type="button" class="close" data-dismiss="alert" aria-label="Close">',
                 '<span aria-hidden="true">&times;</span>',
              '</button>',
            '</div>' ].join( "" ) ); 
    }
    
    // basic functions
    function isString ( value ) { // Returns if a value is a string
        return typeof value === 'string' || value instanceof String;
    }
    // define hashing funciton of string
    Object.defineProperty(String.prototype, 'hashCode', {
            value: function() {
                var hash = 0, i, chr;
                for (i = 0; i < this.length; i++) {
                    chr   = this.charCodeAt(i);
                    hash  = ((hash << 5) - hash) + chr;
                    hash |= 0; // Convert to 32bit integer
                }
            return hash;
        }
    });
    
    // functions for numpy-like operations
    function ArrayIndexing( l, l_index ) {
        let l_output = [ ];
        for ( let i = 0; i < l_index.length; i++ ) { l_output.push( l[ l_index[ i ] ] ); }
        return l_output
    }
    function ArrayBooleanIndexing( l, l_bool ) {
        let l_output = [ ];
        for ( let i = 0; i < l_bool.length; i++ ) { if ( l_bool[ i ] ) { l_output.push( l[ i ] ); } }
        return l_output
    }
    function ArrayBoolAND( l_l ) {
        let l_output = [ ];
        for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
            let output = true;
            for ( let i = 0; i < l_l.length; i++ ) { output = output && l_l[ i ][ j ]; }
            l_output.push( output );
        }
        return l_output;
    }
    function ArrayBoolOR( l_l ) {
        let l_output = [ ];
        for ( let j = 0; j < l_l[ 0 ].length; j++ ) {
            let output = false;
            for ( let i = 0; i < l_l.length; i++ ) { output = output || l_l[ i ][ j ]; }
            l_output.push( output );
        }
        return l_output;
    }
    function ArrayBoolNOT( l ) {
        let l_output = [ ];
        for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] ? false : true ); }
        return l_output;
    }
    function ArrayGreaterThan( l, thres ) {
        let l_output = [ ];
        for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] > thres ); }
        return l_output;
    }
    function ArrayLessThan( l, thres ) {
        let l_output = [ ];
        for ( let i = 0; i < l.length; i++ ) { l_output.push( l[ i ] < thres ); }
        return l_output;
    }
    function ArrayFull( length, value ) {
        let l_output = [ ];
        for ( let i = 0; i < length; i++ ) { l_output.push( value ); }
        return l_output;
    }
    function ArrayBroadCasting( l, l_bool_or_integer_index, value ) { // broadcast a single scalar value to multiple elements of an array according to the given 'l_bool_or_integer_index'. Receive either l_bool or l_integer_index
        let l_output = [ ];
        if ( ( l.length == l_bool_or_integer_index.length ) & ( typeof l_bool_or_integer_index[ 0 ] === 'boolean' ) ) { // if boolean index is given
            let l_bool = l_bool_or_integer_index;
            for ( let i = 0; i < l.length; i++ ) { 
                l_output.push( l_bool[ i ] ? value : l[ i ] );
            }
        } else {
            let l_int_index = l_bool_or_integer_index;
            l_output.push( ... l ); // copy list l to l_output
            for ( let i = 0; i < l_int_index.length; i++ ) { 
                l_output[ l_int_index[ i ] ] = value; // then modify elements according to the given list of integer indices
            }
        }
        return l_output;
    }
    function ArrayCap( l, value ) { // cap value of a given list at the given capping value (manually set maximum value)
        l_modified = lodash.cloneDeep( l );
        for ( let i = 0; i < l.length; i ++ ) {
            if ( l[ i ] > value ) { // cap value of a given list at the given capping value (manually set maximum value)
                l_modified[ i ] = value;
            }
        }
        return l_modified
    }
    function ArrayFloor( l, value ) { // floor value of a given list at the given flooring value (manually set minimum value)
        l_modified = lodash.cloneDeep( l );
        for ( let i = 0; i < l.length; i ++ ) {
            if ( l[ i ] < value ) { // cap value of a given list at the given capping value (manually set maximum value)
                l_modified[ i ] = value;
            }
        }
        return l_modified
    }
    function ArrayApply( l, a_function ) { // apply certain function to all of values of a given array
        let l_output = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_output[ i ] = a_function( l[ i ] );
        }
        return l_output
    }
    function ArrayMap( l, dictionary ) { // map values in a given array using a given dictionary
        let l_output = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_output[ i ] = dictionary[ l[ i ] ];
        }
        return l_output
    }
    function ArrayTranspose( l_l ) { // transpose 2d array
        let n_row = l_l.length, n_col = l_l[ 0 ].length, l_l_t = [ ]; // transposed 2d array
        for ( let i = 0; i < n_col; i ++ ) {
            let l_t = [ ]; // transposed column (now a row)
            for ( let j = 0; j < n_row; j ++ ) { l_t.push( l_l[ j ][ i ] ); }
            l_l_t.push( l_t );
        }
        return l_l_t;
    }
    function ArrayAsInt( l ) { 
        let l_int = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_int.push( parseInt( l[ i ] ) ); // parse a string into an integer for each entry
        }
        return l_int
    } // convert array of strings to array of integers
    function ArrayAverage( l ) { // calculate average of values in the array
        let sum = l.reduce( ( a, b ) => a + b, 0 );
        let avg = ( sum / l.length ) || 0;
        return avg;
    }
    function ArrayMultiply( l, float_multiply_by ) { // return a list with values multiplied by 'float_multiply_by'
        let l_multiplied = [ ];
        for ( let i = 0; i < l.length; i ++ ) {
            l_multiplied.push( l[ i ] * float_multiply_by );
        }
        return l_multiplied;
    }
    function ArrayFindMinMax ( l ) { 
        let min = l[ 0 ], max = l[ 0 ]; // initialize min and max values
        for ( let i = 1; i < l.length; i++ ) {
            let value = l[ i ];
            min = (value < min) ? value : min;
            max = (value > max) ? value : max;
        }
        return [ min, max ];
    } // Find Min and Max values of a given array
    function TickFindOptimal( float_max ) { // retrieve list of optimal number of ticks for concise representation of an axis (start from 0)
        let step = parseInt( 10 ** Math.floor( Math.log10( float_max ) ) );
        let n_ticks = Math.ceil( float_max / step ) + 1;
        if ( n_ticks <= 3 ) {
            step = step / 5;
        } else if ( n_ticks <= 5 ) {
            step = step / 2;
        }
        if ( parseInt( step ) == step ) {
            step = parseInt( step );
        }
        n_ticks = Math.ceil( float_max / step ) + 1;
        return nj.arange( 0, step * n_ticks, step ).tolist( ); // return ticks starts from 0
    }
    function Unique( l ) {
        let set_unique_element = { };
        for ( let i = 0; i < l.length; i ++ ) {
            set_unique_element[ l[ i ] ] = true;
        }
        return Object.keys( set_unique_element );
    } // return unique elements of a given array as a list of strings 
    function DictArrayCombine( ) { // return combined dictionary-arrays of the given list of dictionary-arrays (dictionary arrays are list of arrays with key values stored in a dictionary (combining action will be an inner join)
        let l_key = [ ];
        for ( let i = 0; i < arguments.length; i ++ ) {
            let dictarr = arguments[ i ];
            l_key.push( ... Object.keys( dictarr ) );
        }
        let l_key_shared = DictionaryFindMatchingValue( Counter( l_key ), arguments.length ); // retrieve list of keys shared by all dictionary-arrays
        // initialize a dictarr that will contain combined dictionary-arrays
        let dictarr_combined = { };
        for ( let i = 0; i < l_key_shared.length; i ++ ) {
            let key = l_key_shared[ i ];
            dictarr_combined[ key ] = [ ];
        }
        for ( let i = 0; i < arguments.length; i ++ ) {
            let dictarr = arguments[ i ]; // retrieve dictionary-array in order
            for ( let j = 0; j < l_key_shared.length; j ++ ) {
                let key = l_key_shared[ j ];
                try {
                    dictarr_combined[ key ].push( ... dictarr[ key ] ); // concatanate the array of a shared key of the current dictionary-array
                } catch ( e ) {
                    console.log( `[DictArrCOmbine] error when combining ${key} value`, dictarr ); // report key that caused error
                }
            }
        }
        return dictarr_combined;
    }
    function DictArrayIndexing( dictarr, l_index ) { // return a smaller dictarr than the given dictarr containing smaller arrays with a given 'l_index'
        let l_key = Object.keys( dictarr ),
            dictarr_output = { };
        for ( let i = 0; i < l_key.length; i ++ ) {
            let key = l_key[ i ];
            dictarr_output[ key ] = ArrayIndexing( dictarr[ key ], l_index ); // retrieve a smaller array with a given 'l_index'
        }
        return dictarr_output;
    }
    function ArrayCombine(  ) { 
        let l_combined = [ ]; 
        for ( let i = 0; i < arguments.length; i ++ ) {
            let l = arguments[ i ];
            l_combined.push( ... l );
        }
        return l_combined;
    } // return a list that will contain elments of a combined list
    function Index_list_with_dictionary( l ) { // build dictionary containing list for indices for a given list of accessions (key = accession, value = list of indices containing the accession)
        let dictionary_index = { };
        for ( let i = 0; i < l.length; i ++ ) { 
            let acc = l[ i ];
            if ( acc in dictionary_index ) {
                dictionary_index[ acc ].push( i )
            } else {
                dictionary_index[ acc ] = [ i ]; // initialize value of key encountered for the first time
            }
        }
        return dictionary_index;
    }
    function Counter( l ) { // count entries in the list
        let dict_count = { };
        for ( entry of l ) {
            if ( entry in dict_count ) {
                dict_count[ entry ] += 1;
            } else {
                dict_count[ entry ] = 1;
            }
        }
        return dict_count;
    }
    function FindTheMajority( l ) { // count entries in the list and return the majority in the list
        let dict_count = Counter( l ), key_majority = '', count_majority = 0;
        for ( key of Object.keys( dict_count ) ) { // for each key
            let count = dict_count[ key ];
            if ( count > count_majority ) { // if the count of the current key is larger than count of majority key, update the majority key name
                key_majority = key;
                count_majority = count;
            }
        }
        return key_majority;
    }
    function DictionaryFindMatchingValue( dict, value ) { // return list of keys in a given dictionary with a matching value with the given value
        let l_key_match = [ ];
        let l_key = Object.keys( dict ); // retrieve all keys of a given object
        for ( let i = 0; i < l_key.length; i ++ ) {
            let key = l_key[ i ];
            if ( dict[ key ] == value ) { // if key has a value matched with the given value
                l_key_match.push( key );
            }
        }
        return l_key_match;
    }
    function DictArrayToArray( dictarr, l_col ) {
        let l_l = [ ];
        for ( let i = 0; i < l_col.length; i ++ ) {
            l_l.push( dictarr[ l_col[ i ] ] );
        }
        return l_l;
    } // return 2D array containing lists in the order specified by l_col of dictarr (column name refers to the key name of the dicitonary of dictionary-array)
    
    function unpack( rows, key ) { 
        if ( Array.isArray( key ) ) { // if more than one key is given, return 2D-array of unpacked data
            let l_l_value = [ ];
            for ( let i = 0; i < rows.length; i ++ ) {
                let row = rows[ i ];
                let l_value = [ ];
                for ( let j = 0; j < key.length; j ++ ) { 
                    l_value.push( row[ key[ j ] ] );
                }
                l_l_value.push( l_value );
            }
            return l_l_value;
        } else { return rows.map( function( row ) { return row[ key ]; } ); } // if only a single key is given, return 1D-array of unpacked data
    };
    function Unpack_array_to_dict_data( arr, l_key = [ ] ) { // unpack array returned by papaparse into dictionary containing unpacked arrays // this is much faster than 'new DataFrame( arr ).toDict( )' method
        if ( l_key.length == 0 ) { // if list of keys is not given, use all keys of the first record for unpacking by default.
            l_key = Object.keys( arr[ 0 ] );
        }
        let dict_data = { };
        for ( let i = 0; i < l_key.length; i ++ ) {
            let key = l_key[ i ];
            dict_data[ key ] = unpack( arr, key );
        }
        return dict_data;
    }
    function Unpack_String_Numbers( data ) { // unpack a string containing a list of numbers
        let l = data.split( ',' ), l_data = [ ], bool_flag_float_datatype = data.includes( '.' ); // retrieve flag indicating the float datatype
        for ( let i = 0; i < l.length; i ++ ) {
            let value = l[ i ].length == 0? "0" : l[ i ];
            l_data.push( bool_flag_float_datatype? parseFloat( value ) : parseInt( value ) ); // parse float or integer datatype
        }
        return l_data;
    };
    function ColorMap_Rainbow( n_colors ) { // colormap witn the given number of colors
        let l_colormap = [ ]; 
        for ( let i = 0; i < n_colors; i ++ ) { 
            let f = i / n_colors; // convert to [0,1]

            let a = ( 1 - f ) * 5.0; // from a code found at "https://www.particleincell.com/2014/colormap/"
            let X = Math.floor( a );
            let Y = Math.floor( 255 * ( a - X ) );
            let r = 0, g = 0, b = 0;
            switch( X )
            {
                case 0: r = 255; g = Y; b = 0; break;
                case 1: r = 255 - Y; g = 255; b = 0; break;
                case 2: r = 0; g = 255; b = Y; break;
                case 3: r = 0; g = 255 - Y; b = 255; break;
                case 4: r = Y; g = 0; b = 255; break;
                case 5: r = 255; g = 0; b = 255; break;
            }
            l_colormap.push( {r:r,g:g,b:b} )
        }
        return l_colormap; // return a colormap
    }
    function ColorMap_Rainbow_Map( l_scalar ) { // map integer values in 'l_scaler' to rainbow rgb colormap 
        let min_value = Math.min.apply( null, l_scalar );
        let max_value = Math.max.apply( null, l_scalar );
        console.log( min_value, max_value )
        let l_colormap = [ ], l_mapped_color = [ ], n_colors = ( max_value - min_value + 1 ); // min and max values should be intergers
        for ( let i = 0; i < n_colors; i ++ ) { 
            let f = i / n_colors; // convert to [0,1]

            let a = ( 1 - f ) * 5.0; // from a code found at "https://www.particleincell.com/2014/colormap/"
            let X = Math.floor( a );
            let Y = Math.floor( 255 * ( a - X ) );
            let r = 0, g = 0, b = 0;
            switch( X )
            {
                case 0: r = 255; g = Y; b = 0; break;
                case 1: r = 255 - Y; g = 255; b = 0; break;
                case 2: r = 0; g = 255; b = Y; break;
                case 3: r = 0; g = 255 - Y; b = 255; break;
                case 4: r = Y; g = 0; b = 255; break;
                case 5: r = 255; g = 0; b = 255; break;
            }
            l_colormap.push( {r:r,g:g,b:b} )
        }
        for ( let i = 0; i < l_scalar.length; i ++ ) { l_mapped_color.push( l_colormap[ l_scalar[ i ] - min_value ] ); }
        return l_mapped_color; // return mapped colors
    }
    function hexToRgb(hex) { // https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
      // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
      let shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
      hex = hex.replace(shorthandRegex, function(m, r, g, b) {
        return r + r + g + g + b + b;
      });

      let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }
    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }
    function ColorGetDarkness( hex ) { // get darkness of color (hex)
        let c = hex.substring(1);      // strip #
        let rgb = parseInt(c, 16);   // convert rrggbb to decimal
        let r = (rgb >> 16) & 0xff;  // extract red
        let g = (rgb >>  8) & 0xff;  // extract green
        let b = (rgb >>  0) & 0xff;  // extract blue
        let luma = 0.2126 * r + 0.7152 * g + 0.0722 * b; // per ITU-R BT.709 // get brightness
        return luma
    }
    
    function RetrieveDiscardedLength( str_discarded_regions, alignment_start ) { // retrieve length of discarded sequence from 'str_discarded_regions' for the given alignment start position
        let len_discarded_sequence = 0, l_discarded_regions = str_discarded_regions.split( ";" ).map( function( str ) { return str.split( ":" ).map( function( str ) { return parseInt( str ); } ) } );
        for ( let i = 0; i < l_discarded_regions.length; i ++ ) {
            if ( alignment_start < l_discarded_regions[ i ][ 0 ] ) { break; } // if the region is before the start of a discarded region, stop subtracting the length of discarded regions
            len_discarded_sequence += l_discarded_regions[ i ][ 1 ] // increase the length of discarded regions by the length of the current discarded region
        }
        return len_discarded_sequence;
    }
    function Unpack_String_rsa( seq ) { // unpack string containing RSA value using ASCII encoding (126 encodes null)
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value == 126 ) { l_output.push( null ); }
            else { l_output.push( Math.round( ( int_value - 33 ) / 92 * 100 ) / 100 ); } // RSA value range 0 ~ 1 // round up so that step is 1
        }
        return l_output;
    }
    function Unpack_String_rsa_encoded_by_two_char( seq ) { // unpack string containing RSA value using ASCII encoding with two characters (two 126 encodes null)
        let l_output = [ ];
        for ( let i = 0; i < parseInt( seq.length / 2 ); i ++ ) {
            let int_value_first_char = seq.charCodeAt( 2 * i ), int_value_second_char = seq.charCodeAt( 2 * i + 1 ); // retrieve ASCII character as an integer number
            if ( int_value_first_char == 126 && int_value_second_char == 126 ) { l_output.push( null ); }
            else { l_output.push( Math.round( ( int_value_first_char - 33 ) * ( int_value_second_char - 33 ) / 8648 * 1000 ) / 1000 ); } // RSA value range 0 ~ 1 // round up so that step is 1
        }
        return l_output;
    }
    function Unpack_String_torsion_angle( seq ) {
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value == 126 ) { l_output.push( null ); }
            else { l_output.push( Math.round( ( int_value - 33 ) / 92 * 360 ) - 180 ); } // torsion angle value range -180 ~ 180 // round up so that step is 1
        }
        return l_output;
    }
    function Unpack_String_ss8( seq ) {
        let l_ss8 = [ 'G', 'H', 'I', 'E', 'B', 'T', 'S', 'C' ];
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value >= 41 ) { l_output.push( null ); }
            else { l_output.push( l_ss8[ int_value - 33 ] ); } // retrieve encoded ss8 classification
        }
        return l_output;
    }
    function Unpack_String_datatype( seq ) {
        let l_datatype = [ 'predicted', 'modeling', 'PDB' ]; // [ 'prediction', 'homology modeling', 'experimental structure' ];
        let l_output = [ ];
        for ( let i = 0; i < seq.length; i ++ ) {
            let int_value = seq.charCodeAt( i ); // retrieve ASCII character as an integer number
            if ( int_value >= 36 ) { l_output.push( null ); }
            else { l_output.push( l_datatype[ int_value - 33 ] ); } // retrieve encoded datatype classification
        }
        return l_output;
    }
    function Unpack_String_structure_id( seq ) {
        let l_value = seq.split( ';' ), entry_previous = null, l_output = [ ], chr_representing_repeated_string = '=';
        for ( let i = 0; i < l_value.length; i ++ ) {
            let entry = l_value[ i ];
            if ( entry.length == 0 )  { l_output.push( null ); }
            else if ( entry == chr_representing_repeated_string ) { l_output.push( entry_previous ); }
            else { l_output.push( entry ); entry_previous = entry; }
        }
        return l_output;
    }
    function Align_Structural_Property( object_structure_property, seq ) { // align structural property and colors 
        let l_name_data = Object.keys( object_structure_property ), object_structure_property_aligned = { };
        for ( let i = 0; i < l_name_data.length; i ++ ) { // for each member (structural property data) in 'object_structure_property'
            let l_aligned_data = [ ], l_data = object_structure_property[ l_name_data[ i ] ], int_pos_data = 0; // initial position is 0
            for ( let j = 0; j < seq.length; j ++ ) {
                let residue = seq[ j ]; // for each residue in the alignment
                if ( residue == '-' ) { // add value representing a gap when encounter a gap (for color, the value representing the gap is the color 'black')
                    let value_representing_gap = l_name_data[ i ].includes( "color_" )? "#000000" : '-';
                    l_aligned_data.push( value_representing_gap );
                } else {
                    l_aligned_data.push( l_data[ int_pos_data ] ); // add data value when encounter a non-gap residue
                    int_pos_data += 1;
                }
            }
            object_structure_property_aligned[ l_name_data[ i ] ] = l_aligned_data; // add aligned data
        }
        return object_structure_property_aligned;
    }
    
    var color_representing_null = "#c3c3c3"; // color representing null value is grey color
    function Color_for_rsa( l_rsa ) {
        let l_color = [ ], function_colormap = function_colormap_rsa;
        for ( let i = 0; i < l_rsa.length; i ++ ) { l_color.push( l_rsa[ i ] == null? color_representing_null : function_colormap( l_rsa[ i ] * 2 ).toString( ) ); } // RSA of 0.5 will be represented as 'fully accessible to the surface'
        return l_color;
    }
    function Color_for_score_blosum( l_score_blosum ) {
        let l_color = [ ], function_colormap = function_colormap_score_blosum;
        for ( let i = 0; i < l_score_blosum.length; i ++ ) { l_color.push( l_score_blosum[ i ] == null? color_representing_null : function_colormap( ( l_score_blosum[ i ] + 3 ) / 6 ).toString( ) ); } // display blosum62 score from -5 to 5
        return l_color;
    }
    function Color_for_torsion_angle( l_torsion_angle ) {
        let l_color = [ ], function_colormap = function_colormap_torsion_angle;
        for ( let i = 0; i < l_torsion_angle.length; i ++ ) { l_color.push( l_torsion_angle[ i ] == null? color_representing_null : function_colormap( ( l_torsion_angle[ i ] + 180 ) / 360 ).toString( ) ); }
        return l_color;
    }
    function Color_for_ss8( l_ss8 ) {
        let l_color = [ ], dict_colormap = { G: "#b2d0ed", H: "#b2d0ed", I: "#b2d0ed", E: "#f7b4a3", B: "#f7b4a3", T: "#cbf7c8", S: "#cbf7c8", C: "#edebe4" };
        for ( let i = 0; i < l_ss8.length; i ++ ) { l_color.push( l_ss8[ i ] == null? color_representing_null : dict_colormap[ l_ss8[ i ] ] ); }
        return l_color;
    }
    function Color_for_datatype( l_datatype ) {
        let l_color = [ ], dict_colormap = { predicted: "#fffafe", modeling: "ffc38a", PDB: "#ff8b14" };
        for ( let i = 0; i < l_datatype.length; i ++ ) { l_color.push( l_datatype[ i ] == null? color_representing_null : dict_colormap[ l_datatype[ i ] ] ); }
        return l_color;
    }
    function Color_for_structure_id( l_structure_id ) {
        let l_color = [ ];
        for ( let i = 0; i < l_structure_id.length; i ++ ) { l_color.push( l_structure_id[ i ] == null? color_representing_null : "#ffffff" ); } // color representing value structure_id is 'white' color
        return l_color;
    }
    
    var plotMolecularMimicryMap = document.getElementById( 'plotly_graph_molecular_mimicry_map' );
    var plotBCellCrossReactivityMetrics = document.getElementById( 'plotly_graph_b_cell_cross_reactivity' );
    var plotTCellCrossReactivityMetrics = document.getElementById( 'plotly_graph_t_cell_cross_reactivity' );
    var plotHumanProteinMetrics = document.getElementById( 'plotly_graph_human_protein' );
    var plotGTEx = document.getElementById( 'plotly_graph_gtex' );
    var plotscrnaseq = document.getElementById( 'plotly_graph_scrnaseq_expression' );
    var tableMetrics = document.getElementById( 'd3_table_metrics' );
    var tableSequence = document.getElementById( 'plotly_table_sequence' );
    
    var str_jquery_container = "#container_PDB"; // JQuery string for returning promise for collapse transition of the container targeted by 'str_jquery_container'
    const BootstrapCollapseShownPromise = ( str_jquery ) => { // return promise when content is fully shown to the screen
        return new Promise( ( resolve, reject ) => {
            jQuery( str_jquery ).collapse( 'show' ) // trigger transition
            jQuery( str_jquery ).on( 'shown.bs.collapse', function( ) { // when transition is complete, resolve the promise
                console.log( "shown" );
                resolve( 'shown' );
            });
        });
    }
    const MolStarRenderCompletePromise = ( instance_molstar_viewer ) => { // return promise when content is fully shown to the screen
        return new Promise( ( resolve, reject ) => {
            instance_molstar_viewer.events.loadComplete.subscribe( function( ) { // when transition is complete, resolve the promise
                console.log( "rendering was completed" );
                resolve( "rendering was completed" );
            });
        });
    }
    
    var l_file = [ ];
    const fileSelector = document.getElementById( 'file-selector' );
    fileSelector.addEventListener( 'change', function( event ) {
        Loading_Screen( true ); // add loading screen
        l_file = [ ];
        l_file.push( ... event.target.files ); // retrieve list of given files
        console.log( "Locally loaded files:", l_file );
        if ( l_file.length > 0 ) { LoadLocalData( l_file ); }
        Loading_Screen( false );
    });

    const fileSelector_file_fasta_vaccine_design = document.getElementById( 'file_vaccine_design_fasta' );
    fileSelector_file_fasta_vaccine_design.addEventListener( 'change', async function( event ) {
        Loading_Screen( true ); // add loading screen
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ];
        dataset.vaccine_design = { l_file_fasta: [ ], arr_aligned_peptide: [ ], dict_header_to_seq: { }, dict_duplicated_header_count: { }, data: [ ], dict_data: { }, dict_y_axis_max: { }, name_y_axis: null, plotly: { }, selection: { dict_threshold: { } } }; // initialize the object
        let l_file_fasta = [ ]; // initialized the file list
        l_file_fasta.push( ... event.target.files ); // retrieve list of given files
        console.log( "Fasta file(s) selected:", l_file_fasta );
        for ( let i = 0; i < l_file_fasta.length; i ++ ) { await LoadFasta( l_file_fasta[ i ] ); } // load a fasta file at a time
        dataset.vaccine_design.l_file_fasta = l_file_fasta; // update the file list
        ProcessVaccineCandidate( );
        Loading_Screen( false );
    });
    
    async function LoadFasta( file ) { // async. function for loading a fasta file (return a promise that resolve when parsing of FASTA file is completed)
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        return new Promise( ( resolve, reject ) => {
            let reader = new FileReader( ); // initialize FileReader
            reader.onload = function( progressEvent ) {
                var l_line = this.result.split( '\n' ); // By lines
                let index = 0, line = '';
                line = l_line[ index ]; // retrieve the first line as a header
                let str_header = line, l_seq = [ ];
                while ( true ) {
                    str_header = line, l_seq = [ ];
                    while ( true ) {
                        index ++;
                        if ( index >= l_line.length ) { break; }
                        line = l_line[ index ];
                        if ( line[ 0 ] == '>' ) { break; }
                        l_seq.push( line );
                    }
                    let header = str_header.slice( 1 ), seq = l_seq.join( '' );
                    if ( header in dataset.vaccine_design.dict_duplicated_header_count ) { dataset.vaccine_design.dict_duplicated_header_count[ header ] ++; } // handle sequences with duplicated headers
                    else { dataset.vaccine_design.dict_duplicated_header_count[ header ] = 1; }
                    if ( dataset.vaccine_design.dict_duplicated_header_count[ header ] > 1 ) { dataset.vaccine_design.dict_header_to_seq[ header + '_dup_' + String( dataset.vaccine_design.dict_duplicated_header_count[ header ] ) ] = seq; } // if current fastq header in already exists, add '_dup_{index}' to the header to make it unique 
                    else { dataset.vaccine_design.dict_header_to_seq[ header ] = seq; }
                    if ( index >= l_line.length ) { break; }
                }
                console.log( file, "loaded and parsed." );
                resolve( ); // when loading and parsing is complete, resolve the promise
            };
            reader.readAsText( file )
        });
    }
    async function LoadRemoteFasta( file ) { // async. function for loading a remote fasta file through URL (return a promise that resolve when parsing of FASTA file is completed)
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        return new Promise( ( resolve, reject ) => {
            jQuery.get( file, function( data ) {
                var l_line = data.split( '\n' ); // process each line
                let index = 0, line = '';
                line = l_line[ index ]; // retrieve the first line as a header
                let str_header = line, l_seq = [ ];
                while ( true ) {
                    str_header = line, l_seq = [ ];
                    while ( true ) {
                        index ++;
                        if ( index >= l_line.length ) { break; }
                        line = l_line[ index ];
                        if ( line[ 0 ] == '>' ) { break; }
                        l_seq.push( line );
                    }
                    let header = str_header.slice( 1 ), seq = l_seq.join( '' );
                    if ( header in dataset.vaccine_design.dict_duplicated_header_count ) { dataset.vaccine_design.dict_duplicated_header_count[ header ] ++; } // handle sequences with duplicated headers
                    else { dataset.vaccine_design.dict_duplicated_header_count[ header ] = 1; }
                    if ( dataset.vaccine_design.dict_duplicated_header_count[ header ] > 1 ) { dataset.vaccine_design.dict_header_to_seq[ header + '_dup_' + String( dataset.vaccine_design.dict_duplicated_header_count[ header ] ) ] = seq; } // if current fastq header in already exists, add '_dup_{index}' to the header to make it unique 
                    else { dataset.vaccine_design.dict_header_to_seq[ header ] = seq; }
                    if ( index >= l_line.length ) { break; }
                }
                console.log( "[LoadRemoteFasta] remote file", file, "loaded and parsed." );
                resolve( ); // when loading and parsing is complete, resolve the promise
            });
        });
    }
    
    function AlignPeptide( ) { // align peptides to concatanated consensus protein sequence for the virus
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        dataset.vaccine_design.arr_aligned_peptide = [ ]; // empty array containing records of aligned peptides
        let l_header = Object.keys( dataset.vaccine_design.dict_header_to_seq );
        if ( ! ( 'seq_consensus_concatenated' in dataset.consensus_sequence_virus ) ) { return; } // if 'object_data_acc_virus_representative' has not been loaded, do not align the peptides
        let seq_consensus_concatenated = dataset.consensus_sequence_virus.seq_consensus_concatenated; // retrieve 'seq_consensus_concatenated'
        for ( let i = 0; i < l_header.length; i ++ ) {
            let header = l_header[ i ];
            let seq = dataset.vaccine_design.dict_header_to_seq[ header ], len_seq = seq.length;
            let start_alignment = seq_consensus_concatenated.indexOf( seq ) + 1, end_alignment = start_alignment + len_seq - 1; // 1-based coordinate
            if ( start_alignment != 0 ) { dataset.vaccine_design.arr_aligned_peptide.push( { header: header, seq: seq, start_alignment: start_alignment, end_alignment: end_alignment, n_mismatches: 0 } ); }
            else {
                let n_max_mismatches = parseInt( len_seq / 3 ), bool_flag_match_found = false, pos_aligned = undefined, n_mismatches_alignment = undefined; // retrieve the maximum number of mismatches
                for ( let n_mismatches = 1; n_mismatches < n_max_mismatches; n_mismatches ++ ) {
                    for ( let pos = 0; pos < seq_consensus_concatenated.length - len_seq + 1; pos ++ ) {
                        let seq_consensus_peptide = seq_consensus_concatenated.slice( pos, pos + len_seq );
                        if ( FuzzyContains( seq, seq_consensus_peptide, n_mismatches ) ) { // if match is found
                            pos_aligned = pos, bool_flag_match_found = true, n_mismatches_alignment = n_mismatches;
                            break;
                        }
                    }
                    if ( bool_flag_match_found ) { break; } // if match is found at the current 'n_mismatches', skip search with larger 'n_mismatches'
                }
                if ( bool_flag_match_found ) { console.log( "Alignment considering mismatches succeeded:", header, seq, n_mismatches_alignment ); dataset.vaccine_design.arr_aligned_peptide.push( { header: header, seq: seq, start_alignment: pos_aligned, end_alignment: pos_aligned + len_seq, n_mismatches: n_mismatches_alignment } ); } // infer 'end_alignment' using the length of the peptide // 0-based coordinates
                else { console.log( "Alignment failed for", header, seq ); }
            }
        }
        console.log( "Alignment operations of", l_header.length, "peptides are completed. The number of successfully aligned peptides is", dataset.vaccine_design.arr_aligned_peptide.length );
        AlignPeptide_Post_Processing( );
    }
    function AlignPeptide_Post_Processing( ) { // post-processing step of 'AlignPeptide' function
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        dataset.vaccine_design.dict_data = Unpack_array_to_dict_data( dataset.vaccine_design.arr_aligned_peptide, Object.keys( dataset.vaccine_design.arr_aligned_peptide[ 0 ] ) ); // unpack an array into another format
        dataset.vaccine_design.dict_data[ "start" ] = nj.array( ArrayMap( dataset.vaccine_design.dict_data[ "start_alignment" ], dataset.consensus_sequence_virus.dict_accumulated_coord_to_individual_coord ) ).add( 1 ).tolist( ), dataset.vaccine_design.dict_data[ "end" ] = ArrayMap( dataset.vaccine_design.dict_data[ "end_alignment" ], dataset.consensus_sequence_virus.dict_accumulated_coord_to_individual_coord ), dataset.vaccine_design.dict_data[ "protein_name" ] = ArrayApply( dataset.vaccine_design.dict_data[ "start_alignment" ], function( start ) { return dataset.arr_data_acc_virus_representative[ dataset.consensus_sequence_virus.dict_accumulated_coord_to_acc_rep[ start ] ].name; } ); // retrieve coordinates of individual proteins // 1-based coordinates
//     assign random coordinates for designed peptide vaccines
        let seed = xmur3( "molecular_mimicry_map_of_SARS-CoV-2" ), rand = mulberry32( seed( ) ), l_random_value = [ ]; // retrieve seed for a PRNG // retrieve a function for PRNG
        for( let i = 0; i < dataset.vaccine_design.arr_aligned_peptide.length; i ++ ) { l_random_value.push( rand( ) ); } // retrieve random values for aligned peptides for displaying peptides
        dataset.vaccine_design.dict_data[ "random_value" ] = l_random_value;
        dataset.vaccine_design.dict_data[ "selected" ] = ArrayFull( dataset.vaccine_design.arr_aligned_peptide.length, true ); // initially all peptides are selected
        document.getElementById( "div_display_current_number_of_peptides" ).innerHTML = "Total number of peptides is " + String( dataset.vaccine_design.arr_aligned_peptide.length ) + '.'; // update description in modal_generate_peptides
    }
    function Retrieve_Peptides( ) { // retrieve peptides of the given window size
        let window_size = parseInt( document.getElementById( "input_window_size_generate_peptides" ).value ), str_message = "";
        if ( window_size <= 0 ) { // check validity of a given window size
            str_message = "peptide length cannot be smaller than 1";
            Dismissible_Alert( "#modal_generate_peptides_alert_container", "warning", str_message ); // display number of peptides generated via an alert message  
            console.log( "[Retrieve_Peptides] invalid window_size, exiting" ); return;
        }
        dataset.vaccine_design.arr_aligned_peptide_retrieved_from_consensus = [ ];
        for ( let object_protein of dataset.arr_data_acc_virus_representative ) {
            let name_protein = object_protein.name.replace( " ", '_' ).replace( "(", "" ).replace( ")", "" ), seq_protein = object_protein.seq_consensus, start_accumulated = object_protein.accumulated_start_skipping_orf1a__for_web_application;
            for ( let pos_start = 0, pos_end = pos_start + window_size; pos_end <= object_protein.length ;  ) { // 0-based coordinates
                let seq_peptide = seq_protein.slice( pos_start, pos_end );
                let n_gaps = CountOccurrence( seq_peptide, '-' )
                if ( window_size == ( seq_peptide.length - n_gaps ) ) { // if number of non-gap residues are the same with window_size, add the peptide to the list
                    dataset.vaccine_design.arr_aligned_peptide_retrieved_from_consensus.push( { start_alignment: start_accumulated + pos_start, end_alignment: start_accumulated + pos_end, seq: seq_peptide, header: "3M_of_SARS_CoV_2_" + name_protein + "_" + String( pos_start + 1 ) + "to" + String( pos_end ), n_mismatches: 0 } ); // 0-based coodinates
                    pos_start += 1;
                    pos_end = pos_start + window_size
                } else {
                    pos_end += n_gaps - ( seq_peptide.length - window_size ); // if number of non-gap residues are not the same with window_size, extend pos_end to include more residues.
                }
            }
        }
        str_message = "<b>" + String( dataset.vaccine_design.arr_aligned_peptide_retrieved_from_consensus.length ) + ' peptides were successfully generated for window size ' + String( window_size ) + '</b>';
        console.log( "[Retrieve_Peptides] ", str_message );
        Dismissible_Alert( "#modal_generate_peptides_alert_container", "success", str_message ) // display number of peptides generated via an alert message  
    }
    function AnalyzeVaccineDesign( ) { // analyze vaccine design with the current view of MolecularMimicryMap
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        console.log( "analyzing a given list of vaccine candidates..." )
        object_plot_BCellCrossReactivity.arr_data_selected = ArrayBooleanIndexing( object_plot_BCellCrossReactivity.arr_data, object_plot_BCellCrossReactivity.mask_selected );
        object_plot_TCellCrossReactivity.arr_data_selected = ArrayBooleanIndexing( object_plot_TCellCrossReactivity.arr_data, object_plot_TCellCrossReactivity.mask_selected );
        let tree_bcellcrossreactivity_data = createIntervalTree( ArrayTranspose( [ nj.array( unpack( object_plot_BCellCrossReactivity.arr_data_selected, "target_representative_accumulated_start__for_web_application" ) ).subtract( 1 ).tolist( ), nj.array( unpack( object_plot_BCellCrossReactivity.arr_data_selected, "target_representative_accumulated_end__for_web_application" ) ).subtract( 0.1 ).tolist( ) ] ) ), tree_tcellcrossreactivity_data = createIntervalTree( ArrayTranspose( [ nj.array( unpack( object_plot_TCellCrossReactivity.arr_data_selected, "target_representative_accumulated_start__for_web_application" ) ).subtract( 1 ).tolist( ), nj.array( unpack( object_plot_TCellCrossReactivity.arr_data_selected, "target_representative_accumulated_end__for_web_application" ) ).subtract( 0.1 ).tolist( ) ] ) ); // build interval trees with 0-based coordinates
        // analyze vaccine candidate based on the currently available data in this application
        let l_start_vaccine_design = dataset.vaccine_design.dict_data[ "start_alignment" ], l_end_vaccine_design = dataset.vaccine_design.dict_data[ "end_alignment" ];
        dataset.vaccine_design.dict_data[ "number_of_overlapped_potential_b_cell_cross_reactive_epitopes" ] = [ ], dataset.vaccine_design.dict_data[ "number_of_overlapped_potential_t_cell_cross_reactive_epitopes" ] = [ ]; 
        // analyze using vaccine_metric data
        let l_col = Object.keys( dataset.vaccine_metric.dict_data );
        // if vaccinemetrics data has not been loaded, load the data 
        if ( l_col.length == 0 ) {
            VaccineMetrics_Apply_Visibility( true ); // preprocess and draw plots of vaccine metrics if the plots have not been drawn
            l_col = Object.keys( dataset.vaccine_metric.dict_data ); // update column names
        }
        for ( let i = 0; i < l_col.length; i ++ ) { dataset.vaccine_design.dict_data[ l_col[ i ] ] = [ ]; } // initialize data containers
        for ( let i = 0; i < l_start_vaccine_design.length; i ++ ) { 
            let start = l_start_vaccine_design[ i ], end = l_end_vaccine_design[ i ], counter_overlapped_bcellcrossreactivity_data = 0, counter_overlapped_tcellcrossreactivity_data = 0; 
            tree_bcellcrossreactivity_data.queryInterval( start - 1, end - 0.1, function( interval ) { counter_overlapped_bcellcrossreactivity_data ++; } ); // since the "interval-tree-id" consider a point overlap as an overlap, 0-based coordinate requires subtraction of 0.1 from either the start or the end of the interval.
            tree_tcellcrossreactivity_data.queryInterval( start - 1, end - 0.1, function( interval ) { counter_overlapped_tcellcrossreactivity_data ++; } );
            dataset.vaccine_design.dict_data[ "number_of_overlapped_potential_b_cell_cross_reactive_epitopes" ].push( counter_overlapped_bcellcrossreactivity_data );
            dataset.vaccine_design.dict_data[ "number_of_overlapped_potential_t_cell_cross_reactive_epitopes" ].push( counter_overlapped_tcellcrossreactivity_data );
            for ( let j = 0; j < l_col.length; j ++ ) {
                let col = l_col[ j ];
                switch( col ) {
                    case "type_of_structural_data" : 
                    case "secondary_structure_classification__dssp_8_states" : 
                        dataset.vaccine_design.dict_data[ col ].push( FindTheMajority( dataset.vaccine_metric.dict_data[ col ].slice( start, end ) ) ); // retrieve list of vaccine metric data values with 0-based coordinates, and retrieve the majority classification for analysis
                        break;
                    default: dataset.vaccine_design.dict_data[ col ].push( Math.max( ... dataset.vaccine_metric.dict_data[ col ].slice( start, end ) ) ); // retrieve list of vaccine metric data values with 0-based coordinates, and retrieve the maximum value for analysis
                }
            }
        }
        dataset.vaccine_design.string_csv = ''; // initialize a data container for downloading file
    }
    function ProcessVaccineCandidate( ) { // a pipeline to parse and process loaded peptide vaccine candidates
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        AlignPeptide( ); // align peptides to concatanated consensus protein sequence for the virus   
        AnalyzeVaccineDesign( );
        dataset.vaccine_design.plotly = { }, dataset.vaccine_design.dict_y_axis_max = { }; // initialize data related to updating the plotly plot after plotly_relayout 
        Draw_DesignedVaccineTrace( "updated_peptides" );
        Loading_Screen( false );
    }
    function Update_Peptides( mode_update ) {
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        let name_file = dataset.vaccine_design.l_file_fasta[ 0 ].name;
        if ( mode_update == 'append' ) { 
            dataset.vaccine_design.arr_aligned_peptide.push( ... dataset.vaccine_design.arr_aligned_peptide_retrieved_from_consensus ); 
            dataset.vaccine_design.l_file_fasta[ 0 ].name = name_file.slice( 0, name_file.lastIndexOf( '.' ) ) + ".plus.3M_of_SARS_CoV_2.custom_peptides.fa"; // modify file names for downloading
        } 
        else if ( mode_update == "replace" ) { 
            dataset.vaccine_design.arr_aligned_peptide = dataset.vaccine_design.arr_aligned_peptide_retrieved_from_consensus;
            dataset.vaccine_design.l_file_fasta[ 0 ].name = "3M_of_SARS_CoV_2.custom_peptides.fa"; // modify file names for downloading
        }
        AlignPeptide_Post_Processing( );
        AnalyzeVaccineDesign( );
        dataset.vaccine_design.plotly = { }, dataset.vaccine_design.dict_y_axis_max = { }; // initialize data related to updating the plotly plot after plotly_relayout 
        Draw_DesignedVaccineTrace( "updated_peptides" );
    }
    
    function Retrieve_Selection_of_Peptides( ) {
        if ( ! ( "selection" in dataset.vaccine_design ) ) { dataset.vaccine_design.selection = { }; } // add selection object if not present in the vaccine_design object
        dataset.vaccine_design.selection.selection_mode_include_or_exclude = $('#radio__Vaccine_Design__Selection_Thresholding_Mode__Include_or_Exclude label.active input').attr( "value" ); // retrieve selection mode
        dataset.vaccine_design.selection.selection_mode_above_or_below = $('#radio__Vaccine_Design__Selection_Thresholding_Mode__Above_or_Below label.active input').attr( "value" ); // retrieve selection mode
        
        let float_threshold = parseFloat( document.getElementById( "input_threshold_select_peptides" ).value );
        if ( ! isNaN( float_threshold ) && float_threshold > 0 ) { dataset.vaccine_design.selection.dict_threshold[ dataset.vaccine_design.name_y_axis ] = float_threshold; } // update float_threshold value // valid float_threshold should be a positive value
        
        let l_data = dataset.vaccine_design.dict_data[ dataset.vaccine_design.name_y_axis ];
        let l_mask = dataset.vaccine_design.selection.selection_mode_above_or_below == 'Above' ? ArrayGreaterThan( l_data, float_threshold ) : ArrayLessThan( l_data, float_threshold );
        
        let l_bool_selected = dataset.vaccine_design.dict_data[ "selected" ], l_bool_selected_updated = lodash.cloneDeep( l_bool_selected ), bool_flag_include = dataset.vaccine_design.selection.selection_mode_include_or_exclude == 'Include', int_count_changed = 0;
        for ( let i = 0; i < l_bool_selected_updated.length; i ++ ) {
            if ( bool_flag_include && l_mask[ i ] && ! l_bool_selected_updated[ i ] ) { // include peptides
                l_bool_selected_updated[ i ] = true;
                int_count_changed ++;
            } else if ( ! bool_flag_include && l_mask[ i ] && l_bool_selected[ i ] ) { // exclude peptides
                l_bool_selected_updated[ i ] = false;
                int_count_changed ++;
            }
        }
        dataset.vaccine_design.selection.l_selected_previous = l_bool_selected, dataset.vaccine_design.selection.l_selected_current = l_bool_selected_updated;
        document.getElementById( "button_apply_change_select_peptides" ).disabled = false; // enable apply button
        document.getElementById( "button_undo_last_change_modal_select_peptides" ).disabled = true; // enable apply button
        str_message = String( ArraySum( l_mask ) ) + '/' + String( l_mask.length )  +  ' peptides ' + ( dataset.vaccine_design.selection.selection_mode_above_or_below == 'Above' ? "above" : "below" ) + ' threshold were retrieved.<br>Among these, ' + String( int_count_changed ) + ' peptides will be ' + ( dataset.vaccine_design.selection.selection_mode_include_or_exclude == 'Include' ? "included" : "excluded" ) + ' when applying current selection.';
        console.log( "[Retrieve_Selection_of_Peptides] ", str_message );
        Dismissible_Alert( "#modal_select_peptides_alert_container", "info", str_message ); // display number of peptides generated via an alert message  
    }
    function Update_Selection_of_Peptides( mode ) {
        if ( ! ( "selection" in dataset.vaccine_design ) ) { return; } // exits when a function call is invalid
        if ( ! ( "l_selected_previous" in dataset.vaccine_design.selection ) ) { return; } 
        
        if ( mode == 'apply' ) {
            dataset.vaccine_design.dict_data[ "selected" ] = dataset.vaccine_design.selection.l_selected_current;
        } else if ( mode == 'undo_last_change' ) {
            dataset.vaccine_design.dict_data[ "selected" ] = dataset.vaccine_design.selection.l_selected_previous;
        }
        document.getElementById( "div_display_current_number_of_selected_peptides" ).innerHTML = "Total number of selected peptides: " + String( ArraySum( dataset.vaccine_design.dict_data[ "selected" ] ) ) + '.'; // update description in modal_select_peptides
        document.getElementById( "button_apply_change_select_peptides" ).disabled = mode == 'apply'; // update disabled status of undo last change button
        document.getElementById( "button_undo_last_change_modal_select_peptides" ).disabled = mode == 'undo_last_change';
        Draw_DesignedVaccineTrace( "update_selection" ); // update selection
    }

    function Draw_DesignedVaccineTrace( mode_drawing ) {
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        // check validility of funciton call
        if ( dataset.vaccine_design.arr_aligned_peptide.length == 0 ) { console.log( "[Draw_DesignedVaccineTrace] since there is no aligned peptides from the input vaccine candidates or the file has not been loaded, skip drawing a plot" ); return; } // if there are no aligned peptides, stop drawing the plot
        Loading_Screen( true ) // add loading screen
        let index_trace = dict_name_plot_to_trace_index__MolecularMimicryMap[ "vaccine_design" ]; // retrieve index of vaccine_design trace
        // prepare a trace for displaying designed vaccines
        dataset.vaccine_design.show = $( "#toggle_vaccine_design_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of vaccine design
        let trace = { };
        trace.visible = dataset.vaccine_design.show;
        // retrieve markers settings according to the selected peptides
        let l_bool_selected = dataset.vaccine_design.dict_data[ "selected" ], color_selected = "#1c03ff", color_not_selected = "#ffaf03";
        dataset.vaccine_design.l_color = [ ];
        for ( let i = 0; i < l_bool_selected.length; i ++ ) { dataset.vaccine_design.l_color.push( l_bool_selected[ i ]? color_selected : color_not_selected ); } // update color based on selection
        trace.marker = { size: 10, opacity: 0.5, color: dataset.vaccine_design.l_color, line: { width: 2 }, symbol: "cross-open" };
        if ( mode_drawing == 'update_selection' ) { // update markers and exits
            Plotly.restyle( plotMolecularMimicryMap, trace, index_trace ); Loading_Screen( false ); return;
        }
        // retrieve y_axis values according to y-axis and y-axis max range setting
        let name_y_axis = document.getElementById( "select_yaxis_plot_vaccine_design" ).value, name_y_axis_previous = dataset.vaccine_design.name_y_axis; // retrieve current y_axis name
        dataset.vaccine_design.name_y_axis = name_y_axis; // update y-axis name
        
        if ( mode_drawing == "update_float_y_axis_range_max" ) {
            let float_y_axis_max = parseFloat( document.getElementById( "input_y_axis_range_max" ).value ); // retrieve and update y-axis max values 
            if ( ! isNaN( float_y_axis_max ) && float_y_axis_max > 0 ) { dataset.vaccine_design.dict_y_axis_max[ name_y_axis ] = float_y_axis_max; } // update y_axis_range_max value // valid y_axis_max should be a positive value
        } else {
            if ( ! ( name_y_axis in dataset.vaccine_design.dict_y_axis_max ) ) { 
                let l = dataset.vaccine_design.dict_data[ name_y_axis ];
                dataset.vaccine_design.dict_y_axis_max[ name_y_axis ] = Math.max( ... l );
                dataset.vaccine_design.selection.dict_threshold[ name_y_axis ] = ( ArraySum( l ) / l.length ) + ArrayStandardDeviation( l ); // retrieve sum + 1 std.
            } // if max value for y_axis range does not exist, use the max value of y_values by default
            let float_y_axis_max = dataset.vaccine_design.dict_y_axis_max[ name_y_axis ], float_y_axis_threshold = dataset.vaccine_design.selection.dict_threshold[ name_y_axis ];
            document.getElementById( "input_y_axis_range_max" ).value = CheckInt( float_y_axis_max ) ? String( float_y_axis_max ) : float_y_axis_max.toFixed( 3 ); // show float_y_axis_max value of the name_y_axis
            document.getElementById( "input_threshold_select_peptides" ).value = CheckInt( float_y_axis_threshold ) ? String( float_y_axis_threshold ) : float_y_axis_threshold.toFixed( 3 ); // show float_y_axis_threshold value of the name_y_axis
        } // set default y_axis_range_max 
        dataset.vaccine_design.plotly.y = ArrayCap( dataset.vaccine_design.dict_data[ name_y_axis ], dataset.vaccine_design.dict_y_axis_max[ name_y_axis ] ); // cap at specific value
        let arr_y = nj.array( dataset.vaccine_design.plotly.y ); 
        trace.y = arr_y.divide( arr_y.max( ) / 1.70 ).subtract( 5.85 ).tolist( ); // retrieve y-axis values
        if ( mode_drawing == "update_name_y_axis" || mode_drawing == "update_float_y_axis_range_max" ) { // update only y and exists
            Plotly.restyle( plotMolecularMimicryMap, { y: [ trace.y ] }, [ index_trace ] ); Loading_Screen( false ); Adjust_Layout_MolecularMimicryMap( "vaccine_design_y_axis_updated" ); return;
        }
        // retrieve custom data and other settings for drawing a new trace
        let l_start = dataset.vaccine_design.dict_data[ "start_alignment" ], l_end = dataset.vaccine_design.dict_data[ "end_alignment" ]; // 0-based coordinates
        trace.x = nj.array( l_start ).add( l_end ).divide( 2 ).tolist( );
        trace.marker = { size: 10, opacity: 0.5, color: ArrayFull( l_start.length, color_selected ), line: { width: 2 }, symbol: "cross-open" }; // selected color: dark green 
        trace.type = 'scattergl';
        trace.mode = 'markers';
        trace.name = "vaccine_design";
        trace.showlegend = false;
        trace.error_x = { type: 'data', array: nj.array( l_end ).subtract( l_start ).divide( 2 ).tolist( ), visible: true, width: 0, thickness: 1 }; // represent alignment by using errorbar
        trace.hovertemplate = ["header: %{customdata[3]}",
                               'seq: <b>%{customdata[4]}</b>',
                               '<b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b> (%{customdata[5]:.0f} mismatch)',
                               '',
                               'number of <b>mutated</b> proteins: <b>%{customdata[10]:.0f}</b>',
                               'number of overlapped predicted <b>B-cell cross-reactive epitopes</b>: <b>%{customdata[6]:.0f}</b>',
                               'number of overlapped predicted <b>T-cell cross-reactive MHC epitopes</b>: <b>%{customdata[7]:.0f}</b>',
                               'number of overlapped predicted <b>MHC-I epitopes</b> (af<0.001): <b>%{customdata[16]:.0f}</b>',
                               'number of overlapped predicted <b>MHC-II epitopes</b> (af<0.001): <b>%{customdata[17]:.0f}</b>',
                               'number of <b>positive B-cell assays</b> for overlapped IEDB epitopes: <b>%{customdata[8]:.0f}</b>',
                               'number of <b>positive T-cell assays</b> for overlapped IEDB epitopes: <b>%{customdata[9]:.0f}</b>',
                               'Relative accessible surface area: <b>%{customdata[18]:.1%}</b>',
                               'B cell linear epitope prediction score (BepiPred): <b>%{customdata[14]:.3f}</b>',
                               'MHC-I epitope processing score (MHCflurry): <b>%{customdata[15]:.3f}</b>',
                               '<extra></extra>' ].join( "<br>" );
        let n_residues = dataset.consensus_sequence_virus.accumulated_length;
        let trace_vaccine_design_lower_bound = { x : [ 0, n_residues ], y : [ -4, -4 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "vaccine_design__lower_bound" }, trace_vaccine_design_upper_bound = { x : [ 0, n_residues ], y : [ -6, -6 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "vaccine_design__upper_bound" };
        trace.customdata = ArrayTranspose( [dataset.vaccine_design.dict_data[ "protein_name" ], 
                                            dataset.vaccine_design.dict_data[ "start" ], 
                                            dataset.vaccine_design.dict_data[ "end" ], 
                                            dataset.vaccine_design.dict_data[ "header" ], 
                                            dataset.vaccine_design.dict_data[ "seq" ],  
                                            dataset.vaccine_design.dict_data[ "n_mismatches" ], // 5
                                            dataset.vaccine_design.dict_data[ "number_of_overlapped_potential_b_cell_cross_reactive_epitopes" ], 
                                            dataset.vaccine_design.dict_data[ "number_of_overlapped_potential_t_cell_cross_reactive_epitopes" ], 
                                            dataset.vaccine_design.dict_data[ "count_iedb_epitope_with_bcell_assay" ], 
                                            dataset.vaccine_design.dict_data[ "count_iedb_epitope_with_tcell_assay" ], 
                                            dataset.vaccine_design.dict_data[ "count_non_consensus_residue" ], // 10
                                            dataset.vaccine_design.dict_data[ "count_non_consensus_residue__USA" ], 
                                            dataset.vaccine_design.dict_data[ "count_non_consensus_residue__India" ], 
                                            dataset.vaccine_design.dict_data[ "count_non_consensus_residue__Australia" ], 
                                            dataset.vaccine_design.dict_data[ "score_linear_bcell_epitope_prediction__bepipred" ], 
                                            dataset.vaccine_design.dict_data[ "avg_processing_score_mhc_i" ], // 15
                                            dataset.vaccine_design.dict_data[ "count_peptide_binding_common_mhc_i_alleles__537_alleles__min_allele_frequency_0.001" ], 
                                            dataset.vaccine_design.dict_data[ "count_peptide_binding_common_mhc_ii_alleles__1668_alleles__min_allele_frequency_0.001" ],
                                            dataset.vaccine_design.dict_data[ "relative_accessible_surface_area" ] ] ); // add custom data for hoverinfo.
        dataset.vaccine_design.data = [ trace_vaccine_design_lower_bound, trace_vaccine_design_upper_bound, trace ];
        if ( mode_drawing == "new_trace" || ! ( "vaccine_design" in dict_name_plot_to_trace_index__MolecularMimicryMap ) ) { // draw new trace
            console.log( '[Draw_DesignedVaccineTrace] adding new traces ...' );
            dataset.vaccine_design.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
            Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( dataset.vaccine_design.data ) );
            dataset.vaccine_design.index_trace_end = plotMolecularMimicryMap.data.length;
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; } // update mapping of name of each trace to trace index
        } else if ( mode_drawing == "new_analysis" || mode_drawing == "updated_peptides" ) { // update the existing trace
            console.log( '[Draw_DesignedVaccineTrace] updating existing trace ...' );
            trace.x = [ trace.x ];
            trace.y = [ trace.y ];
            trace.customdata = [ trace.customdata ];
            Plotly.restyle( plotMolecularMimicryMap, trace, index_trace ); // update vaccine_design trace based on updated peptides
        }
        Loading_Screen( false ); Adjust_Layout_MolecularMimicryMap( "vaccine_design_y_axis_updated" ); return;// update y-axis annotation
    }
    function Download_Analysis_Result__Vaccine_Design( ) { // download analysis result of vaccine candidate as a csv file
        if ( dataset.vaccine_design.string_csv.length == 0 ) {
            let df = new DataFrame( dataset.vaccine_design.dict_data );
            dataset.vaccine_design.string_csv = df.toCSV( true );
        }
        let blob = new Blob( [ dataset.vaccine_design.string_csv ], { type: "text/plain;charset=utf-8" } );
        let name_file = dataset.vaccine_design.l_file_fasta[ 0 ].name;
        name_file = name_file.slice( 0, name_file.lastIndexOf( '.' ) ) + '_MolecularMimicryMap_of_SARS-CoV-2_analysis_result.csv'
        saveAs( blob, name_file ); // save file 
    }
    
    var l_parsed_data = [ ];
    var function_colormap_rsa = chroma.scale( [ 'black', 'white' ] ), function_colormap_score_blosum = chroma.scale( [ '#f00','white', '#0f0' ] ), function_colormap_torsion_angle = chroma.scale( [ '#52f9ff', '#972ff7', 'yellow', '#52f9ff' ] ), function_colormap_score_iedb_epitope = chroma.scale( [ '#ff00f2', '#1500ff' ] ), function_colormap_rainbow = chroma.scale( [ '#f00','#0f0','#00f','#f00' ] ).mode('hsl'); // define functions for colormaps
    async function LoadRemoteData( l_dir_file ) { // load list of given tsv files from remote locations through asynchrous operations
        return new Promise( async function( resolve, reject ) { 
            console.log( "[LoadRemoteData] remote data fetch started:", l_dir_file );
            Loading_Screen( true ) // add loading screen
            let l_dir_file_not_downloaded = [ ];
            for ( let i = 0; i < l_dir_file.length; i ++ ) { // ignore already downloaded files
                if ( ! ( l_dir_file[ i ] in object_data.file.dict_dir_file_to_parsed_data ) ) { 
                    l_dir_file_not_downloaded.push( l_dir_file[ i ] );
                } // if current file has not been downloaded, download the file 
            }
            l_dir_file = l_dir_file_not_downloaded;
            let l_promise = l_dir_file.map( function( file ) { 
                if( file.split( '.' ).slice( - 1 )[ 0 ] == "tsv" ) { // if given remote file is a tsv file
                    return new Promise ( function( resolve, reject ) {
                        Papa.parse( file, { download: true, header: true, skipEmptyLines: false, delimiter: '\t', dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ) }, error: reject } );
                    });
                } else if ( file.split( '.' ).slice( - 2 ).join( '.' ) == "base64.txt" ) { // if given remote file is base64-encoded binary file
                    return new Promise ( function( resolve, reject ) {
                        fetch( file )
                            .then( ( response ) => {
                              return response.text( );
                           }).then( ( text_base64 ) => {
                              return ParseBase64GzippedText( text_base64 );
                           }).then( ( text ) => {
                              Papa.parse( text, { download: false, header: true, skipEmptyLines: false, delimiter: '\t', dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ) }, error: reject } );
                           }).catch( err => { reject } );
                    });
                }
            }); // 'skipEmptyLines' is set to false to allow reading empty lines in some input files // due to 'skipEmptyLines: false' option, the last line is empty, and should be discarded
            let results = await Promise.all( l_promise ); // wait until all files have been parsed by Papa.parse
            l_parsed_data = [ ]; // empty a list
            l_parsed_data.push( ... results );
            for ( let i = 0; i < l_dir_file.length; i ++ ) { 
                object_data.file.dict_dir_file_to_parsed_data[ l_dir_file[ i ] ] = l_parsed_data[ i ];
            } // put parsed data into a dictionary
            console.log( "[LoadRemoteData] remote data loaded:", l_dir_file );
            resolve( "[LoadRemoteData] resolved" )
            Loading_Screen( false ) // add loading screen
        });
    }
    async function LoadOptiVax( ) { // load OptiVax peptide vaccine candidates
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        return new Promise( async function( resolve, reject ) {
            if ( object_data.flag.vaccine_design_optivax_loaded ) {
                console.log( "[LoadOptiVax] OptiVax Peptides alreadly loaded" );
                resolve( "[LoadOptiVax] OptiVax Peptides alreadly loaded" ); }
            dataset.vaccine_design = { l_file_fasta: [ ], arr_aligned_peptide: [ ], dict_header_to_seq: { }, dict_duplicated_header_count: { }, data: [ ], dict_data: { }, dict_y_axis_max: { }, name_y_axis: null, plotly: { }, selection: { dict_threshold: { } } }; // initialize the object
            dataset.vaccine_design.l_file_fasta = [ { name: "Optivax.Supplementary_Materials.fa" } ];
            await LoadRemoteFasta( object_data.file.base_url + "data/peptides/Optivax/Optivax.Supplementary_Materials.fa" ); // load a fasta file at a time
            ProcessVaccineCandidate( );
            console.log( "[LoadOptiVax] OptiVac peptide vaccine candidates loaded" );
            dataset.flag.vaccine_design_optivax_loaded = true; // update flag indicating the Optivax file has been loaded
            resolve( "[LoadOptiVax] resolved" );
        });
    }
    async function LoadLocalData( l_file ) {
        Loading_Screen( true ) // add loading screen
        let l_promise = l_file.map( function( file ) { 
            return new Promise ( function( resolve, reject ) {
                Papa.parse( file, { header: true, skipEmptyLines: false, delimiter: '\t', dynamicTyping: true, complete: function( results ) { resolve( results.data.slice( 0, results.data.length - 1 ) ) }, error: reject } ); }); }); // 'skipEmptyLines' is set to false to allow reading empty lines in some input files // due to 'skipEmptyLines: false' option, the last line is empty, and should be discarded
        let results = await Promise.all( l_promise ) // wait until all files have been parsed by Papa.parse
        l_parsed_data = [ ]; // empty a list
        l_parsed_data.push( ... results ); 
        for ( let i = 0; i < l_file.length; i ++ ) { object_data.file.dict_dir_file_to_parsed_data[ l_file[ i ].name ] = l_parsed_data[ i ]; } // put parsed data into a dictionary
        console.log( "[LoadLocalData] parsing completed:", object_data.file.dict_dir_file_to_parsed_data );
        await ParseData( );
        Loading_Screen( false );
    }
    function SplitColumn( dictarr, delimiter = '|' ) { // split column name of the given dict_array into two with the given delimiter character and return dict_dict_array # 20201106
        let dictdictarr = { };
        for ( let col in dictarr ) {
            let col_split = col.split( "|" );
            if ( ! ( col_split[ 0 ] in dictdictarr ) ) {
                dictdictarr[ col_split[ 0 ] ] = { };
            }
            dictdictarr[ col_split[ 0 ] ][ col_split[ 1 ] ] = dictarr[ col ];
        }
        return dictdictarr;
    }
    function SubsetDictDictArr( dictdictarr, l_col_inner, fill_empty_columm_if_not_exist = true, fill_value = 0 ) { // subset a given dictdictarr with a given list of l_col_inner list containing column names of the inner layer. if only one column is given, return dictarray containing the inner column # 20201106
        // 'fill_empty_columm_if_not_exist' : if true, fill empty column with 'fill_value' value
        if ( Array.isArray( l_col_inner ) ) { // subset a given dictdictarr with a given list of l_col_inner list containing column names of the inner layer.
            let dictdictarr_subset = { };
            for ( let col_outer in dictdictarr ) {
                for ( let i = 0; i < l_col_inner.length; i ++ ) {
                    let col_inner = l_col_inner[ i ];
                    if ( ! ( col_inner in dictdictarr[ col_outer ] ) ) {
                        if ( fill_empty_columm_if_not_exist ) { // 'fill_empty_columm_if_not_exist' : if true, fill empty column with 'fill_value' value
                            dictdictarr[ col_outer ][ col_inner ] = ArrayFull( dictdictarr[ col_outer ][ Object.keys( dictdictarr[ col_outer ] )[ 0 ] ].length, fill_value ); // assume that the length of array is same for all columns
                        }
                    } else {
                        if ( ! ( col_outer in dictdictarr_subset ) ) {
                            dictdictarr_subset[ col_outer ] = { };
                        }
                        dictdictarr_subset[ col_outer ][ col_inner ] = dictdictarr[ col_outer ][ col_inner ]
                    }
                }
            }
            return dictdictarr_subset;
        } else { // if only one column is given, return dictarray containing the inner column
            let col_inner_subset = l_col_inner;
            let dictarr = { };
            for ( let col_outer in dictdictarr ) {
                if ( ! ( col_inner_subset in dictdictarr[ col_outer ] ) ) {
                    dictarr[ col_outer ] = ArrayFull( dictdictarr[ col_outer ][ Object.keys( dictdictarr[ col_outer ] )[ 0 ] ].length, fill_value ); // assume that the length of array is same for all columns
                } else {
                    dictarr[ col_outer ] = dictdictarr[ col_outer ][ col_inner_subset ]
                }
            }
            return dictarr;
        }
    }
    function ParseData_DatasetCore( name_dataset ) { // parse 'arr_data_blosum62' and build blosum62 matrix # 20210110
        console.log( "[ParseData_DatasetCore] Core dataset initialization started for " + name_dataset );
        let dir_folder = object_data.file.base_url + "data/base64/" + name_dataset + "/", // retrieve directory of the current folder of the current dataset
            dataset = object_data.main.dataset[ name_dataset ];
        
        // modify HTML elements
        if ( ! object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when MHC ligand prediction data does not exist
            $( "#plotly_graph_t_cell_cross_reactivity" ).collapse( 'hide' ); // hide T-cell cross-reactivity panel
            $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).prop( "disabled", true ); 
            $( "#btn_toggle_mhc_cross_reactivity_metrics" ).prop( "disabled", true ); 
			$( "#container_expression_panel_MolecularMimicryMap" ).collapse( 'hide' ); // hide gene expression panel
			$( "#btn_toggle_gene_expression_panel" ).prop( "disabled", true ); 
        } else { // activate buttons
            $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).prop( "disabled", false ); 
            $( "#btn_toggle_mhc_cross_reactivity_metrics" ).prop( "disabled", false );
            $( "#btn_toggle_gene_expression_panel" ).prop( "disabled", false ); 			
        }
        
        if ( ! object_data.flag.human_label_represents_virus ) {
            // initialize 
            if ( ! ( 'gtex' in dataset ) ) { 
                dataset.gtex = { };
                dataset.gtex.dict_name_tissue_to_color = {
                    "Adipose Tissue (n=1204)" : "#FF4500",
                    "Muscle (n=803)" : "#9370DB",
                    "Blood Vessel (n=1335)" : "#B22222",
                    "Heart (n=861)" : "#4B0082",
                    "Uterus (n=142)" : "#FF69B4",
                    "Vagina (n=156)" : "#FF1493",
                    "Breast (n=459)" : "#00CED1",
                    "Skin (n=1809)" : "#0000FF",
                    "Salivary Gland (n=162)" : "#8FBC8F",
                    "Brain (n=2642)" : '#FFD700',
                    "Adrenal Gland (n=258)" : '#228B22',
                    "Thyroid (n=653)" : "#006400",
                    "Lung (n=578)" : "#7FFF00",
                    "Spleen (n=241)" : "#556B2F",
                    "Pancreas (n=328)" : "#8B0000",
                    "Esophagus (n=1445)" : "#800000",
                    "Stomach (n=359)" : "#F0E68C",
                    "Colon (n=779)" : "#CD853F",
                    "Small Intestine (n=187)" : "#2F4F4F",
                    "Prostate (n=245)" : "#D3D3D3",
                    "Testis (n=361)" : "#778899",
                    "Nerve (n=619)" : "#F0E68C",
                    "Blood (n=929)" : "#FF0000",
                    "Pituitary (n=283)" : "#98FB98",
                    "Ovary (n=180)" : "#FFC0CB",
                    "Liver (n=226)" : "#9ACD32",
                    "Kidney (n=89)" : "#00FFFF",
                    "Cervix Uteri (n=19)" : "#DDA0DD",
                    "Fallopian Tube (n=9)" : "#FFDAB9",
                    "Bladder (n=21)" : "#8B0000"
                }; // define color for each tissue
            }
            if ( ! ( 'scrnaseq' in dataset ) ) { 
                dataset.scrnaseq = { option: { }, dictdictarr: { }, dict_dir_file_to_cached_data: { } }; // object for saving settings for scrnaseq plot // dictionary to save cached data
                dataset.scrnaseq.metadata = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dataset.dir_folder + "scrnaseq.metadata.tsv.gz.base64.txt" ] ); // load metadata of scRNA-seq datasets
                dataset.scrnaseq.setting = { histogram : { start: 0, step: 0.1 }, gene_of_interest: "ACE2", thres_n_clusters_for_label_newline: 22, cache : { n_records: 5 } } // setting for compact histogram count data. // set maximum records for saving cache for rapid plotting // 'thres_n_clusters_for_label_newline': a threshold number of cluster that removes line breaks in the labels.

                PlotExpression_scRNA_Seq_Update_Select_Options( "20200804_NasalSwab_Broad_BCH_UMMC_to_CZI.h5ad" ); // update select option and select given dataset by default (update selection label)
            }
            if ( ! ( 'l_algorithm' in dataset ) ) {
                dataset.l_algorithm = unpack( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "algorithms.tsv.gz.base64.txt" ], 'value' ); } // list of algorithms
            if ( ! ( 'dictarr_data_mhc_allele' in dataset ) ) {
                dataset.dictarr_data_mhc_allele = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "mhc_allele.tsv.gz.base64.txt" ] ); }
            if ( ! ( 'dictdictarr' in dataset.gtex ) ) {
                dataset.gtex.dictdictarr = SplitColumn( Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "gtex.tsv.gz.base64.txt" ] ) ); } // retrieve dictionary-dictionary-array of gtex data
            // simply put arrays in the name space of the dataset
            dataset.arr_data_mhc_allele = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "mhc_allele.tsv.gz.base64.txt" ];
        } else {
            
        }

        // load dict_blosum62 score dictionary if it has not been loaded
        if ( ! ( 'dict_blosum62' in object_data.main ) ) { 
            let arr_data_blosum62 = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "blosum62.tsv.gz.base64.txt" ]; // blosum62 score matrix
            object_data.main.dict_blosum62 = { }; 
            for ( let i = 0; i < arr_data_blosum62.length; i ++ ) { 
                object_data.main.dict_blosum62[ arr_data_blosum62[ i ].pair_of_amino_acids ] = arr_data_blosum62[ i ].score_blosum62;
            }
        }
        if ( ! ( 'dictarr_data_acc_virus' in dataset ) ) {
            dataset.dictarr_data_acc_virus = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_virus.tsv.gz.base64.txt" ] ); }
        if ( ! ( 'dictarr_data_acc_pdb' in dataset ) ) {
            dataset.dictarr_data_acc_pdb = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_pdb.tsv.gz.base64.txt" ] ); }

            
        if ( ! ( 'acc_human' in dataset ) ) {
            dataset.acc_human = { };
            dataset.acc_human.dict_data_all = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_human.tsv.gz.base64.txt" ] );
            dataset.dictarr_data_acc_human = dataset.acc_human.dict_data_all;
            dataset.acc_human.dictionary_human_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( dataset.acc_human.dict_data_all[ object_data.setting.name_acc_human ].map( ( e ) => { return e.toUpperCase( ); } ) ); // index records according to datatype of records with the 'human' labels
        }
        // build dictionary-based index of human genes (gene_symbol)
        if ( ! ( 'dictionary_gene_symbol_lower_case_to_list_of_integer_index' in dataset ) ) {
            dataset.dictionary_gene_symbol_lower_case_to_list_of_integer_index = Index_list_with_dictionary( dataset.acc_human.dict_data_all[ object_data.setting.name_acc_human ].map( ( e ) => { return e.toLowerCase( ); } ) );
        } 
        
        // simply put arrays in the name space of the dataset
        dataset.arr_data_acc_virus = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_virus.tsv.gz.base64.txt" ];
        dataset.arr_data_acc_pdb = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_pdb.tsv.gz.base64.txt" ];
        dataset.arr_data_acc_human = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_human.tsv.gz.base64.txt" ];
        dataset.arr_data_alignment_human_pdb = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "alignment_human_pdb__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_alignment_human_virus = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "alignment_human_virus__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_alignment_virus_pdb = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "alignment_virus_pdb__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_structural_property_human = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "structural_property_human__compact__for_web_application.tsv.gz.base64.txt" ];
        dataset.arr_data_structural_property_virus = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "structural_property_virus__compact__for_web_application.tsv.gz.base64.txt" ];

        // retrieve list of virus species
        if ( object_data.flag.human_label_represents_virus ) { // retrieve list of virus species when the dataset of cross-reactivity between viruses has been loaded.
            if ( "Species" in dataset.dictarr_data_acc_human ) {
                dataset.l_virus_species = Unique( dataset.dictarr_data_acc_human.Species );
            } else {
                
            }
        } else if ( "Species" in dataset.dictarr_data_acc_virus ) { 
            dataset.l_virus_species = Unique( dataset.dictarr_data_acc_virus.Species );
        } else {
            dataset.l_virus_species = [ "Severe acute respiratory syndrome coronavirus 2" ]; // virus species is SARS-CoV-2 by default 
        }
        //  assign color to human proteins // build a colormap for representing accessions of human proteins
        if ( ! ( 'l_colormap_rainbow_acc_human' in dataset ) ) {
            let l_gene_symbol = dataset.acc_human.dict_data_all[ object_data.setting.name_acc_human ];
            dataset.l_colormap_rainbow_acc_human = [ ]; // initialize the list of mapped colors
            dataset.l_float_for_colormap_rainbow_acc_human = [ ];
            for ( let i = 0; i < l_gene_symbol.length; i ++ ) {
                let str_gene_symbol = l_gene_symbol[ i ], float_for_colormap = ( Math.abs( str_gene_symbol.hashCode( ) ) % 10000 ) / 10000, str_color = function_colormap_rainbow( float_for_colormap ).toString( );
                dataset.l_float_for_colormap_rainbow_acc_human.push( float_for_colormap )
                dataset.l_colormap_rainbow_acc_human.push( str_color ); // assign color to gene_symbol using a 32-bit hashing function
                
                object_data.main.dictionary_human_gene_symbol_lower_case_to_color[ str_gene_symbol.toLowerCase( ) ] = str_color; // update global colormap
            }
        }
        //  assign color to human proteins and virus species // build a colormap for representing accessions of human proteins
        if ( ! ( 'dict_virus_species_to_rainbow_color' in dataset ) ) {
            let int_hash = 4217, // integer used for retrieving float from the hash
                dict_virus_species_to_float_rainbow_color_preset = { "Severe acute respiratory syndrome coronavirus 2" : 0.84,
                    "Severe acute respiratory syndrome-related coronavirus" : 0.04,
                    "Middle East respiratory syndrome-related coronavirus" : 0.12,
                    "Betacoronavirus 1" : 0.18,
                    "Human coronavirus 229E" : 0.26,
                    "Human coronavirus NL63" : 0.42,
                    "Human coronavirus HKU1" : 0.5,
                    "Coronavirus cya-BetaCoV/2019" : 0.54,
                    "Coronavirus cyb-BetaCoV/2019" : 0.58,
                    "Coronavirus cyc-BetaCoV/2019" : 0.76 }; // manually selected colors for virus species (for more intuitive visualization )
            dataset.dict_virus_species_to_rainbow_color = { }; // initialize the list of mapped colors
            dataset.dict_virus_species_to_float_rainbow_color = { };

            
            for ( let i = 0; i < dataset.l_virus_species.length; i ++ ) {
                let str_virus_species = dataset.l_virus_species[ i ],
                    float_for_colormap = ( str_virus_species in dict_virus_species_to_float_rainbow_color_preset ) ? dict_virus_species_to_float_rainbow_color_preset[ str_virus_species ] : ( Math.abs( str_virus_species.hashCode( ) ) % int_hash ) / int_hash, // assign float using string-based hashing
                    str_color = function_colormap_rainbow( float_for_colormap ).toString( );
                dataset.dict_virus_species_to_float_rainbow_color[ str_virus_species ] = float_for_colormap;
                dataset.dict_virus_species_to_rainbow_color[ str_virus_species ] = str_color; // assign color to gene_symbol using a 32-bit hashing function
                
                object_data.main.dictionary_virus_species_to_color[ str_virus_species ] = str_color; // update global colormap
            }
        }
        console.log( "[ParseData_DatasetCore] Core dataset initialized for " + name_dataset );
    }
    function ParseData_AlignmentToVirus( name_dataset ) {
        console.log( "[ParseData_AlignmentToVirus] dataset initialization started for " + name_dataset + " visualized with 'AlignmentToVirus' mode" );
        // parse dataset for visualization with AlignmentToVirus alignment mode
        let dir_folder = object_data.file.base_url + "data/base64/" + name_dataset + "/", // retrieve directory of the current folder of the current dataset
            dataset = object_data.main.dataset[ name_dataset ];
        
        // modify HTML elements
        $( "#btn_for_opening_navbar_vaccine_design" ).prop( "disabled", false );
        $( "#btn_toggle_human_protein_metrics" ).prop( "disabled", false ); // enable human metrics plot
        $( "#button_update_human_protein_metrics_plot" ).prop( "disabled", false ); 
        $( "#toggle_vaccine_metrics_MolecularMimicryMap" ).prop( "disabled", false ); 
        $( "#toggle_vaccine_design_MolecularMimicryMap" ).prop( "disabled", false ); 
        
        // initialize dataset specific for alignment to virus reference proteome
        if ( ! ( 'iedb_epitope_virus' in dataset ) ) { 
            dataset.iedb_epitope_virus = { };
            dataset.iedb_epitope_virus.dict_data = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "iedb_epitope_virus.tsv.gz.base64.txt" ] ); // IEDB records of virus proteins
        }
        if ( ! ( 'vaccine_metric' in dataset ) ) { 
            dataset.vaccine_metric = { dict_data: { }, data: [ ], l_name_data : [ ] }; }
        if ( ! ( 'vaccine_design' in dataset ) ) { 
            dataset.vaccine_design = { l_file_fasta: [ ], arr_aligned_peptide: [ ], dict_header_to_seq: { }, dict_duplicated_header_count: { }, data: [ ], dict_data: { }, dict_y_axis_max: { }, name_y_axis: null, plotly: { }, selection: { dict_threshold: { } } }; } // "dict_y_axis_max" dictionary containing max value of y-axis range for each y-axis name.
        
        // simply put arrays in the name space of the dataset
        dataset.arr_data_acc_virus_representative = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "acc_virus_representative.tsv.gz.base64.txt" ];
        
        // retrieve a trace of concatanated consensus virus protein sequence
        if ( ! ( 'consensus_sequence_virus' in dataset ) ) { 
            dataset.consensus_sequence_virus = { };
            dataset.consensus_sequence_virus.seq_consensus_concatenated = unpack( dataset.arr_data_acc_virus_representative, 'seq_consensus' ).join( '' ); // retrieve concatanated consensus_sequence of virus proteins
            dataset.consensus_sequence_virus.accumulated_length = dataset.consensus_sequence_virus.seq_consensus_concatenated.length;
            dataset.consensus_sequence_virus.l_x = nj.arange( dataset.consensus_sequence_virus.accumulated_length ).tolist( ) // 0-based coordinates of x-axis
            
            // add dictionary mapping accumulated coordinates to protein and coordinate in individual protein
            dataset.consensus_sequence_virus.dict_accumulated_coord_to_individual_coord = { };
            dataset.consensus_sequence_virus.dict_accumulated_coord_to_acc_rep = { };
            for ( let i = 0; i < dataset.arr_data_acc_virus_representative.length; i ++ ) { 
                let protein = dataset.arr_data_acc_virus_representative[ i ], accumulated_start = protein.accumulated_start_skipping_orf1a__for_web_application;
                for ( let j = 0; j < protein.length; j ++ ) { // 0-based coordinates
                    dataset.consensus_sequence_virus.dict_accumulated_coord_to_individual_coord[ accumulated_start + j ] = j;
                    dataset.consensus_sequence_virus.dict_accumulated_coord_to_acc_rep[ accumulated_start + j ] = i;
                }
            }
            dataset.consensus_sequence_virus.data = [ { type: 'scattergl', mode: "text", x: dataset.consensus_sequence_virus.l_x, y: ArrayFull( dataset.consensus_sequence_virus.accumulated_length, - 0.75 ), text: dataset.consensus_sequence_virus.seq_consensus_concatenated.split( "" ), textfont: { size: 15 }, hoverinfo: "x", hovertemplate: "<br><extra></extra>", showlegend: false, name: "concatanated_consensus_protein_sequence" } ]; // display only x position of residues // no hover info
        }
        layout_MolecularMimicryMap.xaxis.rangeslider.range = [ 0, dataset.consensus_sequence_virus.accumulated_length ]; // update layout of MolecularMimicryMap
        // retrieve traces of virus protein annotations
        if ( ! ( 'annotation_representative_virus_protein' in dataset ) ) { 
            dataset.annotation_representative_virus_protein = { data: [ ] };
            dataset.annotation_representative_virus_protein.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of SARS-CoV-2 proteins
            for ( let i = 0; i < dataset.arr_data_acc_virus_representative.length; i ++ ) {
                let protein = dataset.arr_data_acc_virus_representative[ i ], pos_y = ( i % 2 - 1 ) / 4 - 0.15;
                dataset.annotation_representative_virus_protein.data.push( { x: [ protein.accumulated_start_skipping_orf1a__for_web_application, protein.accumulated_start_skipping_orf1a__for_web_application + protein.length - 1 ], y: [ pos_y, pos_y ], name: protein.name + "_Anno_Base", mode: "lines", type: "scatter", opacity: 1, showlegend: false, line: { width: 10, color: "#a3a3a3" }, visible: dataset.annotation_representative_virus_protein.show } ); // 1-based coordinate
            }
        }
        // retrieve traces of virus protein domain annotations
        if ( ! ( 'interpro_virus' in dataset ) ) { 
            dataset.interpro_virus = { };
            dataset.interpro_virus.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of SARS-CoV-2 proteins
            dataset.interpro_virus.arr_data = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "interpro_virus.tsv.gz.base64.txt" ];
            dataset.interpro_virus.dict_data = Unpack_array_to_dict_data( dataset.interpro_virus.arr_data ); // interpro annotation of virus proteins
            dataset.interpro_virus.dict_data[ "protein_name" ] = ArrayApply( dataset.interpro_virus.dict_data[ "accession_representative" ], function( acc_rep ) { return dataset.arr_data_acc_virus_representative[ acc_rep ].name; } );
            dataset.interpro_virus.data = [ ];
            dataset.interpro_virus.dict_color = { P: "#1f1994", G: "#08750a", S: "#781387", c: "#798514" };
            for ( let i = 0; i < dataset.interpro_virus.arr_data.length; i ++ ) {
                let step = 10;
                let domain = dataset.interpro_virus.arr_data[ i ], protein = dataset.arr_data_acc_virus_representative[ domain.accession_representative ], pos_y = ( domain.accession_representative % 2 - 1 ) / 4 - 0.15, str_len_protein = String( protein.length ), str_domain_start = String( domain.start ), str_domain_end = String( domain.end ), customdata = [ protein.name, str_len_protein, domain.interpro_name, domain.interpro_acc, domain.annotation_acc, str_domain_start, str_domain_end ], len_domain = domain.end_accumulated - domain.start_accumulated, trace = { name: domain.interpro_name + "__InterPro", mode: "lines", type: "scatter", opacity: 0.2, showlegend: false, line: { width: 15, color: dataset.interpro_virus.dict_color[ domain.annotation_acc.slice( 0, 1 ) ] }, visible: dataset.interpro_virus.show, hovertemplate: "InterPro Domain: <b>%{customdata[2]}</b> (%{customdata[3]})<br>Protein: <b>%{customdata[0]}</b> (from %{customdata[5]} to %{customdata[6]})<br>Database accession: %{customdata[4]}<br><extra></extra>", customdata: [ ], x: [ ], y: [ ] };
                for ( let j = 0; j <= len_domain / step + 1; j ++ ) { // for each domain, plot point every 10 residues for displaying information through hover
                    trace.customdata.push( customdata );
                    trace.y.push( pos_y );
                    let x = domain.start_accumulated + j * step;
                    trace.x.push( x > domain.end_accumulated ? domain.end_accumulated : x )
                }
                dataset.interpro_virus.data.push( trace );
            }
        }
        console.log( "[ParseData_AlignmentToVirus] dataset initialized for " + name_dataset + " visualized with 'AlignmentToVirus' mode" );
    }
    function ParseData_AlignmentToHuman( name_dataset ) {
        if ( object_data.flag.human_label_represents_virus ) { // when virus proteins are not used, AlignmentToHuman option is not available
            return -1
        }
        // parse dataset for visualization with AlignmentToHuman alignment mode
        let dir_folder = object_data.file.base_url + "data/base64/" + name_dataset + "/", // retrieve directory of the current folder of the current dataset
            dataset = object_data.main.dataset[ name_dataset ];
        console.log( "[ParseData_AlignmentToHuman] dataset initialization started for " + name_dataset + " visualized with 'AlignmentToHuman' mode" );
        
        // modify HTML elements
        $( "#navbar_vaccine_design" ).collapse( 'hide' ); // hide vaccine design panel
        $( "#btn_for_opening_navbar_vaccine_design" ).prop( "disabled", true ); // disable vaccine design panel toggle button
        $( "#plotly_graph_human_protein" ).collapse( 'hide' ); // hide vaccine design panel
        $( "#btn_toggle_human_protein_metrics" ).prop( "disabled", true ); // disable human metrics plot
        $( "#button_update_human_protein_metrics_plot" ).prop( "disabled", true ); 
        $( "#toggle_vaccine_metrics_MolecularMimicryMap" ).prop( "disabled", true ); 
        $( "#toggle_vaccine_design_MolecularMimicryMap" ).prop( "disabled", true ); 
        
        dataset.arr_data_iedb_epitope_human = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "iedb_epitope_human.tsv.gz.base64.txt" ];
        
        // initialize dataset specific for alignment to human reference proteome
        if ( ! ( 'iedb_epitope_human' in dataset ) ) { 
            dataset.iedb_epitope_human = { };
            dataset.iedb_epitope_human.dict_data_all = Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "iedb_epitope_human.tsv.gz.base64.txt" ] );
            dataset.iedb_epitope_human.dict_data_all[ "humen_gene_symbol" ] = ArrayApply( dataset.iedb_epitope_human.dict_data_all[ "accession_human" ], function( i ) { return dataset.acc_human.dict_data_all[ "Gene_Symbol" ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of human proteins // used for indexing (use upper case to make search case-insensitive)
            dataset.iedb_epitope_human.dictionary_human_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( dataset.iedb_epitope_human.dict_data_all[ "humen_gene_symbol" ] ); // index with human_gene_symbol
        }
        if ( ! ( 'interpro_human' in dataset ) ) { 
            dataset.interpro_human = { };
            dataset.interpro_human.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of protein annotations
            dataset.interpro_human.arr_data_all = object_data.file.dict_dir_file_to_parsed_data[ dir_folder + "interpro_human.tsv.gz.base64.txt" ];
            dataset.interpro_human.dict_data_all = Unpack_array_to_dict_data( dataset.interpro_human.arr_data_all ); // interpro annotation of human proteins
            dataset.interpro_human.dict_data_all[ "humen_gene_symbol" ] = ArrayApply( dataset.interpro_human.dict_data_all[ "accession_human" ], function( i ) { return dataset.acc_human.dict_data_all[ "Gene_Symbol" ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of human proteins // used for indexing (use upper case to make search case-insensitive)
            dataset.interpro_human.dictionary_human_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( dataset.interpro_human.dict_data_all[ "humen_gene_symbol" ] ); // index with human_gene_symbol
        }
        console.log( "[ParseData_AlignmentToHuman] dataset initialized for " + name_dataset + " visualized with 'AlignmentToVirus' mode" );
    }
    async function ParseData( ) { // parse loaded data and prepare for plotting molecular mimicry map plots
        let l_name_dataset = object_data.main.l_name_dataset;
        
        for ( let i = 0; i < l_name_dataset.length; i ++ ) {
            let name_dataset = l_name_dataset[ i ];
            console.log( "[ParseData] parsing dataset for " + name_dataset );

            if ( ! ( name_dataset in object_data.main.dataset ) ) { // initialize data dictionary of a dataset
                object_data.main.dataset[ name_dataset ] = { flag: { vaccine_design_optivax_loaded: false }, 
                                                            dir_folder: `${object_data.file.base_url}data/base64/${name_dataset}/`,
                                                            object_plot_BCellCrossReactivity : { },
                                                            object_plot_TCellCrossReactivity : { }
                                                           };
            }
            let dir_folder = object_data.file.base_url + "data/base64/" + name_dataset + "/", // retrieve directory of the current folder of the current dataset
                dataset = object_data.main.dataset[ name_dataset ];
            
            ParseData_DatasetCore( name_dataset ); // parse core data
            
            if ( object_data.flag.alignment_to_virus ) {
                ParseData_AlignmentToVirus( name_dataset );
            } else {
                ParseData_AlignmentToHuman( name_dataset );
            }
        }
        
        return new Promise( async function( resolve, reject ) { 
            await DrawMolecularMimicryMap( );
            Display_DataTable( );
            console.log( "[ParseData] resolved" );
            Loading_Screen( false );
            resolve( "[ParseData] resolved" );
        });
    }
    
//     var object_datatable_acc_human = [ ], df_datatable = null; // objects containing 2D-array for drawing datatable
//     function Display_DataTable( ) { // load datatable with loaded datasets
//         let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset to display data
//         let name_data = document.getElementById( "select_datatable" ).value, columns = [ ], dataSet = [ ], df = null, l_col = [ ];
//         console.log( "Loading datatable", name_data );
//         if ( name_data == "acc_human.tsv" ) { // retrieve appropriate dataframe for each setting
//             if( object_data.flag.human_label_represents_virus ) { // do not show datatable of acc_human when human label represent virus proteins
//                 return - 1
//             }
//             df = new DataFrame( dataset.arr_data_acc_human );
//             df = df.select( "Gene_Symbol", "value", "n_counts", "seq_length", "description", "IEDB___n_unique_epitopes", "AAgAtlas___n_PubMed_ID" );
//         } else if ( name_data == "acc_virus_representative.tsv" ) {
//             df = new DataFrame( dataset.arr_data_acc_virus_representative );
//             df = df.select( "name", "accession", "uniprot_acc", "length", "n_non_redundant_proteins" );
//         } else if ( name_data == "mhc_allele.tsv" ) {
//             df = new DataFrame( dataset.arr_data_mhc_allele );
//         } else if ( name_data == "interpro_virus.tsv" ) {
//             df = new DataFrame( dataset.interpro_virus.dict_data );
//             df = df.select( "protein_name", "start", "end", "interpro_acc", "interpro_name", "annotation_acc" );
//         } else if ( name_data == "iedb_epitope_virus.tsv" ) {
// //             if ( object_data.flag.alignment_to_virus ) {
// //                 df = new DataFrame( dataset.iedb_epitope_virus.dict_data );
// //                 df = df.select( "accession_iedb", "iedb_epitope_sequence", "number_of_positive_B_cell_assay", "number_of_positive_T_cell_assay", "protein_name", "start", "end", "percent_identity", "mismatch", "gapopen" );
// //             }
//         } 
//         df_datatable = df;
//         dataSet = df_datatable.toArray( ), l_col = df_datatable.listColumns( );
//         for ( let i = 0; i < l_col.length; i ++ ) { columns.push( { title: l_col[ i ] } ); }

//         $( '#container_datatable_MolecularMimicryMap' ).empty( ); // empty the datatable and redraw the datatable
//         $( '#container_datatable_MolecularMimicryMap' ).append( '<table id="datatable_MolecularMimicryMap" class="display" width="100%"></table>' );
//         $( '#datatable_MolecularMimicryMap' ).DataTable( { data: dataSet, columns: columns } ); // display the datatable
//     }

    
    var object_datatable_acc_query = [ ], df_datatable = null; // objects containing 2D-array for drawing datatable
    function Display_DataTable( ) { // load datatable with loaded datasets
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset to display data
        let name_data_table = document.getElementById( "select_datatable" ).value, data, l_col_selected, columns = [ ], dataSet = [ ], df = null, l_col = [ ];
        console.log( "[Display_DataTable] Loading datatable: ", name_data_table );

        switch( name_data_table ) {
              case "B-cell cross-reactivity prediction":
                data = dataset.object_plot_BCellCrossReactivity.dict_data;
                l_col_selected = [ "window_size", "human_accession", "query_start", "query_end", "name_structure_query", "virus_accession", "target_start", "target_end", "name_structure_target", "e_value", "identity", "score_blosum", "score_similarity_ss8", "correl_coeffi_acc", "correl_p_value_acc", "correl_coeffi_phi", "score_blosum_weighted", "sum_of_weights", "avg_score_blosum_weighted" ];
                break;
              case "T-cell cross-reactivity prediction":
                data = dataset.object_plot_TCellCrossReactivity.dict_data;
                l_col_selected = [ "name_mhc_allele", "mhc_class", "window_size", "score_blosum", "avg_score", "human_accession", "query_start", "query_end", "query_subsequence", "score_geometric_mean_query", "virus_accession", "target_start", "target_end", "target_subsequence", "score_geometric_mean_target" ];
                break;
              case "human proteins":
                data = dataset.acc_human.dict_data_all;
                l_col_selected = [ "value", "n_counts" ];
                break;
              case "MHC alleles":
                data = dataset.arr_data_mhc_allele;
                l_col_selected = [ 'value' ];
                break;
              default:
                data = [ ];
        }
        df = new DataFrame( data );
        df_datatable = df; // set global variable pointing to current data_table
        df = df.select( ... l_col_selected ); // select appropriate columns before visualization
        
        dataSet = df.toArray( ), l_col = df.listColumns( );
        for ( let i = 0; i < l_col.length; i ++ ) { columns.push( { title: l_col[ i ] } ); } // set columns for DataTable.js
        $( '#container_datatable_MolecularMimicryMap' ).empty( ); // empty the datatable and redraw the datatable
        $( '#container_datatable_MolecularMimicryMap' ).append( '<table id="datatable_MolecularMimicryMap" class="display" width="100%"></table>' );
        $( '#datatable_MolecularMimicryMap' ).DataTable( { data: dataSet, columns: columns } ); // display the datatable
    }
    var string_csv_datatable = "";
    function Download_DataTable( ) { // download analysis result of vaccine candidate as a csv file
        if ( df_datatable != null ) {
            string_csv_datatable = df_datatable.toCSV( true );
        }
        let blob = new Blob( [ string_csv_datatable ], { type: "text/plain;charset=utf-8" } );
        let name_file = document.getElementById( "select_datatable" ).value // retrieve the name of the current data
        name_file = name_file.slice( 0, name_file.lastIndexOf( '.' ) ) + '_MolecularMimicryMap_of_SARS-CoV-2_datatable.csv' // change the extension of the filename
        saveAs( blob, name_file ); // save file 
    }
    
    
    var l_a = [ ];
    var l_b = [ ], l_xy = [ ];
    // settings for Plotly plots
    var float_line_type_opacity_MolecularMimicryMap_BCellCrossReactivity = 0.5, float_opacity_MolecularMimicryMap_TCellCrossReactivity = 0.5;
    // plot Plotly plots
    var dict_name_plot_to_trace_index__MolecularMimicryMap = { }; // dictionary mapping name of plot to trace index
    var object_plot_BCellCrossReactivity = { }, object_plot_TCellCrossReactivity = { };
    var arr_data_BCellCrossReactivity = [ ], arr_data_TCellCrossReactivity = [ ]; // lists containing data of currently plotted B/TCellCrossReactivity records
    var trace_point_type_MolecularMimicryMap_BCellCrossReactivity = { mode: 'markers', marker: { line: { } }, showlegend: false }, data_line_type_MolecularMimicryMap_BCellCrossReactivity = [ ], trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human = { mode: 'markers', marker: { line: { } }, showlegend: false }, trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus = { mode: 'markers', marker: { line: { } }, showlegend: false }, trace_BCellCrossReactivityMetrics = { type: 'parcoords', line: { color: "#aa00ff" }, dimensions: [ ] }, trace_TCellCrossReactivityMetrics = { type: 'parcoords', line: { color: '#aa00ff' }, dimensions: [ ] };
    // graph setting from graph setting panel
    var plotly_type_BCellCrossReactivity = 'scattergl', plotly_type_TCellCrossReactivity = 'scattergl', int_index_representation_TCellCrossReactivity = 1, int_index_MHC_class_TCellCrossReactivity = 3; 
    // variables for interactions
    var clicked_record = { }, clicked_record_parsed = { }, arr_data_clicked = [ ], trace_tableSequence = { };
    // general Plotly settings
    var config = { responsive: true, displaylogo: false, toImageButtonOptions: { hoverClosestCartesian: true, format: 'svg', filename: 'MolecularMimicryMap_of_SARS-CoV-2', height: 750, width: 1100, scale: 1 }, modeBarButtonsToRemove: [ 'autoScale2d', 'toggleSpikelines', 'hoverCompareCartesian', 'hoverClosestCartesian' ] } // flexible plot width according to the window size  // do not display plotly logo
    let config_MolecularMimicryMap = Object.assign( { toImageButtonOptions: { hoverClosestCartesian: true, format: 'svg', filename: 'MolecularMimicryMap_of_SARS-CoV-2', height: 750, width: 1100, scale: 1 }, modeBarButtonsToRemove: [ 'autoScale2d', 'toggleSpikelines', 'hoverCompareCartesian', 'hoverClosestCartesian' ] }, config ), layout_MolecularMimicryMap = { margin: { l: 60, r: 15, b: 10, t: 0, pad: 4 }, xaxis: { rangeslider: { borderwidth : 1, thickness : 0.07 }, zeroline: false }, yaxis: { fixedrange: true, zeroline: false, tickmode: "array", tickvals: [ 0, 2, 4, 6, 8, 10 ], ticktext: ArrayApply( [ 0, 2, 4, 6, 8, 10 ], String ) }, hovermode: "closest", hoverlabel: { bgcolor: "#ffffff", bordercolor: "#521a87" }, legend: { itemclick: false, itemdoubleclick: false } }; // title: 'Molecular Mimicry Map of SARS-CoV-2', // disable toggling of traces when clickng legends // do hot show y-tickes below 0
    let layout_PredictionMetrics = { margin: { l: 50, r: 65, b: 50, t: 50, pad: 4 } }, layout_tableSequence = { margin: { l: 50, r: 65, b: 5, t: 5, pad: 4 } };
    // for visualizing protein structures
    var object_pdb_human = { }, object_pdb_virus = { }, object_data_tableSequence = { };
    var option_initialization_molstar = { customData: { url: object_data.file.base_url + "data/custom_cif/dummy.cif", format: 'cif', binary: false }, landscape: true, bgColor: {r:0,g:0,b:0}, hideControls: true }; // default option for Mol* when not displaying molecules
    var l_selectSections_PDB_Virus_Protein = [ ], flag_select_PDB_Virus_Protein = true, flag_focus_PDB_Virus_Protein = false, l_selectSections_PDB_Human_Protein = [ ], flag_select_PDB_Human_Protein = true, flag_focus_PDB_Human_Protein = false; // flags for interaction with Mol* viewer
    // for highlighting specific entries
    // object for saving layout data
    var object_plot_MolecularMimicryMap = { hovermode: "closest", layout: { } };
    // for loading data from remote location
    // "Record Details" table styles settings
    var style_font_table_record_details = "font-family:Arial", int_n_residues_per_window_table_sequence = 20; // 'int_n_residues_per_window_table_sequence' number of residues per sequence in the table_sequence plot
    var object_plot_HumanProteins = { }, trace_HumanProteinMetrics = { type: 'parcoords', line: { color: "#aa00ff" }, dimensions: [ ] };
    function DrawHumanProteinMetricsPlot( ) {
        // assume there is only one dataset
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ];
        // prepare data
        object_plot_HumanProteins.n_records = dataset.arr_data_acc_human.length;
        object_plot_HumanProteins.dictarr = SubsetDictDictArr( dataset.gtex.dictdictarr, "Q2" )
        object_plot_HumanProteins.dictarr_log10 = { };
        for ( let col in object_plot_HumanProteins.dictarr ) { // log10 transformation of median count values
            object_plot_HumanProteins.dictarr_log10[ col + ' (log10)' ] = nj.log( object_plot_HumanProteins.dictarr[ col ] ).divide( 2.3025851 ).tolist( )
        }
        object_plot_HumanProteins.dictarr = { ... object_plot_HumanProteins.dictarr_log10, ... Unpack_array_to_dict_data( dataset.arr_data_acc_human ) }
            // prepare data based on selected options
        let l_option = document.getElementById( "selectmultiple_HumanProteinMetrics" ).options, l_col = [ ], l_label = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) {
            let option = l_option[ i ];
            if ( option.selected ) { l_col.push( option.value ); l_label.push( option.text ); } // retrieve column name and label for each selected column
        }
        trace_HumanProteinMetrics.dimensions = [ ]; // initialize metrics data
        trace_HumanProteinMetrics.line = { color: dataset.l_float_for_colormap_rainbow_acc_human, colorscale : "Rainbow", cmin : 0, cmax : 1, cmid : 0.5, colorscale : [ [ 0, '#ff0000' ], [ 0.33, '#00ff00' ], [ 0.66, '#0000ff' ], [ 1, '#ff0000' ] ] }
        for ( let i = 0; i < l_col.length; i ++ ) {
            let col = l_col[ i ], label = l_label[ i ];
            trace_HumanProteinMetrics.dimensions.push( { values: object_plot_HumanProteins.dictarr[ col ], label: label } );
        }
        Plotly.newPlot( plotHumanProteinMetrics, [ lodash.cloneDeep( trace_HumanProteinMetrics ) ], { margin: { l: 70, r: 65, b: 50, t: 50, pad: 4 } }, config );
        // Add Plotly interactions // Selection event through a plot containing metrics (parallel coordinate plots) (BCellCrossReactivity prediction data)
        object_plot_HumanProteins.l_mask = [ ]; // initialize list of masks
        for ( let i = 0; i < trace_HumanProteinMetrics.dimensions.length; i ++ ) { object_plot_HumanProteins.l_mask.push( ArrayFull( object_plot_HumanProteins.n_records, true ) ); } // initialize masks used for retrieving selected entries
        object_plot_BCellCrossReactivity.mask_selected_HumanProteinFilter = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true );
        object_plot_TCellCrossReactivity.mask_selected_HumanProteinFilter = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true );
        plotHumanProteinMetrics.on( 'plotly_restyle', function( eventData ) { // update trace_MolecularMimicryMap_BCellCrossReactivity and trace_MolecularMimicryMap_TCellCrossReactivity based on selection in trace_BCellCrossReactivityMetrics
            let str_name_key = Object.keys( eventData[ 0 ] )[ 0 ];
            if ( str_name_key.includes( "constraintrange" ) ) { // when entries are selected or deselected (ignore event where fields are rearranged and no selection or deselection occurred)
                let index_field = parseInt( str_name_key.split( "].constraintrange" )[ 0 ].split( "dimensions[" )[ 1 ] ); // extract the index of field from the name of the key 
                let l_selectedRange = eventData[ 0 ][ str_name_key ];
                if ( l_selectedRange == null ) { // if all range of the current field is selected
                    object_plot_HumanProteins.l_mask[ index_field ] = ArrayFull( object_plot_HumanProteins.n_records, true ); // reset selection
                } else {
                    let l_mask_for_each_selectedRange = [ ]; // overlap mask for each selected ranges
                    for ( let i = 0; i < l_selectedRange.length; i++ ) { // for each selectedRange
                        let selectedRange = l_selectedRange[ i ].sort( SortFloat );
                        let l_data = trace_HumanProteinMetrics.dimensions[ index_field ].values;
                        l_mask_for_each_selectedRange.push( ArrayBoolAND( [ ArrayGreaterThan( l_data, selectedRange[ 0 ] ), ArrayLessThan( l_data, selectedRange[ 1 ] ) ] ) );
                    }
                    object_plot_HumanProteins.l_mask[ index_field ] = ArrayBoolOR( l_mask_for_each_selectedRange ); // update mask with the currently selected range
                }
                object_plot_HumanProteins.mask_selected = ArrayBoolAND( object_plot_HumanProteins.l_mask ); // retrieve a mask for the selected records
                // update masks for Bcell and Tcell cross-reactivity records
                object_plot_BCellCrossReactivity.mask_selected_HumanProteinFilter = [ ]
                let l_acc_human = dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ];
                for ( let i = 0; i < l_acc_human.length; i ++ ) {
                    object_plot_BCellCrossReactivity.mask_selected_HumanProteinFilter.push( object_plot_HumanProteins.mask_selected[ l_acc_human[ i ] ] );
                }
                object_plot_TCellCrossReactivity.mask_selected_HumanProteinFilter = [ ]
                for ( let i = 0; i < l_acc_human.length; i ++ ) {
                    object_plot_TCellCrossReactivity.mask_selected_HumanProteinFilter.push( object_plot_HumanProteins.mask_selected[ l_acc_human[ i ] ] );
                }
                Filter_BCellCrossReactivity( ); // apply the filter
                Filter_TCellCrossReactivity( );
            }
        });
    }
    async function LoadRemoteData_BasedOnSettings( ) { // load dataset based on setting
        let l_name_dataset = object_data.main.l_name_dataset,
            l_dir_file = [ ];
        for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
            let name_dataset = l_name_dataset[ index_dataset ]; // name_dataset 
            let dataset = object_data.main.dataset[ name_dataset ], // retrieve dataset
                float_thres_margin = 1.5; // a threshold for skipping writing a file if the number of records for subset is too close to the maximum number
            
            // retrieve file names appropriate for current setting
            dataset.object_plot_BCellCrossReactivity.n_records_from_setting = parseInt( document.getElementById( "input_n_alignments_for_plotting_BCellCrossReactivity" ).value );
            dataset.object_plot_BCellCrossReactivity.window_size = document.getElementById( "select_windowSize_BCellCrossReactivity" ).value;
            dataset.object_plot_BCellCrossReactivity.redundancy_level = document.getElementById( "select_redundancy_level_BCellCrossReactivity" ).value;
            dataset.object_plot_BCellCrossReactivity.n_records_max = object_data.file.dict_name_dataset_to_dict_bcell_crossreactivity_data_to_n_records[ name_dataset ][ dataset.object_plot_BCellCrossReactivity.redundancy_level ][ dataset.object_plot_BCellCrossReactivity.window_size ];
            dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file = 1000; // default is the smallest n_records
            if ( dataset.object_plot_BCellCrossReactivity.n_records_from_setting * float_thres_margin >= dataset.object_plot_BCellCrossReactivity.n_records_max ) {
                dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file = dataset.object_plot_BCellCrossReactivity.n_records_max;
            } else {
                for ( let i = 1; i < object_data.file.l_n_records_for_each_step.length; i ++ ) {
                    if ( dataset.object_plot_BCellCrossReactivity.n_records_from_setting < object_data.file.l_n_records_for_each_step[ i ] ) { break; }
                    dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file = object_data.file.l_n_records_for_each_step[ i ];
                }
            }
            dataset.object_plot_BCellCrossReactivity.dir_file = dataset.dir_folder + "BCellCrossReactivity." + dataset.object_plot_BCellCrossReactivity.redundancy_level + ".windowSize_" + dataset.object_plot_BCellCrossReactivity.window_size + ".top_" + String( dataset.object_plot_BCellCrossReactivity.n_records_of_remote_file ) + ".tsv.gz.base64.txt";
            l_dir_file.push( dataset.object_plot_BCellCrossReactivity.dir_file );
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
                dataset.object_plot_TCellCrossReactivity.n_records_from_setting = parseInt( document.getElementById( "input_n_alignments_for_plotting_TCellCrossReactivity" ).value );
                dataset.object_plot_TCellCrossReactivity.redundancy_level = document.getElementById( "select_redundancy_level_TCellCrossReactivity" ).value;
                dataset.object_plot_TCellCrossReactivity.n_records_max = object_data.file.dict_name_dataset_to_dict_tcell_crossreactivity_data_to_n_records[ name_dataset ][ dataset.object_plot_TCellCrossReactivity.redundancy_level ];
                dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file = 1000; // default is the smallest n_records
                if ( dataset.object_plot_TCellCrossReactivity.n_records_from_setting * float_thres_margin >= dataset.object_plot_TCellCrossReactivity.n_records_max ) {
                    dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file = dataset.object_plot_TCellCrossReactivity.n_records_max;
                } else {
                    for ( let i = 1; i < object_data.file.l_n_records_for_each_step.length; i ++ ) {
                        if ( dataset.object_plot_TCellCrossReactivity.n_records_from_setting < object_data.file.l_n_records_for_each_step[ i ] ) { break; }
                        dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file = object_data.file.l_n_records_for_each_step[ i ];
                    }
                }
                dataset.object_plot_TCellCrossReactivity.dir_file = dataset.dir_folder + "TCellCrossReactivity." + dataset.object_plot_TCellCrossReactivity.redundancy_level + ".top_" + String( dataset.object_plot_TCellCrossReactivity.n_records_of_remote_file ) + ".tsv.gz.base64.txt";
                l_dir_file.push( dataset.object_plot_TCellCrossReactivity.dir_file ); 
            }
            gtag( 'event', 'loading_remote_data', { name_dataset: name_dataset, t_cell_n_records : ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? dataset.object_plot_TCellCrossReactivity.n_records_from_setting : 0, b_cell_n_records : dataset.object_plot_BCellCrossReactivity.n_records_from_setting, b_cell_window_size : dataset.object_plot_BCellCrossReactivity.window_size, t_cell_redundancy_level : dataset.object_plot_BCellCrossReactivity.redundancy_level, t_cell_redundancy_level : ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? dataset.object_plot_TCellCrossReactivity.redundancy_level : "nan" } ); // [Google Analytics] record which remote data is being downloaded to improve statistics
        }
        return LoadRemoteData( l_dir_file ); // load given list of files from remote locations
    }
    function Open_and_Draw_BCellCrossReactivityPredMetricsPlot( ) {
        str_jquery_container = "#plotly_graph_b_cell_cross_reactivity";
        if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { DrawBCellCrossReactivityPredMetricsPlot( ); // draw Plotly plot synchronously if the container is currently shown
        } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { DrawBCellCrossReactivityPredMetricsPlot( ); $('#plotly_graph_b_cell_cross_reactivity').collapse( 'hide' ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden
    }        
    function DrawBCellCrossReactivityPredMetricsPlot( ) {
        // reset selection
        let l_index_traces_selected = [ ], l_index_traces_not_selected = [ ];
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { // restyle plot according to the type of BcellCrossReactivity data
            for ( let i = object_plot_BCellCrossReactivity.index_trace_start; i < object_plot_BCellCrossReactivity.index_trace_end; i ++ ) { if ( plotMolecularMimicryMap.data[ i ].visible == false ) { l_index_traces_selected.push( i ); } } // if previously not selected and hidden, show the record
            if ( l_index_traces_selected.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: true }, l_index_traces_selected ); } // show all records
        } else {
            Plotly.restyle( plotMolecularMimicryMap, { marker: { opacity: object_plot_BCellCrossReactivity.dict_data[ "opacity" ], size: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.size, color: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.color, line: { width: 0 } }, error_x: { type: 'data', array: object_plot_BCellCrossReactivity.dict_data[ "error_x" ], visible: true, width: 0, thickness: 1 } }, object_plot_BCellCrossReactivity.index_trace_start ) // reset selection of BCellCrossReactivity records on the plot
        }
        // prepare data
        let l_option = document.getElementById( "selectmultiple_BCellCrossReactivityMetrics" ).options, l_col = [ ], l_label = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) {
            let option = l_option[ i ];
            if ( option.selected ) { l_col.push( option.value ); l_label.push( option.text ); } // retrieve column name and label for each selected column
        }
        trace_BCellCrossReactivityMetrics.dimensions = [ ]; // initialize metrics data
        for ( let i = 0; i < l_col.length; i ++ ) {
            let col = l_col[ i ], label = l_label[ i ];
            let l = col in object_plot_BCellCrossReactivity.metrics ? object_plot_BCellCrossReactivity.metrics[ col ] : object_plot_BCellCrossReactivity.dict_data[ col ];
            trace_BCellCrossReactivityMetrics.dimensions.push( { values: l, label: label } );
        }
        trace_BCellCrossReactivityMetrics.line = { color: object_plot_BCellCrossReactivity.dict_data[ 'float_color' ], cmin : 0, cmax : 1, cmid : 0.5, colorscale : [ [ 0, '#ff0000' ], [ 0.33, '#00ff00' ], [ 0.66, '#0000ff' ], [ 1, '#ff0000' ] ] }; // allow similar coloring of lines with the records in the main plots (pink colors are quite different, but other colors are similar)
        Plotly.newPlot( plotBCellCrossReactivityMetrics, [ lodash.cloneDeep( trace_BCellCrossReactivityMetrics ) ], layout_PredictionMetrics, config );
        // Add Plotly interactions // Selection event through a plot containing metrics (parallel coordinate plots) (BCellCrossReactivity prediction data)
        object_plot_BCellCrossReactivity.l_mask = [ ]; // initialize list of masks
        for ( let i = 0; i < trace_BCellCrossReactivityMetrics.dimensions.length; i ++ ) { object_plot_BCellCrossReactivity.l_mask.push( ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ) ); } // initialize masks used for retrieving selected entries
        object_plot_BCellCrossReactivity.mask_selected_BCellCrossReactivityFilter = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true );
        plotBCellCrossReactivityMetrics.on( 'plotly_restyle', function( eventData ) { // update trace_MolecularMimicryMap_BCellCrossReactivity based on selection in trace_BCellCrossReactivityMetrics
            let str_name_key = Object.keys( eventData[ 0 ] )[ 0 ];
            if ( str_name_key.includes( "constraintrange" ) ) { // when entries are selected or deselected (ignore event where fields are rearranged and no selection or deselection occurred)
                let index_field = parseInt( str_name_key.split( "].constraintrange" )[ 0 ].split( "dimensions[" )[ 1 ] ); // extract the index of field from the name of the key 
                let l_selectedRange = eventData[ 0 ][ str_name_key ];
                if ( l_selectedRange == null ) { // if all range of the current field is selected
                    object_plot_BCellCrossReactivity.l_mask[ index_field ] = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ); // reset selection
                } else {
                    let l_mask_for_each_selectedRange = [ ]; // overlap mask for each selected ranges
                    for ( let i = 0; i < l_selectedRange.length; i++ ) { // for each selectedRange
                        let selectedRange = l_selectedRange[ i ].sort( SortFloat );
                        let l_data = trace_BCellCrossReactivityMetrics.dimensions[ index_field ].values;
                        l_mask_for_each_selectedRange.push( ArrayBoolAND( [ ArrayGreaterThan( l_data, selectedRange[ 0 ] ), ArrayLessThan( l_data, selectedRange[ 1 ] ) ] ) );
                    }
                    object_plot_BCellCrossReactivity.l_mask[ index_field ] = ArrayBoolOR( l_mask_for_each_selectedRange ); // update mask with the currently selected range
                }
                object_plot_BCellCrossReactivity.mask_selected_BCellCrossReactivityFilter = ArrayBoolAND( object_plot_BCellCrossReactivity.l_mask ); // retrieve a mask for the selected records
                Filter_BCellCrossReactivity( ); // apply the filter
            }
        });
    }
    function Open_and_Draw_TCellCrossReactivityPredMetricsPlot( ) {
        str_jquery_container = "#plotly_graph_t_cell_cross_reactivity";
        if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { DrawTCellCrossReactivityPredMetricsPlot( ); // draw Plotly plot synchronously if the container is currently shown
        } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { DrawTCellCrossReactivityPredMetricsPlot( ); $('#plotly_graph_b_cell_cross_reactivity').collapse( 'hide' ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden
    }        
    function DrawTCellCrossReactivityPredMetricsPlot( ) {
        // reset selection
        let update_human = { marker: { opacity: float_opacity_MolecularMimicryMap_TCellCrossReactivity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.line.width } } }, update_virus = { marker: { opacity: float_opacity_MolecularMimicryMap_TCellCrossReactivity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.line.width } }, error_x: { type: 'data', array: object_plot_TCellCrossReactivity.dict_data[ "error_x" ], visible: true, width: 0, thickness: 1 } };
        Plotly.restyle( plotMolecularMimicryMap, update_human, object_plot_BCellCrossReactivity.index_trace_end ); // T-cell crossreactivity trace is situated next to B-cell cross-reactivity trace
        Plotly.restyle( plotMolecularMimicryMap, update_virus, object_plot_BCellCrossReactivity.index_trace_end + 1 );
        // prepare data
        let l_option = document.getElementById( "selectmultiple_TCellCrossReactivityMetrics" ).options, l_col = [ ], l_label = [ ];
        for ( let i = 0; i < l_option.length; i ++ ) {
            let option = l_option[ i ];
            if ( option.selected ) { l_col.push( option.value ); l_label.push( option.text ); } // retrieve column name and label for each selected column
        }
        trace_TCellCrossReactivityMetrics.dimensions = [ ]; // initialize metrics data
        for ( let i = 0; i < l_col.length; i ++ ) {
            let col = l_col[ i ], label = l_label[ i ];
            let l = ( col in object_plot_TCellCrossReactivity.metrics ) ? object_plot_TCellCrossReactivity.metrics[ col ] : object_plot_TCellCrossReactivity.dict_data[ col ];
            trace_TCellCrossReactivityMetrics.dimensions.push( { values: l, label: label } );
        }
        trace_TCellCrossReactivityMetrics.line = { color: object_plot_TCellCrossReactivity.dict_data[ "float_color" ], cmin : 0, cmax : 1, cmid : 0.5, colorscale : [ [ 0, '#ff0000' ], [ 0.33, '#00ff00' ], [ 0.66, '#0000ff' ], [ 1, '#ff0000' ] ] };
        Plotly.newPlot( plotTCellCrossReactivityMetrics, [ lodash.cloneDeep( trace_TCellCrossReactivityMetrics ) ], layout_PredictionMetrics, config ); 
        // Add Plotly interactions // Selection event through a plot containing metrics (parallel coordinate plots) (TCellCrossReactivity prediction data)
        object_plot_TCellCrossReactivity.l_mask = [ ]; // initialize list of masks
        for ( let i = 0; i < trace_TCellCrossReactivityMetrics.dimensions.length; i ++ ) { object_plot_TCellCrossReactivity.l_mask.push( ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ) ); } // initialize masks used for retrieving selected entries
        object_plot_TCellCrossReactivity.mask_selected_TCellCrossReactivityFilter = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true );
        plotTCellCrossReactivityMetrics.on( 'plotly_restyle', function( eventData ) { // update trace_MolecularMimicryMap_TCellCrossReactivity based on selection in trace_TCellCrossReactivityMetrics
            let str_name_key = Object.keys( eventData[ 0 ] )[ 0 ];
            if ( str_name_key.includes( "constraintrange" ) ) { // when entries are selected or deselected (ignore event where fields are rearranged and no selection or deselection occurred)
                let index_field = parseInt( str_name_key.split( "].constraintrange" )[ 0 ].split( "dimensions[" )[ 1 ] ); // extract the index of field from the name of the key 
                let l_selectedRange = eventData[ 0 ][ str_name_key ];
                if ( l_selectedRange == null ) { // if all range of the current field is selected
                    object_plot_TCellCrossReactivity.l_mask[ index_field ] = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ); // reset selection
                } else {
                    let l_mask_for_each_selectedRange = [ ]; // overlap mask for each selected ranges
                    for ( let i = 0; i < l_selectedRange.length; i++ ) { // for each selectedRange
                        let selectedRange = l_selectedRange[ i ].sort( SortFloat );
                        let l_data = trace_TCellCrossReactivityMetrics.dimensions[ index_field ].values;
                        l_mask_for_each_selectedRange.push( ArrayBoolAND( [ ArrayGreaterThan( l_data, selectedRange[ 0 ] ), ArrayLessThan( l_data, selectedRange[ 1 ] ) ] ) );
                    }
                    object_plot_TCellCrossReactivity.l_mask[ index_field ] = ArrayBoolOR( l_mask_for_each_selectedRange ); // update mask with the currently selected range
                }
                object_plot_TCellCrossReactivity.mask_selected_TCellCrossReactivityFilter = ArrayBoolAND( object_plot_TCellCrossReactivity.l_mask ); // retrieve a mask for the selected records
                Filter_TCellCrossReactivity( ); // apply the filter
            }
        });
    }
    function Filter_BCellCrossReactivity( ) { // filter BCellCrossReactivity records
        // collect all filters
        let l_filter = [ ];
        if ( 'mask_selected_BCellCrossReactivityFilter' in object_plot_BCellCrossReactivity ) { // if metric plot has been drawn, add metric-based filter to the list of filters
            l_filter.push( object_plot_BCellCrossReactivity.mask_selected_BCellCrossReactivityFilter );
        }
        if ( object_data.flag.alignment_to_virus & ( 'mask_selected_HumanProteinFilter' in object_plot_BCellCrossReactivity ) ) { // if HumanProteinMetrics plot has not been drawn and AlignmentToVirus mode is used (multiple protein visualized), use the HumanProtein filter
            l_filter.push( object_plot_BCellCrossReactivity.mask_selected_HumanProteinFilter );
        }
        if ( 'mask_selected_highlighting' in object_plot_BCellCrossReactivity ) { // if records were highlighted, add the filter for highlighting
            l_filter.push( object_plot_BCellCrossReactivity.mask_selected_highlighting );
        }
        object_plot_BCellCrossReactivity.mask_selected = ( l_filter.length == 0 ) ? ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ) : ArrayBoolAND( l_filter ); // apply all available filters. if no filter is available, display all records
        
        object_plot_BCellCrossReactivity.selection = { }; // object for storing data related to selected records
        let mask_not_selected = ArrayBoolNOT( object_plot_BCellCrossReactivity.mask_selected );
        object_plot_BCellCrossReactivity.selection.l_opacity = ArrayBroadCasting( object_plot_BCellCrossReactivity.dict_data[ "opacity" ], mask_not_selected, 0 ); // retrieve modified opacity values of records
        object_plot_BCellCrossReactivity.selection.l_error_x = ArrayBroadCasting( object_plot_BCellCrossReactivity.dict_data[ "error_x" ], mask_not_selected, 0 ); // retrieve modified error_x values of records
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { // restyle plot according to the type of BcellCrossReactivity data
            l_index_traces_selected = [ ], l_index_traces_not_selected = [ ]; // retrieve trace indices that are newly selected or deselected
            for ( let i = object_plot_BCellCrossReactivity.index_trace_start; i < object_plot_BCellCrossReactivity.index_trace_end; i ++ ) { 
                if ( object_plot_BCellCrossReactivity.mask_selected[ i ] && plotMolecularMimicryMap.data[ i ].visible == false ) { l_index_traces_selected.push( i ); } // if previously not selected but currently selected 
                else if ( ! ( object_plot_BCellCrossReactivity.mask_selected[ i ] ) && plotMolecularMimicryMap.data[ i ].visible == true ) { l_index_traces_not_selected.push( i ); } // if previously selected but currently not selected 
            }
            if ( l_index_traces_selected.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: true }, l_index_traces_selected ); } // show selected records
            if ( l_index_traces_not_selected.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: false }, l_index_traces_not_selected ); } // hide non-selected records
        } else {
            Plotly.restyle( plotMolecularMimicryMap, { marker: { opacity: object_plot_BCellCrossReactivity.selection.l_opacity, size: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.size, color: trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.color, line: { width: 0 } }, error_x: { type: 'data', array: object_plot_BCellCrossReactivity.selection.l_error_x, visible: true, width: 0, thickness: 1 } }, object_plot_BCellCrossReactivity.index_trace_start ) // set opacity of markers not selected in the metric plot 0
        }
    }
    function Filter_TCellCrossReactivity( ) { // filter TCellCrossReactivity records
        if ( ( ! object_data.flag.cross_reactive_mhc_ligand_data_exist ) ) { // exit when mhc_ligand data does not exist
            return -1;
        }
        // collect all filters
        let l_filter = [ ];
        if ( 'mask_selected_TCellCrossReactivityFilter' in object_plot_TCellCrossReactivity ) { // if metric plot has been drawn, add metric-based filter to the list of filters
            l_filter.push( object_plot_TCellCrossReactivity.mask_selected_TCellCrossReactivityFilter );
        }
        if ( object_data.flag.alignment_to_virus & ( 'mask_selected_HumanProteinFilter' in object_plot_TCellCrossReactivity ) ) { // if HumanProteinMetrics plot has not been drawn and AlignmentToVirus mode is used (multiple protein visualized), use the HumanProtein filter
            l_filter.push( object_plot_TCellCrossReactivity.mask_selected_HumanProteinFilter );
        }
        if ( 'mask_selected_highlighting' in object_plot_TCellCrossReactivity ) { // if records were highlighted, add the filter for highlighting
            l_filter.push( object_plot_TCellCrossReactivity.mask_selected_highlighting );
        }
        object_plot_TCellCrossReactivity.mask_selected = ( l_filter.length == 0 ) ? ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ) : ArrayBoolAND( l_filter ); // apply all available filters. if no filter is available, display all records
        
        object_plot_TCellCrossReactivity.selection = { l_opacity: [ ] };
        for ( let i = 0; i < object_plot_TCellCrossReactivity.mask_selected.length; i ++ ) { object_plot_TCellCrossReactivity.selection.l_opacity.push( object_plot_TCellCrossReactivity.mask_selected[ i ] ? float_opacity_MolecularMimicryMap_TCellCrossReactivity : 0 ); } // retrieve modified opacity values of records
        object_plot_TCellCrossReactivity.selection.l_error_x = ArrayBroadCasting( object_plot_TCellCrossReactivity.dict_data[ "error_x" ], ArrayBoolNOT( object_plot_TCellCrossReactivity.mask_selected ), 0 ); // retrieve modified error_x values of records
        update_human = { marker: { opacity: object_plot_TCellCrossReactivity.selection.l_opacity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.line.width } } }, update_virus = { marker: { opacity: object_plot_TCellCrossReactivity.selection.l_opacity, size: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.size, color: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.color, symbol: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.symbol, line: { width: trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.line.width } }, error_x: { type: 'data', array: object_plot_TCellCrossReactivity.selection.l_error_x, visible: true, width: 0, thickness: 1 } };
        Plotly.restyle( plotMolecularMimicryMap, update_human, object_plot_BCellCrossReactivity.index_trace_end ); // T-cell crossreactivity trace is situated next to B-cell cross-reactivity trace
        Plotly.restyle( plotMolecularMimicryMap, update_virus, object_plot_BCellCrossReactivity.index_trace_end + 1 );
    }
    function UpdateBCellCrossReactivityPredMetricsPlot( ) {
        if( $( "#plotly_graph_b_cell_cross_reactivity" ).hasClass( "show" ) ) {
            DrawBCellCrossReactivityPredMetricsPlot( );
            object_data.flag.bcellmetrics_plot_is_drawn = true;
        } else {
            object_data.flag.bcellmetrics_plot_is_drawn = false;
        }
    }
    function UpdateTCellCrossReactivityPredMetricsPlot( ) {
        if( $( "#plotly_graph_t_cell_cross_reactivity" ).hasClass( "show" ) ) {
            DrawTCellCrossReactivityPredMetricsPlot( );
            object_data.flag.tcellmetrics_plot_is_drawn = true;
        } else {
            object_data.flag.tcellmetrics_plot_is_drawn = false;
        }
    }
    function UpdateHumanProteinMetricsPlot( ) {
        if( $( "#plotly_graph_human_protein" ).hasClass( "show" ) ) {
            DrawHumanProteinMetricsPlot( );
            object_data.flag.humanproteinmetrics_plot_is_drawn = true;
        } else {
            object_data.flag.humanproteinmetrics_plot_is_drawn = false;
        }
    }
    function Record_Details_Table( bool_create_table_div ) { // function to create and remove "record datails" table
        if ( ( ! bool_create_table_div ) && document.getElementById( "table_record_details" ) != null ) { // remove div for "record datails" table
            document.getElementById( "table_record_details" ).remove( ); // remove loading screen once plot is drawn
            document.getElementById( "container_graph_molecular_mimicry_map" ).removeAttribute( "style" );
            window.dispatchEvent( new Event( 'resize' ) ); // trigger resize events to allow Plotly plot to resize its plot
        } else if ( document.getElementById( "table_record_details" ) == null ) { // create div for "record datails" table
            $("#container_d3_table_metrics").append( [
                '<div id="table_record_details">',
                    '<div class="navbar navbar-dark bg-custom-navbar">',
                        '<a class="navbar-brand my-0 h6" id="title_d3_table_metrics">Record Details</a>',
                        '<button type="button" class="close" aria-label="Close container_d3_table_metrics" onclick="Record_Details_Table( false )"><span aria-hidden="true">&times;</span></button>',
                    '</div>',
                    '<div id="d3_table_metrics"></div>',
                    '<div id="footnote_d3_table_metrics" class="text-muted"></div>',
                '</div>' ].join( "" ) ); // display an SVG file during loading 
            document.getElementById( "container_graph_molecular_mimicry_map" ).setAttribute( "style", "display: grid;grid-template-columns: 1fr minmax(150px, 33%);" ); // add css to allow a grid representation of two divisions.
            window.dispatchEvent( new Event( 'resize' ) ); // trigger resize events to allow Plotly plot to resize its plot
        }
    }
    function DrawD3Table_for_Record_Details( arr_data_clicked ) { // draw d3 table for the given 'arr_data_clicked' record
        Record_Details_Table( true ); // make a div. for table
        // draw 'd3_table_metrics'
        d3.select( "#d3_table_metrics" ).select( "div" ).remove( ); // remove previously drawn table

        let table = d3.select( "#d3_table_metrics" ).append( "div" ).attr( "style", "overflow-x:auto;" ).append( "table" ), thead = table.append( "thead" ), tbody = table.append( "tbody" ).attr( "style", "overflow-y:auto;" ); // write a responsive table
        thead.append( "th" ).text( "Data Name" );
        thead.append( "th" ).text( "Value" );
        let tr = tbody.selectAll( "tr" ).data( arr_data_clicked ).enter( ).append( "tr" ).classed( "table_even", function( d, i ) { return i % 2 == 1; } );
        tr.each( function( d ) {
            var self = d3.select(this);
            self.append("td").attr( "class", "table_left" ).html(d["Data Name"]);
            if ( d.URL != null ) { // if there is available URL link, add the link to the cell
                self.append("td").append("a").attr( "class", "table_left" ).attr("href", d.URL).attr( "target", "_blank" ).attr( "rel", "noopener noreferrer" ).text(d.Value).attr( "style", d.style ); // open the link in a new tab  // security measure to prevent phishing 
            } else { self.append("td").append("a").attr( "class", "table_left" ).text(d.Value).attr( "style", d.style ); }
        });
    }
    async function DrawMolecularMimicryMap( ) {
        return new Promise ( async function( resolve, reject ) {
        Loading_Screen( true );
        let l = [ ], n_digits = 2,
            l_name_dataset = object_data.main.l_name_dataset,
            dict_l = { BCellCrossReactivity_dict_data: [ ], TCellCrossReactivity_dict_data: [ ], BCellCrossReactivity_arr_data: [ ], TCellCrossReactivity_arr_data: [ ] }; // a dictionary containing list of dictionary-arrays (each list containing dictionary-arrays of datasets in l_name_dataset.
        for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
            let name_dataset = l_name_dataset[ index_dataset ], // retrieve name_dataset 
                dataset = object_data.main.dataset[ name_dataset ];
            await LoadRemoteData_BasedOnSettings( name_dataset ); // download necessary data based on settings
            console.log( `[DrawMolecularMimicryMap] preprocessing of ${name_dataset} started with ${( object_data.flag.alignment_to_virus )? "AlignmentToVirus" : "AlignmentToHuman"} mode.` );
            console.log( "[DrawMolecularMimicryMap] Drawing graphs using following files:", dataset.object_plot_BCellCrossReactivity.dir_file, dataset.object_plot_TCellCrossReactivity.dir_file, "for dataset " + name_dataset );
            console.log( "[DrawMolecularMimicryMap] setting hovermode to", object_plot_MolecularMimicryMap.hovermode );

            // preprocess B cell cross reactivity prediction data 
            dataset.arr_data_BCellCrossReactivity = object_data.file.dict_dir_file_to_parsed_data[ dataset.object_plot_BCellCrossReactivity.dir_file ];
            dataset.object_plot_BCellCrossReactivity.n_records = Math.min( dataset.arr_data_BCellCrossReactivity.length, dataset.object_plot_BCellCrossReactivity.n_records_from_setting ); // retrieve the number of BCellCrossReactivity records to plot
            dataset.arr_data_BCellCrossReactivity = dataset.arr_data_BCellCrossReactivity.slice( 0, dataset.object_plot_BCellCrossReactivity.n_records ); // retrieve "dataset.object_plot_BCellCrossReactivity.n_records" number of records
            dict_l.BCellCrossReactivity_arr_data.push( dataset.arr_data_BCellCrossReactivity ); // add array to the list 
            dataset.object_plot_BCellCrossReactivity.dict_data = Unpack_array_to_dict_data( dataset.arr_data_BCellCrossReactivity ); // unpack data to dict_data format
            if ( object_data.flag.alignment_to_virus ) { // when reference virus proteins are used for visualization
                dataset.object_plot_BCellCrossReactivity.dict_data[ "name_protein_virus" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "representative_accession" ], function( acc_rep ) { return dataset.arr_data_acc_virus_representative[ acc_rep ].name; } ); 
            } 
            
            dataset.object_plot_BCellCrossReactivity.dict_data[ "e_value" ] =  dataset.object_plot_BCellCrossReactivity.dict_data[ "e_value" ].map( val => { return ( ( val == 0 ) ? 1e-230 : val ); } ); // replace 0 value with lowest e-value possible
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_dataset" ] =  ArrayFull( dataset.arr_data_BCellCrossReactivity.length, name_dataset ); // put name_dataset
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_protein_human" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return ( object_data.flag.human_label_represents_virus ) ? `${dataset.arr_data_acc_human[ acc ].Species} (${dataset.arr_data_acc_human[ acc ].Genus})` : dataset.arr_data_acc_human[ acc ].name; } ); // name_protein_human is the virus species of virus proteins labeled as 'human' proteins in this application
            dataset.object_plot_BCellCrossReactivity.dict_data[ "virus_accession" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "target_accession" ], function( acc ) { return dataset.arr_data_acc_virus[ acc ].value; } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "human_accession" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return dataset.arr_data_acc_human[ acc ].value; } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "humen_gene_symbol" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "query_accession" ], function( i ) { return dataset.acc_human.dict_data_all[ object_data.setting.name_acc_human ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of human proteins // used for indexing (use upper case to make search case-insensitive)
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_structure_human" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "structure_id_query" ], function( acc ) { if( acc == - 1 ) { return "not available" } else { return dataset.arr_data_acc_pdb[ acc ].value; } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_structure_virus" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "structure_id_target" ], function( acc ) { if( acc == - 1 ) { return "not available" } else { return dataset.arr_data_acc_pdb[ acc ].value; } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_coeffi_acc" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_coeffi_acc" ], function( num ) { if( num == null ) { return "not available" } else { return String( num.toFixed( n_digits ) ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_coeffi_phi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_coeffi_phi" ], function( num ) { if( num == null ) { return "not available" } else { return String( num.toFixed( n_digits ) ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_coeffi_psi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_coeffi_psi" ], function( num ) { if( num == null ) { return "not available" } else { return String( num.toFixed( n_digits ) ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_p_value_acc" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_p_value_acc" ], function( num ) { if( num == null ) { return "not available" } else { return num.toExponential( n_digits ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_p_value_phi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_p_value_phi" ], function( num ) { if( num == null ) { return "not available" } else { return num.toExponential( n_digits ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "string_correl_p_value_psi" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "correl_p_value_psi" ], function( num ) { if( num == null ) { return "not available" } else { return num.toExponential( n_digits ); } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_structure_query" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "structure_id_query" ], function( acc ) { if( acc == - 1 ) { return "not available" } else { return dataset.arr_data_acc_pdb[ acc ].value; } } );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "name_structure_target" ] = ArrayApply( dataset.object_plot_BCellCrossReactivity.dict_data[ "structure_id_target" ], function( acc ) { if( acc == - 1 ) { return "not available" } else { return dataset.arr_data_acc_pdb[ acc ].value; } } );
            
            // retrieve YAxis setting
            selOpt = Select_Get_Selected_Option_Using_ID( "select_YAxis_BCellCrossReactivity" );
            dataset.object_plot_BCellCrossReactivity.y_axis = { label : selOpt.text, name_value : selOpt.value };
            let l_y = dataset.object_plot_BCellCrossReactivity.dict_data[ dataset.object_plot_BCellCrossReactivity.y_axis.name_value ]; 
            dataset.object_plot_BCellCrossReactivity.dict_data[ "y" ] = l_y; // retrieve YAxis setting
            dataset.object_plot_BCellCrossReactivity.float_max_of_l_y = ArrayFindMinMax( l_y )[ 1 ]; // retrieve max value of Y-axis
            // retrieve l_size values
            selOpt = Select_Get_Selected_Option_Using_ID( "select_Size_BCellCrossReactivity" );
            dataset.object_plot_BCellCrossReactivity.size = { label : selOpt.text, name_value : selOpt.value };
            let l_size = dataset.object_plot_BCellCrossReactivity.dict_data[ dataset.object_plot_BCellCrossReactivity.size.name_value ];
            dataset.object_plot_BCellCrossReactivity.dict_data[ "size" ] = l_size; // retrieve l_size values
            // retrieve l_opacity values
            selOpt = Select_Get_Selected_Option_Using_ID( "select_Opacity_BCellCrossReactivity" );
            dataset.object_plot_BCellCrossReactivity.opacity = { label : selOpt.text, name_value : selOpt.value };
            let l_opacity = dataset.object_plot_BCellCrossReactivity.dict_data[ dataset.object_plot_BCellCrossReactivity.opacity.name_value ];
            dataset.object_plot_BCellCrossReactivity.dict_data[ "opacity" ] = l_opacity; // retrieve l_opacity values
            
            // retrieve x coordinates of records
            let arr_start = [ ], arr_end = [ ];
            if ( object_data.flag.alignment_to_virus ) { // when reference virus proteins are used for visualization
                arr_start = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'target_representative_accumulated_start__for_web_application' ] );
                arr_end = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'target_representative_accumulated_end__for_web_application' ] );
            } else {
                arr_start = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_start' ] );
                arr_end = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_end' ] );
            }
            // retrieve x coordinates of records
            dataset.object_plot_BCellCrossReactivity.dict_data[ "start" ] = arr_start.tolist( );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "end" ] = arr_end.tolist( );
            dataset.object_plot_BCellCrossReactivity.dict_data[ "x" ] = arr_start.add( arr_end ).divide( 2 ).tolist( );
            
            let l_colors = [ ], l_float_colors = [ ], l_virus_species = [ ], l_acc_human = dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_accession' ], l_acc_virus = dataset.object_plot_BCellCrossReactivity.dict_data[ "target_accession" ]; // retrieve colors for each alignment
            
            if ( object_data.flag.alignment_to_virus ) { 
                for ( let i = 0; i < l_acc_human.length; i ++ ) { 
                    let color = "", 
                        float_color = 0;
                    // color with human_gene_symbol or virus_species (cross-reactivity between virus species)
                    if ( object_data.flag.human_label_represents_virus ) {
                        let virus_species = dataset.dictarr_data_acc_human.Species[ l_acc_human[ i ] ];
                        float_color = dataset.dict_virus_species_to_float_rainbow_color[ virus_species ];
                        color = dataset.dict_virus_species_to_rainbow_color[ virus_species ];
                        l_virus_species.push( virus_species ) // use virus_species of 'query' dataset
                    } else {
                        float_color = dataset.l_float_for_colormap_rainbow_acc_human[ l_acc_human[ i ] ];
                        color = dataset.l_colormap_rainbow_acc_human[ l_acc_human[ i ] ];
                    }
                    l_colors.push( color );
                    l_float_colors.push( float_color );
                }
                if ( ( ! object_data.flag.human_label_represents_virus ) ) {
                    l_virus_species = ArrayFull( l_acc_human.length, "Severe acute respiratory syndrome coronavirus 2" ); // default virus is SARS-CoV-2 // virus_species of 'target' dataset
                }
            } else { 
                if ( ! ( "Species" in dataset.dictarr_data_acc_virus ) ) { // if Species column does not exist, SARS-CoV-2 is the default virus species 
                    l_virus_species = ArrayFull( l_acc_virus.length, "Severe acute respiratory syndrome coronavirus 2" ); // default virus is SARS-CoV-2
                    l_colors = ArrayFull( l_acc_virus.length, dataset.dict_virus_species_to_rainbow_color[ "Severe acute respiratory syndrome coronavirus 2" ] );
                    l_float_colors = ArrayFull( l_acc_virus.length, dataset.dict_virus_species_to_float_rainbow_color[ "Severe acute respiratory syndrome coronavirus 2" ] );
                } else {   
                    for ( let i = 0; i < l_acc_virus.length; i ++ ) { 
                        let int_acc_virus = l_acc_virus[ i ];
                        let str_virus_species = dataset.dictarr_data_acc_virus.Species[ l_acc_virus[ i ] ];
                        l_virus_species.push( str_virus_species );
                        l_colors.push( dataset.dict_virus_species_to_rainbow_color[ str_virus_species ] );
                        l_float_colors.push( dataset.dict_virus_species_to_float_rainbow_color[ str_virus_species ] );
                    }
                }
            }
            // retrieve virus species
            dataset.object_plot_BCellCrossReactivity.dict_data[ "virus_species" ] = l_virus_species; // virus_species of query dataset
            // retrieve colors for each alignment
            dataset.object_plot_BCellCrossReactivity.dict_data[ "color" ] = l_colors;
            dataset.object_plot_BCellCrossReactivity.dict_data[ "float_color" ] = l_float_colors;
            dataset.object_plot_BCellCrossReactivity.dict_data[ "error_x" ] = arr_end.subtract( arr_start ).divide( 2 ).tolist( ); // retrieve error_x data (representing alignment length)    
            dataset.object_plot_BCellCrossReactivity.dict_data[ "minus_log10_e_value" ] = nj.array( dataset.object_plot_BCellCrossReactivity.dict_data[ 'e_value' ] ).log( ).divide( 2.302585 ).multiply( -1 ).tolist( ); // -log10 of e-values
            
            dict_l.BCellCrossReactivity_dict_data.push( dataset.object_plot_BCellCrossReactivity.dict_data ); // add dictionary-array to the list 

            // index data with acc_human (integer index)
            dataset.object_plot_BCellCrossReactivity.dictionary_int_index_acc_human_to_l_int_index = Index_list_with_dictionary( dataset.object_plot_BCellCrossReactivity.dict_data[ 'query_accession' ] ); // build indices of BCellCrossReactivity data with acc_human (integer index)

            // preprocess T cell cross reactivity prediction data when mhc_ligand prediction data exists
            if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
                dataset.arr_data_TCellCrossReactivity = object_data.file.dict_dir_file_to_parsed_data[ dataset.object_plot_TCellCrossReactivity.dir_file ];
                dataset.object_plot_TCellCrossReactivity.n_records = Math.min( dataset.arr_data_TCellCrossReactivity.length, dataset.object_plot_TCellCrossReactivity.n_records_from_setting ); // retrieve the number of BCellCrossReactivity records to plot
                dataset.arr_data_TCellCrossReactivity = dataset.arr_data_TCellCrossReactivity.slice( 0, dataset.object_plot_TCellCrossReactivity.n_records ); // retrieve "dataset.object_plot_TCellCrossReactivity.n_records" number of records from 'dataset.arr_data_TCellCrossReactivity'
                dict_l.TCellCrossReactivity_arr_data.push( dataset.arr_data_TCellCrossReactivity ); // add array to the list 
                // retrieve protein and mhc_allele related data for hover info. 
                dataset.object_plot_TCellCrossReactivity.dict_data = Unpack_array_to_dict_data( dataset.arr_data_TCellCrossReactivity ); // unpack data to dict_data format
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_dataset" ] =  ArrayFull( dataset.arr_data_TCellCrossReactivity.length, name_dataset ); // put name_dataset
                if ( object_data.flag.alignment_to_virus ) { // when reference virus proteins are used for visualization
                    dataset.object_plot_TCellCrossReactivity.dict_data[ "name_protein_virus" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "representative_accession" ], function( acc_rep ) { return dataset.arr_data_acc_virus_representative[ acc_rep ].name; } ); 
                }
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_protein_human" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return dataset.arr_data_acc_human[ acc ].name; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "virus_accession" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "target_accession" ], function( acc ) { return dataset.arr_data_acc_virus[ acc ].value; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "human_accession" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "query_accession" ], function( acc ) { return dataset.arr_data_acc_human[ acc ].value; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "humen_gene_symbol" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "query_accession" ], function( i ) { return dataset.acc_human.dict_data_all[ object_data.setting.name_acc_human ][ i ].toUpperCase( ); } ); // retrieve gene_symbol of human proteins // used for indexing (use upper case to make search case-insensitive)
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_mhc_allele" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "mhc_allele" ], function( acc ) { return dataset.arr_data_mhc_allele[ acc ].value; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "name_disease" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "mhc_allele" ], function( acc ) { return dataset.arr_data_mhc_allele[ acc ].disease_name; } );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "pubmed_id" ] = ArrayApply( dataset.object_plot_TCellCrossReactivity.dict_data[ "mhc_allele" ], function( acc ) { return dataset.arr_data_mhc_allele[ acc ].pubmed_id; } );

                // retrieve x coordinates of records
                if ( object_data.flag.alignment_to_virus ) { // when reference virus proteins are used for visualization
                    arr_start = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'target_representative_accumulated_start__for_web_application' ] );
                    arr_end = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'target_representative_accumulated_end__for_web_application' ] );
                } else {
                    arr_start = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_start' ] );
                    arr_end = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_end' ] );
                }
                // retrieve x coordinates of records
                dataset.object_plot_TCellCrossReactivity.dict_data[ "start" ] = arr_start.tolist( );
                dataset.object_plot_TCellCrossReactivity.dict_data[ "end" ] = arr_end.tolist( );

                let arr_score = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_blosum' ] ), arr_window_size = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'window_size' ] );
                l_avg_score = arr_score.divide( arr_window_size ).tolist( ); // retrieve sum of blosum62 scores per residue
                dataset.object_plot_TCellCrossReactivity.dict_data[ "avg_score" ] = l_avg_score; // retrieve sum of blosum62 scores per residue
                l_colors = [ ];
                l_float_colors = [ ];

                l_acc_human = dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_accession' ];
                l_acc_virus = dataset.object_plot_TCellCrossReactivity.dict_data[ "target_accession" ]; // retrieve colors for each alignment
                l_virus_species = [ ]; // initialize l_virus_species

                if ( object_data.flag.alignment_to_virus ) { // when reference virus proteins are used for visualization
                    for ( let i = 0; i < l_acc_human.length; i ++ ) { 
                        l_colors.push( dataset.l_colormap_rainbow_acc_human[ l_acc_human[ i ] ] );
                        l_float_colors.push( dataset.l_float_for_colormap_rainbow_acc_human[ l_acc_human[ i ] ] );
                    }
                    l_virus_species = ArrayFull( l_acc_human.length, "Severe acute respiratory syndrome coronavirus 2" ); // default virus is SARS-CoV-2
                } else {
                    if ( ! ( "Species" in dataset.dictarr_data_acc_virus ) ) { // if Species column does not exist, SARS-CoV-2 is the default virus species 
                        l_virus_species = ArrayFull( l_acc_virus.length, "Severe acute respiratory syndrome coronavirus 2" ); // default virus is SARS-CoV-2
                        l_colors = ArrayFull( l_acc_virus.length, dataset.dict_virus_species_to_rainbow_color[ "Severe acute respiratory syndrome coronavirus 2" ] );
                        l_float_colors = ArrayFull( l_acc_virus.length, dataset.dict_virus_species_to_float_rainbow_color[ "Severe acute respiratory syndrome coronavirus 2" ] );
                    } else {   
                        for ( let i = 0; i < l_acc_virus.length; i ++ ) { 
                            let int_acc_virus = l_acc_virus[ i ];
                            let str_virus_species = dataset.dictarr_data_acc_virus.Species[ l_acc_virus[ i ] ];
                            l_virus_species.push( str_virus_species );
                            l_colors.push( dataset.dict_virus_species_to_rainbow_color[ str_virus_species ] );
                            l_float_colors.push( dataset.dict_virus_species_to_float_rainbow_color[ str_virus_species ] );
                        }
                    }
                }
                // retrieve virus species
                dataset.object_plot_TCellCrossReactivity.dict_data[ "virus_species" ] = l_virus_species;
                // retrieve colors for each alignment
                dataset.object_plot_TCellCrossReactivity.dict_data[ "color" ] = l_colors;
                dataset.object_plot_TCellCrossReactivity.dict_data[ "float_color" ] = l_float_colors;

                let l_x = arr_start.add( arr_end ).divide( 2 ).tolist( ); // calculate the coordinate of the middle of each alignment;
                dataset.object_plot_TCellCrossReactivity.dict_data[ "x" ] = l_x; // calculate the coordinate of the middle of each alignment;
                let arr_score_geometric_mean_query = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_geometric_mean_query' ] ), arr_score_geometric_mean_target = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_geometric_mean_target' ] );  

                // retrieve l_y (YAxis values) values
                selOpt = Select_Get_Selected_Option_Using_ID( "select_YAxis_TCellCrossReactivity" );
                dataset.object_plot_TCellCrossReactivity.y_axis = { label : selOpt.text, name_value : selOpt.value };

                switch ( dataset.object_plot_TCellCrossReactivity.y_axis.name_value ) {
                    case "score_blosum":
                    l_y = dataset.object_plot_TCellCrossReactivity.dict_data[ 'score_blosum' ]; 
                    break;    
                    case "average_score_blosum":
                    l_y = l_avg_score; 
                    break;
                    case "score_geometric_mean":
                    l_y = nj.ones( l_avg_score.length ).multiply( 1.5 ).divide( nj.sqrt( arr_score_geometric_mean_query.multiply( arr_score_geometric_mean_target ) ).log( ).divide( 2.302585 ) ).tolist( );
                    break;
                    case "duplicate_counts":
                    l_y = dataset.object_plot_TCellCrossReactivity.dict_data[ dataset.object_plot_TCellCrossReactivity.y_axis.name_value ];
                    break;
                }
                dataset.object_plot_TCellCrossReactivity.dict_data[ "y" ] = l_y; // retrieve l_y (YAxis values) values
                dataset.object_plot_TCellCrossReactivity.float_max_of_l_y = ArrayFindMinMax( l_y )[ 1 ]; // retrieve max value of Y-axis

                dataset.object_plot_TCellCrossReactivity.dict_data[ "error_x" ] = arr_end.subtract( arr_start ).divide( 2 ).tolist( ); // retrieve error_x data (representing alignment length)
                dataset.object_plot_TCellCrossReactivity.dict_data[ "opacity" ] = ArrayFull( dataset.object_plot_TCellCrossReactivity.n_records, float_opacity_MolecularMimicryMap_TCellCrossReactivity ); // set opacity

                let arr_score_geometric_mean_query_log10 = arr_score_geometric_mean_query.log( ).divide( 2.302585 ), // calculate log10 of predicted binding values (IC50)
                    arr_score_geometric_mean_target_log10 = arr_score_geometric_mean_target.log( ).divide( 2.302585 ), // calculate log10 of predicted binding values (IC50)
                    arr_scale = nj.ones( dataset.object_plot_TCellCrossReactivity.n_records ).multiply( 20 ); // for scaling marker size

                dataset.object_plot_TCellCrossReactivity.dict_data[ "size_human" ] = ArrayCap( arr_scale.divide( arr_score_geometric_mean_query_log10 ).tolist( ), 30 ); // set size of markers for human peptides
                dataset.object_plot_TCellCrossReactivity.dict_data[ "size_virus" ] = ArrayCap( arr_scale.divide( arr_score_geometric_mean_target_log10 ).tolist( ), 30 ); // set size of markers for virus peptides
                dataset.object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_query_log10" ] = arr_score_geometric_mean_query_log10.tolist( ); // retrieve list of log10 values of predicted IC50 values
                dataset.object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_target_log10" ] = arr_score_geometric_mean_target_log10.tolist( ); // retrieve list of log10 values of predicted IC50 values
                dataset.object_plot_TCellCrossReactivity.dict_data[ "minus_log10_e_value" ] = nj.array( dataset.object_plot_TCellCrossReactivity.dict_data[ 'e_value' ] ).log( ).divide( 2.302585 ).multiply( -1 ).tolist( ); // -log10 of e-values

                dict_l.TCellCrossReactivity_dict_data.push( dataset.object_plot_TCellCrossReactivity.dict_data ); // add dictionary-array to the list 
                // index data with acc_human (integer index)
                dataset.object_plot_TCellCrossReactivity.dictionary_int_index_acc_human_to_l_int_index = Index_list_with_dictionary( dataset.object_plot_TCellCrossReactivity.dict_data[ 'query_accession' ] ); // build indices of TCellCrossReactivity data with acc_human (integer index)
            }
        }
        console.log( "[DrawMolecularMimicryMap] proprocessing of data for each dataset is completed" )
            
        // initialize objects 
        object_plot_BCellCrossReactivity = { }
        object_plot_TCellCrossReactivity = { }
        // combine records of all datasets in l_name_dataset
        object_plot_BCellCrossReactivity.dict_data_all = DictArrayCombine( ... dict_l.BCellCrossReactivity_dict_data );
        object_plot_TCellCrossReactivity.dict_data_all = DictArrayCombine( ... dict_l.TCellCrossReactivity_dict_data );
        object_plot_BCellCrossReactivity.arr_data_all = ArrayCombine( ... dict_l.BCellCrossReactivity_arr_data );
        object_plot_TCellCrossReactivity.arr_data_all = ArrayCombine( ... dict_l.TCellCrossReactivity_arr_data );
        
        // index data with human_gene_symbol
        object_plot_BCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( object_plot_BCellCrossReactivity.dict_data_all[ "humen_gene_symbol" ] );
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
            object_plot_TCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index = Index_list_with_dictionary( object_plot_TCellCrossReactivity.dict_data_all[ "humen_gene_symbol" ] );
        }
            
        console.log( "[DrawMolecularMimicryMap] records of all datasets were combined and indexed with human_gene_symbol" )
        
        // Draw Plots according to Alignment modes
        object_plot_MolecularMimicryMap.human_gene_symbol_of_interest = null; // initialize 'human_gene_symbol_of_interest'
        if ( object_data.flag.alignment_to_virus ) {
            await DrawMolecularMimicryMap_for_a_human_gene( ); // draw plot for all available human genes
        } else {
            let human_gene_symbol_upper_case = "PARP14"; // draw PARP14 by default
            if ( ! ( "destroy" in tagify_searchbox_main ) ) { // if tagify has not yet been attached to the search box
                searchbox_main.value = ( searchbox_main.value.length == 0 ) ? human_gene_symbol_upper_case : searchbox_main.value + ',' + human_gene_symbol_upper_case ; // Add tag event will be triggered
            } else  if ( ( "destroy" in tagify_searchbox_main ) & ( tagify_searchbox_main.isTagDuplicate( human_gene_symbol_upper_case ) == 0 ) ) { // if tagify has been attached and the gene has not been added as a tag, add gene as tag (will automatically trigger drawing plots for the gene)
                tagify_searchbox_main.addTags( human_gene_symbol_upper_case );
            } else { // manually trigger drawing plots in other cases
                await DrawMolecularMimicryMap_for_a_human_gene( human_gene_symbol_upper_case ); // draw plot for a human gene
            }
        }
        console.log( "[DrawMolecularMimicryMap] plots were drawn" )
        Initialize_SearchBox_Main( ); // initialize main search box
        console.log( "[DrawMolecularMimicryMap] searchbox initialized" )
        resolve( "[DrawMolecularMimicryMap] resolved" );
    });
    }
    async function DrawMolecularMimicryMap_for_a_human_gene( human_gene_symbol = '' ) { 
        return new Promise ( async function( resolve, reject ) {
        console.log( `[DrawMolecularMimicryMap_for_a_human_gene] Plotting started with human_gene_symbol = '${human_gene_symbol}'` );
        // draw plots using object_plot_BCellCrossReactivity.dict_data_all, object_plot_BCellCrossReactivity.arr_data_all, object_plot_TCellCrossReactivity.dict_data_all, object_plot_TCellCrossReactivity.arr_data_all
        let l_name_dataset = object_data.main.l_name_dataset;
        
        // initialize variable related to ploting
        object_data.main.highlight = { str_entry: "" }; // no entry is currently being highlighted
        
        // retrieve dict_data and arr_data
        if ( object_plot_MolecularMimicryMap.human_gene_symbol_of_interest == human_gene_symbol.toUpperCase( ) ) { // if the the human_gene is already being displayed, ignore the function call and exit.
            return;
        } else {
            object_plot_MolecularMimicryMap.human_gene_symbol_of_interest = human_gene_symbol.toUpperCase( ); // update gene of interest
        }
        if ( human_gene_symbol.length == 0 ) { // if 'human_gene_symbol' is an empty string, draw plots of all genes (AlignmentToVirus modes)
            object_plot_BCellCrossReactivity.dict_data = object_plot_BCellCrossReactivity.dict_data_all;
            object_plot_TCellCrossReactivity.dict_data = object_plot_TCellCrossReactivity.dict_data_all;
            object_plot_BCellCrossReactivity.arr_data = object_plot_BCellCrossReactivity.arr_data_all;
            object_plot_TCellCrossReactivity.arr_data = object_plot_TCellCrossReactivity.arr_data_all;
            
            // load data for plotting additional annotations
            let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset to retrieve annotations of virus representative proteins
            object_data.plot.annotation_protein = dataset.annotation_representative_virus_protein;
            object_data.plot.interpro = dataset.interpro_virus;
            object_data.plot.consensus_sequence = dataset.consensus_sequence_virus;
            object_data.plot.iedb_epitope = dataset.iedb_epitope_virus;
        } else {
            let human_gene_symbol_upper_case = human_gene_symbol.toUpperCase( ),
                dict_index = { },
                l_index;
            // retrieve indices of a given human protein and subset B-Cell and T-Cell records
            dict_index = object_plot_BCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index;
            l_index = ( human_gene_symbol_upper_case in dict_index ) ? dict_index[ human_gene_symbol_upper_case ] : [ ]; 
            object_plot_BCellCrossReactivity.dict_data = DictArrayIndexing( object_plot_BCellCrossReactivity.dict_data_all, l_index );
            object_plot_BCellCrossReactivity.arr_data = ArrayIndexing( object_plot_BCellCrossReactivity.arr_data_all, l_index );
            
            dict_index = object_plot_TCellCrossReactivity.dictionary_human_gene_symbol_upper_case_to_l_index;
            l_index = ( human_gene_symbol_upper_case in dict_index ) ? dict_index[ human_gene_symbol_upper_case ] : [ ]; 
            object_plot_TCellCrossReactivity.dict_data = DictArrayIndexing( object_plot_TCellCrossReactivity.dict_data_all, l_index );
            object_plot_TCellCrossReactivity.arr_data = ArrayIndexing( object_plot_TCellCrossReactivity.arr_data_all, l_index );
            
            // load data for plotting additional annotations
            // retrieve interpro and iedb records for a human protein
            for ( let index_dataset = 0; index_dataset < l_name_dataset.length; index_dataset ++ ) {
                let dataset = object_data.main.dataset[ l_name_dataset[ index_dataset ] ];
                
                if ( human_gene_symbol_upper_case in dataset.interpro_human.dictionary_human_gene_symbol_upper_case_to_l_index ) { // if current dataset contain data of the current human_gene_sumbol
                    // initialize
                    let dict_index = { },
                        l_index = [ ];
                    
                    object_data.plot.iedb_epitope = dataset.iedb_epitope_human;
                    dict_index = object_data.plot.iedb_epitope.dictionary_human_gene_symbol_upper_case_to_l_index;
                    object_data.plot.iedb_epitope.dict_data = DictArrayIndexing( dataset.iedb_epitope_human.dict_data_all, ( human_gene_symbol_upper_case in dict_index ) ? dict_index[ human_gene_symbol_upper_case ] : [ ] );
                    
                    // compose the protein sequence trace of the current human_gene_symbol
                    let protein = dataset.arr_data_acc_human[ dataset.acc_human.dictionary_human_gene_symbol_upper_case_to_l_index[ human_gene_symbol_upper_case ][ 0 ] ], // retrieve a protein record of a human_protein (use the first protein of the human_gene_symbol)
                        sequence = { }; // initialize consensus sequence object
                    sequence.accumulated_length = protein.seq_length
                    sequence.seq_consensus_concatenated = protein.seq
                    sequence.l_x = nj.arange( sequence.accumulated_length ).tolist( ) // 0-based coordinates of x-axis
                    sequence.data = [ { type: 'scattergl', mode: "text", x: sequence.l_x, y: ArrayFull( sequence.accumulated_length, - 0.75 ), text: sequence.seq_consensus_concatenated.split( "" ), textfont: { size: 15 }, hoverinfo: "x", hovertemplate: "<br><extra></extra>", showlegend: false, name: "concatanated_consensus_protein_sequence" } ]; // display only x position of residues // no hover info
                    object_data.plot.consensus_sequence = sequence; // initialize consensus sequence object
                    
                    // compose the protein annotation trace of the current human_gene_symbol
                    let annotation = { data: [ ] }, // initialize annotation object
                        pos_y = ( 0.5 - 1 ) / 4 - 0.15;
                    annotation.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of SARS-CoV-2 proteins
                    annotation.data.push( { x: [ 0, protein.seq_length ], y: [ pos_y, pos_y ], name: protein[ object_data.setting.name_acc_human ] + "_Anno_Base", mode: "lines", type: "scatter", opacity: 1, showlegend: false, line: { width: 10, color: "#a3a3a3" }, visible: annotation.show } ); // 0-based coordinates
                    object_data.plot.annotation_protein = annotation; // initialize protein annotation object
                    
                    // compose interpro annotation traces for the current human_gene_symbol
                    let interpro = dataset.interpro_human;
                    interpro.data = [ ];
                    interpro.dict_color = { P: "#1f1994", G: "#08750a", S: "#781387", c: "#798514" }; // initialize interpro object
                    dict_index = interpro.dictionary_human_gene_symbol_upper_case_to_l_index;
                    l_index = ( human_gene_symbol_upper_case in dict_index ) ? dict_index[ human_gene_symbol_upper_case ] : [ ];
                    interpro.dict_data = DictArrayIndexing( interpro.dict_data_all, l_index );
                    interpro.arr_data = ArrayIndexing( interpro.arr_data_all, l_index );
                    interpro.show = $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of interpro domains
                    for ( let i = 0; i < interpro.arr_data.length; i ++ ) {
                        let step = 10, // anchor every 10 residues
                            domain = interpro.arr_data[ i ], 
                            pos_y = ( 0.5 - 1 ) / 4 - 0.15, 
                            customdata = [ protein[ object_data.setting.name_acc_human ], protein.seq_length, domain.interpro_name, domain.interpro_acc, domain.annotation_acc, domain.start, domain.end ], // 1-based coodinates
                            len_domain = domain.end - domain.start + 1,  
                            trace = { name: domain.interpro_name + "__InterPro", mode: "lines", type: "scatter", opacity: 0.2, showlegend: false, line: { width: 15, color: interpro.dict_color[ domain.annotation_acc.slice( 0, 1 ) ] }, visible: interpro.show, 
                                     hovertemplate: "InterPro Domain: <b>%{customdata[2]}</b> (%{customdata[3]})<br>Protein: <b>%{customdata[0]}</b> (from %{customdata[5]:.0f} to %{customdata[6]:.0f})<br>Database accession: %{customdata[4]}<br><extra></extra>", customdata: [ ], x: [ ], y: [ ] };
                        
                        for ( let j = 0; j <= len_domain / step + 1; j ++ ) { // for each domain, plot point every 10 residues for displaying information through hover
                            trace.customdata.push( customdata );
                            trace.y.push( pos_y );
                            let x = domain.start - 1 + j * step; // 0-based coordinates
                            trace.x.push( ( x > domain.end ) ? domain.end : x )
                        }
                        interpro.data.push( trace );
                    }
                    object_data.plot.interpro = interpro;
                }
            }
        }
        // index data with virus_species of interest
        object_plot_BCellCrossReactivity.dictionary_virus_species_to_l_index = Index_list_with_dictionary( ( object_data.flag.human_label_represents_virus ) ? object_plot_BCellCrossReactivity.dict_data[ "virus_species" ] : object_plot_BCellCrossReactivity.dict_data[ "virus_species" ] );

        // compose customdata array and hovertemplate            
        object_plot_BCellCrossReactivity.hovertemplate = ["[ B-cell cross reactivity prediction ]",
                                                          ( object_data.flag.alignment_to_virus ) ? "%{customdata[23]}:<br>          <b>%{customdata[25]}</b> from <b>%{customdata[26]:.0f}</b> to <b>%{customdata[27]:.0f}</b> (<b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>)" : "%{customdata[23]}:<br>          <b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>", // display coordinates on the representative virus protein
                                                          "        structure: <b>%{customdata[6]}</b>",
                                                          ( object_data.flag.human_label_represents_virus ) ? "%{customdata[3]}:<br>          <b>%{customdata[24]}</b> from <b>%{customdata[4]:.0f}</b> to <b>%{customdata[5]:.0f}</b>" : "Human: <b>%{customdata[3]}</b> (<b>%{customdata[24]}</b>) from <b>%{customdata[4]:.0f}</b> to <b>%{customdata[5]:.0f}</b>",
                                                          "        structure: <b>%{customdata[7]}</b>",
                                                          "",
                                                          "Structure Similarity:",
                                                          "        secondary structure: <b>%{customdata[8]:.2f}</b>",
                                                          "        surface accessibility correlation (p-value): <b>%{customdata[9]}</b> (%{customdata[12]})",
                                                          "        torsion angle correlation (phi) (p-value): <b>%{customdata[10]}</b> (%{customdata[13]})",
                                                          "        torsion angle correlation (psi) (p-value): <b>%{customdata[11]}</b> (%{customdata[14]})",
                                                          "        global alignment identity (significance, e-value): <b>%{customdata[22]:.2f}</b> (<b>%{customdata[21]:.1e}</b>)",
                                                          "",
                                                          "Epitope Similarity:",
                                                          "        linear similarity (sum of BLOSUM62 scores): <b>%{customdata[16]:.1f}</b>",
                                                          "        discontinuous similarity (only co-accessible residues): <b>%{customdata[17]:.1f}</b>",
                                                          "        discontinuous similarity normalized by window length (%{customdata[19]:.0f} a.a.): <b>%{customdata[15]:.2f}</b>",
                                                          "        number of co-accessible residues: <b>%{customdata[18]:.1f}</b>",
                                                          "(this epitope represent <i>%{customdata[20]:.0f} epitopes</i> before redundancy reduction)",
                                                          "<br><extra></extra>" ].join( "<br>" );

        object_plot_BCellCrossReactivity.customdata = DictArrayToArray( object_plot_BCellCrossReactivity.dict_data, [ "virus_accession", "target_start", "target_end", "name_protein_human", "query_start", "query_end", "name_structure_virus", "name_structure_human", "score_similarity_ss8", "string_correl_coeffi_acc", "string_correl_coeffi_phi", "string_correl_coeffi_psi", "string_correl_p_value_acc", "string_correl_p_value_phi", "string_correl_p_value_psi", "avg_score_blosum_weighted", "score_blosum", "score_blosum_weighted", "sum_of_weights", "window_size", "duplicate_counts", "e_value", "identity", "virus_species", "humen_gene_symbol" ] );
        if ( object_data.flag.alignment_to_virus ) { // when reference virus proteins are used for visualization
            object_plot_BCellCrossReactivity.customdata = ArrayCombine( object_plot_BCellCrossReactivity.customdata, DictArrayToArray( object_plot_BCellCrossReactivity.dict_data, [ "name_protein_virus", "target_representative_start", "target_representative_end" ] ) );
        }
        object_plot_BCellCrossReactivity.customdata = ArrayTranspose( object_plot_BCellCrossReactivity.customdata );
                        
        object_plot_BCellCrossReactivity.selection = { l_error_x: object_plot_BCellCrossReactivity.dict_data[ 'error_x' ], l_opacity: object_plot_BCellCrossReactivity.dict_data[ 'opacity' ] }; // for highlighting specific records
        
        data_line_type_MolecularMimicryMap_BCellCrossReactivity = [ ]; // empty data for line-type MolecularMimicryMap_BCellCrossReactivity plot

        // retrieve general setting            
        layout_MolecularMimicryMap.hovermode = object_plot_MolecularMimicryMap.hovermode; // update hovermode
        object_plot_MolecularMimicryMap.showlegend = false // flag for showing name of certain traces (a legend of the graph)
        plotMolecularMimicryMap.style.height = String( Math.max( 200, Math.min( 1000, document.getElementById( "input_plot_height_MolecularMimicryMap" ).value ) ) ) + 'px' // set height of the MolecularMimicryMap plot // max height is 1000 // min height is 200
            
        object_plot_BCellCrossReactivity.flag_bool_mode_is_lines = document.getElementById( "select_representation_of_an_alignment_BCellCrossReactivity" ).value == 1? true : false; 
        plotly_type_BCellCrossReactivity = document.getElementById( "select_graphic_format_BCellCrossReactivity" ).value == 0? "scattergl" : "scatter"; // retrieve plot setting from the setting panel

        object_plot_BCellCrossReactivity.show = $( "#toggle_BCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // retrieve visibility
        console.log( "[DrawMolecularMimicryMap] BCellCrossReactivity visibility:", object_plot_BCellCrossReactivity.show );

        
        // compose traces
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { 
            for ( let i = 0; i < object_plot_BCellCrossReactivity.arr_data.length; i ++ ) {
                let trace = {  };
                trace.x = [ object_plot_BCellCrossReactivity.dict_data[ 'start' ][ i ], object_plot_BCellCrossReactivity.dict_data[ 'end' ][ i ] ]; // retrieve start and end position
                trace.y = [ object_plot_BCellCrossReactivity.dict_data[ 'y' ][ i ], object_plot_BCellCrossReactivity.dict_data[ 'y' ][ i ] ];
                trace.type = plotly_type_BCellCrossReactivity
                trace.mode = 'lines'
                trace.name = "BCR_" + String( i ) // assign trace name for the current record
                trace.line = { width: object_plot_BCellCrossReactivity.dict_data[ 'size' ][ i ] }
                trace.opacity = float_line_type_opacity_MolecularMimicryMap_BCellCrossReactivity // fixed opacity for the line-type plot for efficient updating
                trace.line.color = object_plot_BCellCrossReactivity.dict_data[ 'color' ][ i ];
                trace.showlegend = false;
                trace.visible = object_plot_BCellCrossReactivity.show;
                trace.customdata = [ object_plot_BCellCrossReactivity.customdata[ i ], object_plot_BCellCrossReactivity.customdata[ i ] ];
                trace.hovertemplate = object_plot_BCellCrossReactivity.hovertemplate;
                data_line_type_MolecularMimicryMap_BCellCrossReactivity.push( trace )
            }
        } else {
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.x = object_plot_BCellCrossReactivity.dict_data[ 'x' ]; 
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.y = object_plot_BCellCrossReactivity.dict_data[ 'y' ];
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.size = object_plot_BCellCrossReactivity.dict_data[ 'size' ];
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.opacity = object_plot_BCellCrossReactivity.dict_data[ 'opacity' ];
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.color = object_plot_BCellCrossReactivity.dict_data[ 'color' ];;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.marker.line.width = 0
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.type = plotly_type_BCellCrossReactivity;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.showlegend = false;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.name = 'B Cell Cross-Reactivity Prediction'
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.visible = object_plot_BCellCrossReactivity.show;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.error_x = { type: 'data', array: object_plot_BCellCrossReactivity.dict_data[ "error_x" ], visible: true, width: 0, thickness: 1 }; // represent alignment by using errorbar
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.customdata = object_plot_BCellCrossReactivity.customdata;
            trace_point_type_MolecularMimicryMap_BCellCrossReactivity.hovertemplate = object_plot_BCellCrossReactivity.hovertemplate;
        }
            
        object_plot_BCellCrossReactivity.metrics = { }; // initialize metrics
        object_plot_BCellCrossReactivity.metrics[ '-log10( e-value )' ] = object_plot_BCellCrossReactivity.dict_data[ "minus_log10_e_value" ];
        object_plot_BCellCrossReactivity.mask_selected = ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, true ); // initialize mask for selection 
            
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { // when mhc_ligand prediction data exists
            // index data with virus_species
            object_plot_TCellCrossReactivity.dictionary_virus_species_to_l_index = Index_list_with_dictionary( object_plot_TCellCrossReactivity.dict_data[ "virus_species" ] );
            
            // compose customdata array and hovertemplate   
            object_plot_TCellCrossReactivity.hovertemplate = ["[ T-cell cross reactivity prediction ]",
                                                              "MHC allele (class): <b>%{customdata[12]}</b> (<b>%{customdata[15]}</b>)",
                                                              "        associated diseases: <b>%{customdata[13]}</b>",
                                                              "        PubMed ID: %{customdata[14]}",
                                                              "",
                                                              ( object_data.flag.alignment_to_virus )? "%{customdata[21]}:<br>          <b>%{customdata[23]}</b> from <b>%{customdata[24]:.0f}</b> to <b>%{customdata[25]:.0f}</b> (<b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>)" : "%{customdata[21]}:<br>          <b>%{customdata[0]}</b> from <b>%{customdata[1]:.0f}</b> to <b>%{customdata[2]:.0f}</b>",
                                                              "        sequence: <b>%{customdata[6]}</b>",
                                                              "        predicted binding affinity (IC50): <b>%{customdata[8]} nM</b>",
    //                                                           "        list of used algorithms: %{customdata[10]}",
                                                              "",
                                                              "Human: <b>%{customdata[3]}</b> (<b>%{customdata[22]}</b>) from <b>%{customdata[4]:.0f}</b> to <b>%{customdata[5]:.0f}</b>",
                                                              "        sequence: <b>%{customdata[7]}</b>",
                                                              "        predicted binding affinity (IC50): <b>%{customdata[9]} nM</b>",
    //                                                           "        list of used algorithms: %{customdata[11]}",
                                                              "",
                                                              "Epitope Similarity:",
                                                              "        linear similarity (sum of BLOSUM62 scores): <b>%{customdata[16]:.1f}</b>",
                                                              "        linear similarity normalized by window length (%{customdata[19]:.0f} a.a.): <b>%{customdata[17]:.2f}</b>",
    //                                                           "    Global alignment significance (e-value): <b>%{customdata[20]:.2f}</b>",
                                                              "(this epitope represent <i>%{customdata[18]:.0f} epitopes</i> before redundancy reduction)",
                                                              "<br><extra></extra>" ].join( "<br>" );

            object_plot_TCellCrossReactivity.customdata = DictArrayToArray( object_plot_TCellCrossReactivity.dict_data, [ "virus_accession", "target_start", "target_end", "name_protein_human", "query_start", "query_end", "target_subsequence", "query_subsequence", "score_geometric_mean_target", "score_geometric_mean_query", "algorithms_target", "algorithms_query", "name_mhc_allele", "name_disease", "pubmed_id", "mhc_class", "score_blosum", "avg_score", "duplicate_counts", "window_size", "e_value", "virus_species", "humen_gene_symbol" ] );
            if ( object_data.flag.alignment_to_virus ) { // when reference virus proteins are used for visualization
                object_plot_TCellCrossReactivity.customdata = ArrayCombine( object_plot_TCellCrossReactivity.customdata, DictArrayToArray( object_plot_TCellCrossReactivity.dict_data, [ "name_protein_virus", "target_representative_start", "target_representative_end" ] ) );
            }
            object_plot_TCellCrossReactivity.customdata = ArrayTranspose( object_plot_TCellCrossReactivity.customdata );
            
            
            object_plot_TCellCrossReactivity.selection = { l_error_x: object_plot_TCellCrossReactivity.dict_data[ 'error_x' ], l_opacity: object_plot_TCellCrossReactivity.dict_data[ 'opacity' ] }; // for highlighting specific records
            
            // retrieve general setting  
            int_index_representation_TCellCrossReactivity = document.getElementById( "select_representation_of_an_alignment_TCellCrossReactivity" ).value; // retrieve plot setting from the setting panel
            plotly_type_TCellCrossReactivity = document.getElementById( "select_graphic_format_TCellCrossReactivity" ).value == 0? "scattergl" : "scatter"; 
            object_plot_TCellCrossReactivity.show = $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // retrieve visibility
            console.log( "[DrawMolecularMimicryMap] TCellCrossReactivity visibility:", object_plot_TCellCrossReactivity.show );
            
            // compose traces
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.x = object_plot_TCellCrossReactivity.dict_data[ 'x' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.x = object_plot_TCellCrossReactivity.dict_data[ 'x' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.y = object_plot_TCellCrossReactivity.dict_data[ 'y' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.y = object_plot_TCellCrossReactivity.dict_data[ 'y' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.symbol = [ "y-down-open", "star-triangle-down-dot", "bowtie" ][ int_index_representation_TCellCrossReactivity ]; // retrieve representation based on the given "int_index_representation_TCellCrossReactivity"
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.symbol = [ "y-up-open", "star-triangle-up-dot", "hourglass" ][ int_index_representation_TCellCrossReactivity ];

            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.size = object_plot_TCellCrossReactivity.dict_data[ 'size_human' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.size = object_plot_TCellCrossReactivity.dict_data[ 'size_virus' ];

            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.line.width = int_index_representation_TCellCrossReactivity == 0 ? 2 : 0; // if symbol is "y-down-open", set line width to 3
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.line.width = int_index_representation_TCellCrossReactivity == 0 ? 2 : 0; // if symbol is "y-down-open", set line width to 3
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.color = object_plot_TCellCrossReactivity.dict_data[ 'color' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.color = object_plot_TCellCrossReactivity.dict_data[ 'color' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.marker.opacity = object_plot_TCellCrossReactivity.dict_data[ 'opacity' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.marker.opacity = object_plot_TCellCrossReactivity.dict_data[ 'opacity' ];
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.type = plotly_type_TCellCrossReactivity;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.type = plotly_type_TCellCrossReactivity;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.name = "T Cell Cross-Reactivity Prediction (Human)";
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.name = "T Cell Cross-Reactivity Prediction (Virus)";
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.visible = object_plot_TCellCrossReactivity.show;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.visible = object_plot_TCellCrossReactivity.show;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.error_x = { type: 'data', array: ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, 0 ), visible: true, width: 0, thickness: 1 }
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.error_x = { type: 'data', array: object_plot_TCellCrossReactivity.dict_data[ 'error_x' ], visible: true, width: 0, thickness: 1 }; // represent alignment by using errorbar of the trace containing data of virus

            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human.hoverinfo = 'skip'; // skip hoverinfo for the other trace
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.hovertemplate = object_plot_TCellCrossReactivity.hovertemplate;
            trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus.customdata = object_plot_TCellCrossReactivity.customdata;

            object_plot_TCellCrossReactivity.metrics = { }; // initialize metrics
            object_plot_TCellCrossReactivity.metrics[ '-log10( e-value )' ] = object_plot_TCellCrossReactivity.dict_data[ "minus_log10_e_value" ];
            object_plot_TCellCrossReactivity.metrics[ "log10( score_geometric_mean_query )" ] = object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_query_log10" ];
            object_plot_TCellCrossReactivity.metrics[ "log10( score_geometric_mean_target )" ] = object_plot_TCellCrossReactivity.dict_data[ "score_geometric_mean_target_log10" ];
            object_plot_TCellCrossReactivity.mask_selected = ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, true ); // initialize mask for selection
        }
            
        // adjust layouts
        object_plot_MolecularMimicryMap.float_max_of_l_y = ArrayFindMinMax( ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? ArrayCombine( object_plot_BCellCrossReactivity.dict_data[ 'y' ], object_plot_TCellCrossReactivity.dict_data[ 'y' ] ) : object_plot_BCellCrossReactivity.dict_data[ 'y' ] )[ 1 ]; // retrieve the max value on the Y-axis for both T and B CellCrossReactivity prediction data
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { 
            console.log( "[DrawMolecularMimicryMap] number of TCellCrossReactivity prediction records for plotting:", object_plot_TCellCrossReactivity.arr_data.length );
        }
        let y_ticks = TickFindOptimal( object_plot_MolecularMimicryMap.float_max_of_l_y ); // generate and assign appropriate y_ticks
        layout_MolecularMimicryMap.yaxis.tickvals = y_ticks;
        layout_MolecularMimicryMap.yaxis.ticktext = ArrayApply( y_ticks, String );
        layout_MolecularMimicryMap.margin.l = 13 + 20 * 2 + layout_MolecularMimicryMap.yaxis.ticktext[ y_ticks.length - 1 ].length * 7; // adjust margins // one digit of y_tick label is about 7 pixels
        console.log( "[DrawMolecularMimicryMap] setting margins of the main graph with following settings:", layout_MolecularMimicryMap.margin );
        console.log( "[DrawMolecularMimicryMap] number of BCellCrossReactivity prediction records for plotting:", object_plot_BCellCrossReactivity.arr_data.length );
        
        // set range of rangeslider according to Alignment mode
        layout_MolecularMimicryMap.xaxis.rangeslider.range = [ 0, object_data.plot.consensus_sequence.accumulated_length ]; // set range using accumulated length of consensus virus sequences
        
        // Draw plots using Plotly.js
        object_plot_BCellCrossReactivity.index_trace_start = 0; // record index_start of traces
        // draw B cell cross reactivity prediction data
        if ( object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) { 
            Plotly.newPlot( plotMolecularMimicryMap, lodash.cloneDeep( data_line_type_MolecularMimicryMap_BCellCrossReactivity ), lodash.cloneDeep( layout_MolecularMimicryMap ), config_MolecularMimicryMap ); 
        } else {
            Plotly.newPlot( plotMolecularMimicryMap, [ lodash.cloneDeep( trace_point_type_MolecularMimicryMap_BCellCrossReactivity ) ], lodash.cloneDeep( layout_MolecularMimicryMap ), config_MolecularMimicryMap );
        }
        object_plot_BCellCrossReactivity.index_trace_end = plotMolecularMimicryMap.data.length; // record index_end of traces
        // update metrics plot
        UpdateBCellCrossReactivityPredMetricsPlot( );
            

        // draw T cell cross reactivity prediction data
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) { 
            // draw T cell cross reactivity prediction data
            object_plot_TCellCrossReactivity.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
            Plotly.addTraces( plotMolecularMimicryMap, [ lodash.cloneDeep( trace_point_type_MolecularMimicryMap_TCellCrossReactivity_human ), lodash.cloneDeep( trace_point_type_MolecularMimicryMap_TCellCrossReactivity_virus ) ] );
            object_plot_TCellCrossReactivity.index_trace_end = plotMolecularMimicryMap.data.length;
            // update metrics plot
            UpdateTCellCrossReactivityPredMetricsPlot( );
        }
        // compose traces
        UpdateHumanProteinMetricsPlot( );
        
        // Add protein annotations 
        console.log( '[DrawMolecularMimicryMap] plotting virus protein annotation traces...' )
            // add annotation of proteins
        object_data.plot.annotation_protein.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
        Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.annotation_protein.data ) );
        object_data.plot.annotation_protein.index_trace_end = plotMolecularMimicryMap.data.length;
            // add annotation of domains
        object_data.plot.interpro.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
        Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.interpro.data ) );
        object_data.plot.interpro.index_trace_end = plotMolecularMimicryMap.data.length;
            // add annotation of consensus protein sequence
        object_data.plot.consensus_sequence.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
        Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.consensus_sequence.data ) );
        object_data.plot.consensus_sequence.index_trace_end = plotMolecularMimicryMap.data.length;

        // update the visibility of protein annotation traces
        Toggle_ProteinAnnotation_MolecularMimicryMap( true );

        // Add IEDB epitopes with positive assays
        object_data.flag.iedb_epitope_drawn = false; // set flag indicating whether the plot has been drawn or not
        object_data.plot.iedb_epitope.show = $( "#toggle_iedb_epitope_MolecularMimicryMap" ).hasClass( "active" );
        if ( object_data.plot.iedb_epitope.show ) {
            Toggle_IEDB_Epitope_MolecularMimicryMap( true );
        }
        
        if ( object_data.flag.alignment_to_virus ) {
            let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset to draw virus annotations
            
            // Add metrics for vaccine design
            object_data.flag.vaccine_metric_drawn = false; // set flag indicating whether the plot has been drawn or not
            dataset.vaccine_metric.show = $( "#toggle_vaccine_metrics_MolecularMimicryMap" ).hasClass( "active" ); // set general visibility of all vaccine metric traces
            if ( dataset.vaccine_metric.show ) {
                VaccineMetrics_Apply_Visibility( true );
            }
            
            // retrieve mapping of name of each trace to trace index
            dict_name_plot_to_trace_index__MolecularMimicryMap = { }; // initialize the mapping
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; }
            
            // draw vaccine candidates // draw DesignedVaccineTrace if the file has been loaded after trace index has been updated
            dataset.flag.vaccine_design_optivax_loaded = false; // assume reference genome changed 
            object_data.flag.vaccine_design_drawn = false; // set flag indicating whether the plot has been drawn or not
            dataset.vaccine_design.show = $( "#toggle_vaccine_design_MolecularMimicryMap" ).hasClass( "active" );
            if ( dataset.vaccine_design.show ) {
                Toggle_VaccineDesign_MolecularMimicryMap( );
            }
            
        } else {
            // retrieve mapping of name of each trace to trace index
            dict_name_plot_to_trace_index__MolecularMimicryMap = { }; // initialize the mapping
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; }
        }
        Loading_Screen( false ); // remove loading screen once plot is drawn
        
        // Add Plotly interactions to MolecularMimicryMap main plot
        // draw tables and show molecular structure upon click
        console.log( '[DrawMolecularMimicryMap] adding interaction callbacks...' )
        plotMolecularMimicryMap.on( 'plotly_click', function( data ) {
            let clicked_point = data.points[ 0 ]; // only use the first point in the returned list of points to show a table containing alignment metrics and details
            let index = null, flag_data_type = null, name_trace = plotMolecularMimicryMap.data[ clicked_point.curveNumber ].name;
            console.log( name_trace );
            index = name_trace.slice( 0, 4 ) == "BCR_" ? clicked_point.curveNumber : clicked_point.pointIndex;
            if ( name_trace == "B Cell Cross-Reactivity Prediction" ) {
                flag_data_type = "B-Cell";
            } else if ( name_trace.slice( 0, 4 ) == "BCR_" ) {
                flag_data_type = "B-Cell";
            } else if ( name_trace.includes( "T Cell Cross-Reactivity Prediction" ) ) {
                flag_data_type = "T-Cell";
            } else if ( name_trace.includes( "IEDB_Epitopes" ) ) {
                flag_data_type = "IEDB";
            } else if ( name_trace.includes( "__InterPro" ) ) {
                flag_data_type = "InterPro";
            } else if ( name_trace == "vaccine_design" ) {
                flag_data_type = "vaccine_design";
            }
            gtag( 'event', 'main_graph_click_callback', { 'clicked_data_type' : flag_data_type } ); // [Google Analytics] record data_type of the clicked record to further improve the visualization of the data_type
            if ( flag_data_type == "B-Cell" ) { // when clicked data belongs to BCellCrossReactivity data         
                ClickCallBack_BCellCrossReactivity( index )
            } else if ( flag_data_type == "T-Cell" ) {
                Toggle_Exclusive_Tabs( "hide_all" ); // hide all supplementary tabs
                let name_dataset = object_plot_TCellCrossReactivity.dict_data[ "name_dataset" ][ index ],
                    dataset = object_data.main.dataset[ name_dataset ]; // retrieve namespace for a dataset
                clicked_record = object_plot_TCellCrossReactivity.arr_data[ index ]; // retrieve a clicked record
                
                object_data.main.expression = { name_dataset: name_dataset, int_index_acc_human: clicked_record.query_accession }; // setting for showing expression of a gene of interest
                UpdatePlotExpression( ); // Plot mRNA expression data
                console.log( "[plotMolecularMimicryMap] clicked record belongs to TCellCrossReactivity data:", clicked_record );
                arr_data_clicked = [ ]; // empty the array containing data of the clincked record
                if ( object_data.flag.alignment_to_virus ) { // add information of representative virus protein
                    let representative_virus_protein = dataset.arr_data_acc_virus_representative[ clicked_record.representative_accession ];
                    arr_data_clicked.push( { "Data Name": "[virus] representative protein", Value: representative_virus_protein.name + " (" + representative_virus_protein.accession + ") from " + clicked_record.target_representative_start + " to " + clicked_record.target_representative_end, URL: "https://www.ncbi.nlm.nih.gov/protein/" + representative_virus_protein.accession } );
                }
                arr_data_clicked.push( { "Data Name": "[human] protein name", Value: dataset.arr_data_acc_human[ clicked_record.query_accession ].name, URL: "https://www.google.com/search?q=" + dataset.arr_data_acc_human[ clicked_record.query_accession ].description.split( "OS=" )[ 0 ] } ); // add human protein description with a link to a google search
                arr_data_clicked.push( { "Data Name": "[virus] protein accession", Value: dataset.arr_data_acc_virus[ clicked_record.target_accession ].value + " from " + clicked_record.target_start + " to " + clicked_record.target_end, URL: "https://www.ncbi.nlm.nih.gov/protein/" + dataset.arr_data_acc_virus[ clicked_record.target_accession ].value } );
                arr_data_clicked.push( { "Data Name": "[human] protein accession", Value: dataset.arr_data_acc_human[ clicked_record.query_accession ].value + " from " + clicked_record.query_start + " to " + clicked_record.query_end, URL: "https://www.uniprot.org/uniprot/" + dataset.arr_data_acc_human[ clicked_record.query_accession ].value } );
                arr_data_clicked.push( { "Data Name": "[virus] peptide", Value: clicked_record.target_subsequence, URL: null, style: "font-family:Consolas" } );
                arr_data_clicked.push( { "Data Name": "[human] peptide", Value: clicked_record.query_subsequence, URL: null, style: "font-family:Consolas" } );
                arr_data_clicked.push( { "Data Name": "[virus] predicted binding affinity*", Value: String( clicked_record.score_geometric_mean_target ) + " nM", URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "[human] predicted binding affinity*", Value: String( clicked_record.score_geometric_mean_query ) + " nM", URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "[virus] prediction algorithms", Value: dataset.l_algorithm[ clicked_record.algorithms_target ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "[human] prediction algorithms", Value: dataset.l_algorithm[ clicked_record.algorithms_query ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "sum of BLOSUM62 scores", Value: clicked_record.score_blosum, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "MHC class", Value: clicked_record.mhc_class, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "MHC allele", Value: dataset.arr_data_mhc_allele[ clicked_record.mhc_allele ].value, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "E-value (significance) of full-length alignment", Value: clicked_record.e_value, URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "alignment method", Value: clicked_record.source_is_blastp? "BLASTP" : "HMMER", URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "number of redundant alignments", Value: clicked_record.duplicate_counts, URL: null, style: "font-family:Arial" } );
                
                DrawD3Table_for_Record_Details( arr_data_clicked );
                document.getElementById( "title_d3_table_metrics" ).innerHTML = "T-Cell Cross-Reactivity Prediction data"; // update table title for 'd3_table_metrics' table
                document.getElementById( "footnote_d3_table_metrics" ).innerHTML = "A geometric average of predicted IC50 values. IC50 is the concentration that inhibits 50% binding of the fluorescein-labeled reference peptide."; // update table footnote for 'd3_table_metrics' table

                // draw Plotly table visualizing BLOSUM62 scores
                object_data_tableSequence.flag_data_type = "T-Cell";
                let len_alignment = clicked_record.query_subsequence.length, query_aligned_sequence = clicked_record.query_subsequence, target_aligned_sequence = clicked_record.target_subsequence, l_score_blosum = [ ];
                for ( let i = 0; i < query_aligned_sequence.length; i ++ ) { l_score_blosum.push( Math.round( object_data.main.dict_blosum62[ query_aligned_sequence[ i ] + target_aligned_sequence[ i ] ] ) ); } // round the blosum score so that step become 1
                let l_color_score_blosum = Color_for_score_blosum( l_score_blosum );

                let colors = [ ], values = [ ], header = [ ], l_col = [ 'virus_seq', 'score_blosum', 'human_seq' ];
                values.push( ... [ target_aligned_sequence.split( "" ), l_score_blosum, query_aligned_sequence.split( "" ) ] );
                colors.push( ... [ ArrayFull( len_alignment, "#ffffff" ), l_color_score_blosum, ArrayFull( len_alignment, "#ffffff" ) ] );

                for ( let i = 0; i < l_col.length; i ++ ) { header.push( [ "<b>" + l_col[ i ] + "</b>" ] ); } // build header from 'l_col'
                object_data_tableSequence.data = [{
                    type: 'table',
                    header: { values: header, align: "center", height: 30, line: {width: 1, color: '#506784'}, fill: {color: '#f0f0f0'}, font: {family: "Arial", size: 12, color: "black"} },
                    cells: {values: values, align: "center", height: 20, line: {color: colors, width: 1}, fill: {color: colors }, font: {family: "Arial", size: 12, color: ["#3d3d3d"] }}
                }];
                document.getElementById( "plotly_table_sequence" ).style.height = String( Math.min( 20 * int_n_residues_per_window_table_sequence + 30 + 10, parseInt( l_score_blosum.length * 20 + 30 + 10 ) ) ) + "px"; // set height of table according to the length of alignment # max height is 640
//                 let layout_tableSequence_TCellCrossReactivity = Object.assign( { width: ( Math.min( , tableSequence.getBoundingClientRect( ).width ) ) }, layout_tableSequence )
                if ( "removeAllListeners" in tableSequence ) { 
                    tableSequence.removeAllListeners( "click" ); tableSequence.removeEventListener( 'click', Highlight_PDB_Residue__Click_Callback__Aligned_Sequence_Table ) } // remove previous listeners if a listener exists
                str_jquery_container = "#container_plotly_table_sequence";
                if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( ); // draw Plotly plot synchronously if the container is currently shown
                } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden
                document.getElementById( "description_clicked_position__table_sequence" ).innerHTML = ""; // empty the description
                
                // Render default molecular structures using the Mol* JS application
                str_jquery_container = "#container_PDB";
                let pos_protein = 0, pos_pdb = 0;
                // show dummy if T-cell cross-reactivity prediction record was been clicked. 
                if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { pdbHumanProtein.visual.update( option_initialization_molstar );; // render coordinates synchronously if the container is currently shown
                } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { pdbHumanProtein.visual.update( option_initialization_molstar ); } ); } // render coordinates once the container is shown if the container is currently hidden
                if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { pdbVirusProtein.visual.update( option_initialization_molstar );; // render coordinates synchronously if the container is currently shown
                } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { pdbVirusProtein.visual.update( option_initialization_molstar ); } ); } // render coordinates once the container is shown if the container is currently hidden
                // update protein id label (to increse interactivity)
                document.getElementById( "text_protein_structure_virus" ).innerText = ( object_data.flag.human_label_represents_virus ) ? `SARS-CoV-2 (----)` : `Virus (----)`;
                document.getElementById( "text_protein_structure_human" ).innerText = ( object_data.flag.human_label_represents_virus ) ? `Coronavirus (----)` : `Human (----)`;
            } else if ( flag_data_type == "IEDB" ) {
                let customdata = clicked_point.customdata; // retrieve custom data of clicked point
                console.log( "[plotMolecularMimicryMap] clicked record is IEDB epitope:", clicked_point );

                arr_data_clicked = [ ]; // empty the array containing data of the clincked record
                let url_iedb = "https://www.iedb.org/epitope/" + customdata[ 0 ];
                arr_data_clicked.push( { "Data Name": "representative virus protein", Value: customdata[ 5 ] + " from " + customdata[ 3 ] + " to " + customdata[ 4 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "IEDB epitope accession", Value: customdata[ 0 ], URL: url_iedb, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "number of positive B-cell assays", Value: customdata[ 1 ], URL: url_iedb, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "number of positive T-cell assays", Value: customdata[ 2 ], URL: url_iedb, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "percent_identity", Value: customdata[ 7 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "mismatch", Value: customdata[ 8 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "gapopen", Value: customdata[ 9 ], URL: null, style: "font-family:Arial" } );

                DrawD3Table_for_Record_Details( arr_data_clicked );
                document.getElementById( "title_d3_table_metrics" ).innerHTML = "Immune Epitope Database (IEDB) Epitope"; // update table title for 'd3_table_metrics' table
                document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table
            } else if ( flag_data_type == "InterPro" ) {
                let customdata = clicked_point.customdata; // retrieve custom data of clicked InterPro annotation
                console.log( "[plotMolecularMimicryMap] clicked record is InterPro protein annotation:", clicked_point );

                arr_data_clicked = [ ]; // empty the array containing data of the clincked record
                let url_interpro = "http://www.ebi.ac.uk/interpro/entry/InterPro/" + customdata[ 3 ] + '/';
                arr_data_clicked.push( { "Data Name": "representative virus protein", Value: customdata[ 0 ] + " from " + customdata[ 5 ] + " to " + customdata[ 6 ], URL: null, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "InterPro accession", Value: customdata[ 3 ], URL: url_interpro, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "InterPro name", Value: customdata[ 2 ], URL: url_interpro, style: "font-family:Arial" } );
                arr_data_clicked.push( { "Data Name": "Database accession", Value: customdata[ 5 ], URL: url_interpro, style: "font-family:Arial" } );
                
                DrawD3Table_for_Record_Details( arr_data_clicked );
                document.getElementById( "title_d3_table_metrics" ).innerHTML = "InterPro Protein Domain Annotation"; // update table title for 'd3_table_metrics' table
                document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table
            } else if ( flag_data_type == "vaccine_design" ) { // selection of vaccine candidate through clicking // update selected status of clicked record
                let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use the first dataset for 
                dataset.vaccine_design.interaction_mode = Retrieve_Selection_Mode_Using_Keydown_Status_VaccineDesign( ); // retrieve selection mode
                if( dataset.vaccine_design.interaction_mode == "Show_Info" ) { dataset.vaccine_design.interaction_mode = $('#radio__Vaccine_Design__Select_Mode label.active input').attr( "value" ); } // selection mode from keydown_status has a priority over selection mode from the radio button.
                if ( dataset.vaccine_design.interaction_mode == "Show_Info" ) {
                    let customdata = clicked_point.customdata; // retrieve custom data of clicked point
                    console.log( "[plotMolecularMimicryMap] clicked record is a (peptide) vaccine candidate:", clicked_point );

                    arr_data_clicked = [{ "Data Name": "header", Value: customdata[ 3 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "sequence", Value: customdata[ 4 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "aligned positions on SARS-CoV-2 proteome", Value: customdata[0] + ' from ' + customdata[1] + ' to ' + customdata[2] + ' (' + customdata[5] + ' mismatch)', URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of <b>mutated</b> proteins", Value: customdata[10], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>B-cell cross-reactive epitopes</b>", Value: customdata[ 6 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>T-cell cross-reactive MHC epitopes</b>", Value: customdata[ 7 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>MHC-I epitopes</b> (af<0.001)", Value: customdata[ 16 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of overlapped predicted <b>MHC-II epitopes</b> (af<0.001)", Value: customdata[ 17 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of <b>positive B-cell assays</b> for overlapped IEDB epitopes", Value: customdata[ 8 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "number of <b>positive T-cell assays</b> for overlapped IEDB epitopes", Value: customdata[ 9 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "Relative accessible surface area", Value: d3.format( ".1%" )( customdata[ 18 ] ), URL: null, style: "font-family:Arial" },
                                        { "Data Name": "B cell linear epitope prediction score (BepiPred)", Value: customdata[ 14 ], URL: null, style: "font-family:Arial" },
                                        { "Data Name": "MHC-I epitope processing score (MHCflurry)", Value: customdata[ 15 ], URL: null, style: "font-family:Arial" },
                                       ]; // build d3 array
                    DrawD3Table_for_Record_Details( arr_data_clicked );
                    document.getElementById( "title_d3_table_metrics" ).innerHTML = "Potential Vaccine Candidate"; // update table title for 'd3_table_metrics' table
                    document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table
                } else {
                    let bool_selected = dataset.vaccine_design.interaction_mode == "Include";
                    if ( dataset.vaccine_design.dict_data[ "selected" ][ index ] != bool_selected ) { // update graph if current status is different from previous status. 
                        dataset.vaccine_design.dict_data[ "selected" ][ index ] = bool_selected;
                        Draw_DesignedVaccineTrace( "update_selection" ); // update selection
                    }
                }
            } 
        });
        plotMolecularMimicryMap.on( 'plotly_selected', function( data ) { // selection of vaccine candidate through selection
            console.log( data );
            if ( data == undefined ) { return; }
            dataset.vaccine_design.interaction_mode = Retrieve_Selection_Mode_Using_Keydown_Status_VaccineDesign( ); // retrieve selection mode
            if( dataset.vaccine_design.interaction_mode == "Show_Info" ) { dataset.vaccine_design.interaction_mode = $('#radio__Vaccine_Design__Select_Mode label.active input').attr( "value" ); } // selection mode from keydown_status has a priority over selection mode from the radio button.
            if ( dataset.vaccine_design.interaction_mode == "Show_Info" ) { return; } // if selection_mode == "Show_Info", do not update selection
            let l_point = [ ], index_vaccine_design = dict_name_plot_to_trace_index__MolecularMimicryMap[ "vaccine_design" ], bool_selected = dataset.vaccine_design.interaction_mode == "Include";
            data.points.forEach( function( pt ) { if ( pt.curveNumber == index_vaccine_design ) { l_point.push( pt ); } } ); // retrieve selected points of the vaccine_design trace
            for ( let i = 0; i < l_point.length; i ++ ) { dataset.vaccine_design.dict_data[ "selected" ][ l_point[ i ].pointIndex ] = bool_selected; } // update selected status of selected records
            Draw_DesignedVaccineTrace( "update_selection" ) // update colors
        });
        plotMolecularMimicryMap.on( 'plotly_relayout', EventHandler_plotly_relayout_MolecularMimicryMap ); // detect zooming and resizing
        plotMolecularMimicryMap.on( 'plotly_restyle', EventHandler_plotly_restyle_MolecularMimicryMap ); 
        plotMolecularMimicryMap.on( 'plotly_autosize', function( data ) { 
            console.log( "plotMolecularMimicryMap, plotly_autosize event triggered:", data );
//             Set_Visibility_of_Consensus_Protein_Sequence( );
        });// detect resizing of plot
        Loading_Screen( false ); // remove loading screen once plot is drawn
        console.log( "[DrawMolecularMimicryMap] resolved" );
        await Adjust_Layout_MolecularMimicryMap( );
            
        console.log( "[DrawMolecularMimicryMap_for_a_human_gene] resolved" );
        resolve( );
    });
    }
                
    function SortBoxTrace( trace_a, trace_b ) { return - ( trace_a.q3 - trace_b.q3 ) } // Sort Plotly Boxplot traces based on parameter values
    function SortViolinTrace_Expression( trace_a, trace_b ) { return - ( trace_a.mean_expression_for_sorting - trace_b.mean_expression_for_sorting ) } // Sort Plotly Violin traces displaying expression values based on parameter values
//     function SortViolineTrace_Proportion( l_a, l_b ) { // Sort Plotly Violin traces displaying proportion data values based on parameter values
//         let index_value_for_sorting = ( l_a.length == 4 ) ? 6 : 3 ; // set index_of_value_for_sorting based on whether the expresion of the gene of interest (ACE2) is available (number of counts = 4 (available) and 2 (unavailable))
//         return - ( l_a[ index_value_for_sorting ] - l_b[ index_value_for_sorting ] )
//     } 
    
    function UpdatePlotExpression( ) { // update plots showing expression of genes based on collapse/show status of the containers
        if( $( "#container_expression_panel_MolecularMimicryMap" ).hasClass( "show" ) ) {
            if( $( "#container_plotly_scrnaseq" ).hasClass( "show" ) ) {
                PlotExpression_scRNA_Seq( );
            }
            if( $( "#container_plotly_gtex" ).hasClass( "show" ) ) {
                PlotExpression_GTEX( );
            }
        }
    }
    function PlotExpression_GTEX( ) { // plot violin and boxplots showing mRNA expressions of the protein of interest
        if ( object_data.flag.human_label_represents_virus ) { // when virus proteins are not used, do not draw GTEx expression plot
            return -1
        }
        let expression = object_data.main.expression,
            name_dataset = expression.name_dataset,
            index_acc_human = expression.int_index_acc_human,
            dataset = object_data.main.dataset[ name_dataset ], // retrieve dataset
            l_trace = [ ],
            gene_symbol = dataset.arr_data_acc_human[ index_acc_human ].Gene_Symbol,
            str_title_nav = "GTEx Expression of " + gene_symbol;
        
        if ( $( "#expression_panel__link_to_GTEx_portal" ).html( ) == str_title_nav ) { // if plot of the current gene of interest has been already drawn, exit the function call
            console.log( `[PlotExpression_GTEX] expression of the gene of interest ${gene_symbol} has been already drawn, exiting` );
            return -1;
        }
        $( "#expression_panel__link_to_GTEx_portal" ).html( str_title_nav ) // set label to the link to GTEx portal
        $( "#expression_panel__link_to_GTEx_portal" ).attr( "href", "https://gtexportal.org/home/gene/" + gene_symbol ); // set a link to GTEx portal
        for ( let tissue in dataset.gtex.dictdictarr ) {
            let trace = { };
            trace.lowerfence = [ dataset.gtex.dictdictarr[ tissue ][ 'MIN' ][ index_acc_human ] ];
            trace.q1 = [ dataset.gtex.dictdictarr[ tissue ][ 'Q1' ][ index_acc_human ] ];
            trace.median = [ dataset.gtex.dictdictarr[ tissue ][ 'Q2' ][ index_acc_human ] ];
            trace.q3 = [ dataset.gtex.dictdictarr[ tissue ][ 'Q3' ][ index_acc_human ] ];
            trace.upperfence = [ dataset.gtex.dictdictarr[ tissue ][ 'MAX' ][ index_acc_human ] ];
            trace.name = tissue;
            trace.line = { color: dataset.gtex.dict_name_tissue_to_color[ tissue ] }; // use pre-defined color for each tissue
            trace.type = 'box';
            trace.x0 = tissue;
            l_trace.push( trace );
        }
        l_trace = l_trace.sort( SortBoxTrace )
        Plotly.newPlot( plotGTEx, l_trace, { margin: { l: 50, r: 65, b: 90, t: 50, pad: 4 }, yaxis: { title : "TPM" } }, { ... config, filename: '3M_of_SARS-CoV-2__GTEx__Expression_of_' + dataset.arr_data_acc_human[ index_acc_human ].Gene_Symbol, height: 750, width: 1100 } ); // draw boxplot of expression of the gene using GTEx data
    }
    function Select_RemoveOptions( selectElement ) { // remove all option in the select element
       let length = selectElement.options.length - 1;
       for( let i = length; i >= 0; i -- ) {
          selectElement.remove( i );
       }
    }
    function Select_Get_Selected_Option_Using_ID( id_selectElement ) { // get selected option in the select element with its id
        let sel = document.getElementById( id_selectElement )
        return sel.options[ sel.selectedIndex ]
    }
    function PlotExpression_scRNA_Seq_get_description( record ) { // get description of the dataset of the given record 
        let text = "";
        if ( record.category_dataset == "cell_line" ) {
            text = record.label;
        } else {
            text = record.tissue;
            if ( record.label != null ) {
                text += ', ' + record.label;
            }
        }
        if ( record.category_dataset == "healthy_donors" ) {
            text += ' (' + record.publication_description.split( " (" )[ 0 ] + ')';
        }
        return text;
    }
    function PlotExpression_scRNA_Seq_Update_Select_Options( id_dataset = null ) { // update select options based on selected category_dataset and select 'id_dataset'
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        let select_name_dataset = document.getElementById( 'select__name_dataset__plotly_scrnaseq' );
        Select_RemoveOptions( select_name_dataset ); // remove all option in the select element
        let category_dataset = document.getElementById( "select__category_dataset__plotly_scrnaseq" ).value;
        dataset.scrnaseq.option.category_dataset = category_dataset;
        
        let objOption = document.createElement( "option" );
        objOption.text = "Select Dataset"; // add a default select option
        objOption.value = -1;
        select_name_dataset.options.add( objOption );
        let arr_metadata = object_data.file.dict_dir_file_to_parsed_data[ dataset.dir_folder + "scrnaseq.metadata.tsv.gz.base64.txt" ]; // add select options based on the selected 'category_dataset'
        for ( let i = 0; i < arr_metadata.length; i ++ ) {
            let record = arr_metadata[ i ];
            if ( record.category_dataset == category_dataset ) {
                let objOption = document.createElement( "option" );
                objOption.text = PlotExpression_scRNA_Seq_get_description( record );
                objOption.value = i;
                select_name_dataset.options.add( objOption );
            }
        }
        if ( category_dataset == "patient_donors" ) { // enable the toggle button if 'patient_donors' was chosen
            document.getElementById( "checkbox__covid_status__plotly_scrnaseq" ).disabled = false;
        } else { // if category_dataset is not patient_donors, disable the toggle button for plotting graphs based on covid_status
            $( "#checkbox__covid_status__plotly_scrnaseq" ).bootstrapToggle( 'on' )
            document.getElementById( "checkbox__covid_status__plotly_scrnaseq" ).disabled = true;
        }
        console.log( "[PlotExpression_scRNA_Seq_Update_Select_Options] selection options updated for " + category_dataset )
        if ( id_dataset != null ) { // if id_dataset is given, select the dataset
            for ( let opt, i = 0; opt = select_name_dataset.options[ i ]; i ++ ) {
                if ( opt.value == -1 ) { select_name_dataset.selectedIndex = i; continue; } // ignore the default select option (select default select option by default)
                if ( dataset.scrnaseq.metadata[ 'name_file' ][ parseInt( opt.value ) ] == id_dataset ) {
                    select_name_dataset.selectedIndex = i;
                    break;
                }
            }
        }
    }
    function String_Check_Substring( string, l_substring ) {
        let flag_contains_substring = false;
        string = string.toLowerCase( );
        for ( let i = 0; i < l_substring.length; i ++ ) {
            let substring = l_substring[ i ].toLowerCase( );
            if ( string.includes( substring ) ) {
                flag_contains_substring = true;
                break;
            }
        }
        return flag_contains_substring;
    }
    function PlotExpression_scRNA_Seq_Get_Color_for_name_clus( str_name_clus ) { // return color for the given str_name_clus
        str_name_clus = str_name_clus.toLowerCase( ); // convert name_clus to lower cases
        let color = "#48D1CC"
        if ( String_Check_Substring( str_name_clus, [ 'platelet' ] ) ) {
            color = "#aec2c1";
        } else if ( String_Check_Substring( str_name_clus, [ 'mast cell' ] ) ) {
            color = "#ceb3fc";
        } else if ( String_Check_Substring( str_name_clus, [ 'uninfected' ] ) ) {
            color = "#9ef274";
        } else if ( String_Check_Substring( str_name_clus, [ 'infected' ] ) ) {
            color = "#ff6b6b";
        } else if ( String_Check_Substring( str_name_clus, [ 'rbc' ] ) ) {
            color = "#fc4970";
        } else if ( String_Check_Substring( str_name_clus, [ 'lymphatic', 'endotheli', 'capillary', 'luminal' ] ) ) {
            color = "#faf75f";
        } else if ( String_Check_Substring( str_name_clus, [ 'dendritic', 'pdc', 'cdc', 'dc_', ' dcs' ] ) ) {
            color = "#64b9fa";
        } else if ( String_Check_Substring( str_name_clus, [ 'fibroblasts', 'fibs', 'mesenchyme', 'cartilage' ] ) ) {
            color = "#fa5f5f";
        } else if ( String_Check_Substring( str_name_clus, [ 'goblet', 'ciliated', 'secretory', 'ionocyte', 'club' ] ) ) {
            color = "#fce6b6";
        } else if ( String_Check_Substring( str_name_clus, [ 'alveolar', 'basal', 'squamous', 'epithelia' ] ) ) {
            color = "#ffbad9";
        } else if ( String_Check_Substring( str_name_clus, [ 'tcell', 't cell', 't_cell', 't_', 'gd t', 'cd8', 'cd4', 'treg' ] ) ) {
            color = "#b89eff";
        } else if ( String_Check_Substring( str_name_clus, [ 'lymphoid', 'hematopo', 'leukocyt', 'immuno', 'monocyte', 'neutrop', 'macro', 'b_cell', 'b cell', 'plasma cell', 'nk', 'eosinophil', 'naive' ] ) ) {
            color = "#e79eff";
        }
        return color;
    }
    async function PlotExpression_scRNA_Seq( ) { // update expression plot using scRNA-seq data
        if ( object_data.flag.human_label_represents_virus ) { // when virus proteins are not used, do not draw GTEx expression plot
            return -1
        }
        let expression = object_data.main.expression,
            name_dataset = expression.name_dataset,
            index_acc_human = expression.int_index_acc_human,
            dataset = object_data.main.dataset[ name_dataset ], // retrieve dataset
            gene_symbol = dataset.arr_data_acc_human[ index_acc_human ].Gene_Symbol,
            str_title_nav = "Single Cell Expression of " + gene_symbol;
        
        if ( document.getElementById( "expression_panel__link_to_cellxgene" ).innerHTML == str_title_nav ) { // if plot of the current gene of interest has been already drawn, exit the function call
            console.log( `[PlotExpression_scRNA_Seq] expression of the gene of interest ${gene_symbol} has been already drawn, exiting` );
            return -1;
        }
        document.getElementById( "expression_panel__link_to_cellxgene" ).innerHTML = str_title_nav; // update header label of the scrnaseq panel
        
        return new Promise( async function( resolve, reject ) { 
            // retrieve setting for the graph
            dataset.scrnaseq.option.index_dataset = parseInt( document.getElementById( "select__name_dataset__plotly_scrnaseq" ).value );
            let index_dataset = dataset.scrnaseq.option.index_dataset;
            if ( index_dataset == -1 ) { return -1; } // skip if default select option is selected
            let category_dataset = dataset.scrnaseq.option.category_dataset;
            let flag_patient_donor = category_dataset == 'patient_donors'
            console.log( "[PlotExpression_scRNA_Seq] the index of the currently chosen dataset is " + index_dataset );
            // retrieve settings
            dataset.scrnaseq.option.covid_status = ! document.getElementById( "checkbox__covid_status__plotly_scrnaseq" ).checked;
            dataset.scrnaseq.option.proportion = ! document.getElementById( "checkbox__proportion__plotly_scrnaseq" ).checked;
            dataset.scrnaseq.option.ignore_cells_with_zero_counts = ! document.getElementById( "checkbox__ignore_cells_with_zero_counts__plotly_scrnaseq" ).checked; // ignore zero_count_cells for efficient plotting
            dataset.scrnaseq.option.dir_file = dataset.dir_folder + "scrnaseq." + dataset.scrnaseq.metadata[ 'name_file' ][ index_dataset ] + ( dataset.scrnaseq.option.proportion ? ".proportion" : ".histogram" ) + ".tsv.gz.base64.txt";
            let dir_file = dataset.scrnaseq.option.dir_file;
            if ( ! ( dir_file in object_data.file.dict_dir_file_to_parsed_data ) ) { // download the current file of the dataset if it has not been already downloaded
                await LoadRemoteData( [ dir_file ] );
            }
            if ( ! ( dir_file in dataset.scrnaseq.dictdictarr ) ) { // if current file has not been preprocessed, perform preprocessing
                dataset.scrnaseq.dictdictarr[ dir_file ] = SplitColumn( Unpack_array_to_dict_data( object_data.file.dict_dir_file_to_parsed_data[ dir_file ] ) ) // retrieve dictionary-dictionary-array of scrnaseq data
            }
            let dictdictarr = dataset.scrnaseq.dictdictarr[ dir_file ], set_covid_status = { };
            // retrieve avaliable 'covid status' category values
            dataset.scrnaseq.l_name_clus = Object.keys( dictdictarr );
            let l_name_clus = dataset.scrnaseq.l_name_clus, str_separation = ( l_name_clus.length > dataset.scrnaseq.setting.thres_n_clusters_for_label_newline ) ? ' ' : '<br>'; // set 'str_separation' based on the number of cells clusters
            for ( let name_clus in dictdictarr ) {
                for ( let name_covid_status in dictdictarr[ name_clus ] ) {
                    set_covid_status[ name_covid_status ] = 1;
                }
            }
            console.log( set_covid_status )
            dataset.scrnaseq.l_covid_status = Object.keys( set_covid_status );
            let l_covid_status = dataset.scrnaseq.l_covid_status;
            dataset.scrnaseq.set_covid_status = set_covid_status;
            _ = SubsetDictDictArr( dictdictarr, dataset.scrnaseq.l_covid_status, true, 0 ); // fill empty columns with zero values
            
            let metadata_dataset = object_data.file.dict_dir_file_to_parsed_data[ dataset.dir_folder + "scrnaseq.metadata.tsv.gz.base64.txt" ][ index_dataset ];
            let description_dataset = PlotExpression_scRNA_Seq_get_description( metadata_dataset ); // retrieve description of the dataset
            
            $( "#expression_panel__link_to_cellxgene" ).attr( "href", ( flag_patient_donor ? "https://www.covid19cellatlas.org/" : metadata_dataset.link_interactive_viewer ) ); // currently cellxgene for patient_donors are currently unavailable (the address keeps changing)
            $( "#expression_panel__link_to_publication" ).attr( "href", metadata_dataset.publication_link );
            if ( ! ( dir_file in dataset.scrnaseq.dict_dir_file_to_cached_data ) ) {
                dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ] = { data: { }, metadata: { time: { } } };
            } // initialize dictionary for storing cached data
            let time_current = new Date( ).getTime( ); // get current time
            // if cached data is not available, load data into the cache. if cached data is available, used the cached data.
            if ( ! ( index_acc_human in dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].data ) ) { 
                console.log( "[PlotExpression_scRNA_Seq] cached data not available ... parsing scRNA-seq data" );
                if ( Object.keys( dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].data ).length >= dataset.scrnaseq.setting.cache.n_records ) {
                    let dict = dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].metadata.time, key_least_recently_used = -1, value_least_recently_used = -1;
                    for ( let key in dict ) {
                        if ( ( value_least_recently_used == -1 ) | ( dict[ key ] < value_least_recently_used ) ) {
                            key_least_recently_used = key;
                            dict[ key ] = value_least_recently_used;
                        }
                    } // identify the record that was least recently used.
                    // evict least recently used data
                    delete dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].data[ key_least_recently_used ];
                    delete dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].metadata.time[ key_least_recently_used ];
                } // if cache is full, evict least recently used data
                if ( ! dataset.scrnaseq.option.proportion ) { // draw expression data
                    // build list of traces for each category
                    let trace_template = { 
                        type: 'violin',
                        opacity: 0.6,
                        box: { visible: true, width: 0.075 },
                        meanline: { visible: true }
                    };
                    let l_trace = [ ], l_trace_covid_status = [ ], dict_flag_legend_shown = { }; // two lists of traces for traces for all cells and traces for each covid_status 
                    let start_histogram = dataset.scrnaseq.setting.histogram.start, step_histogram = dataset.scrnaseq.setting.histogram.step;
                    for ( let name_clus in dictdictarr ) {
                        let l_expression_reconstructed_all = [ ], l_float_mean_expression = [ 0, 0 ], l_n_cells = [ 0, 0 ], l_n_cells_with_zero_count = [ 0, 0 ];
                        for ( let name_covid_status in set_covid_status ) {
                            let entry = dictdictarr[ name_clus ][ name_covid_status ][ index_acc_human ];
                            let l_count_histogram = isNaN( entry ) ? ArrayAsInt( entry.split( ',' ) ) : [ entry ]; // parse the string into a list of counts for a histogram.
                            let n_cells = ArraySum( l_count_histogram ), n_cells_with_zero_count = l_count_histogram[ 0 ]; // retrieve number of cells for the current category
                            // retrieve a mean expression of cells for the current trace
                            let sum_expression = 0;
                            for ( let i = 0; i < l_count_histogram.length; i ++ ) {
                                sum_expression += ( start_histogram + ( i == 0 ? 0 : step_histogram * ( i - 0.5 ) ) ) * l_count_histogram[ i ];
                            }
                            let float_mean_expression = sum_expression / n_cells || 0;
                            let seed = xmur3( "molecular_mimicry_map_of_SARS-CoV-2__scRNA-Seq_expression" ), rand = mulberry32( seed( ) ); // retrieve seed for a PRNG // retrieve a function for PRNG
                            // use [ 0 ] to avoid using empty list to draw plot
                            
                            let l_expression_reconstructed = [ 0 ];
                            for ( let i = 1; i < l_count_histogram.length; i ++ ) {
                                let count = l_count_histogram[ i ], mean = start_histogram + step_histogram * ( i - 0.5 ) ;
                                for ( let j = 0; j < count; j ++ ) {
                                    l_expression_reconstructed.push( mean + ( rand( ) - 0.5 ) * step_histogram )
                                }
                            }
                           let color = "", side = "", index_label = 0;
                            if ( name_covid_status.includes( "Symptomatic" ) | name_covid_status.includes( "Positive" ) ) {
                                color = "#FF6347";
                                side = "positive";
                                index_label = 1;

                            } else {
                                color = "#00FA9A";
                                side = "negative";
                                index_label = 0;
                            }
                            l_float_mean_expression[ index_label ] = float_mean_expression;
                            l_n_cells[ index_label ] = n_cells;
                            l_n_cells_with_zero_count[ index_label ] = n_cells_with_zero_count;
                            if ( flag_patient_donor ) {
                                let l = ArrayFull( n_cells_with_zero_count, 0 );
                                l.push( ... l_expression_reconstructed );
                                let trace = { ... trace_template,
                                             x0: "",
                                             y: [ ],
                                             legendgroup: name_covid_status,
                                             scalegroup: name_clus + ' ' + name_covid_status, // each violin plot is scaled separately
                                             name: name_covid_status,
                                             side: side,
                                             showlegend: ! ( name_covid_status in dict_flag_legend_shown ), // aggregate legends (show label for each 'name_covid_status' only once)
                                             line: { color: color, width: 2 },
                                             points: false, // do not show outliers since this is reconstructed data and thus a bit inaccurate.
                                             y_ignore_cells_with_zero_counts__true: l_expression_reconstructed,
                                             y_ignore_cells_with_zero_counts__false: l, // add 0 expression values to the reconstructed values if 'dataset.scrnaseq.option.ignore_cells_with_zero_counts' is false. 
                                             n_cells: n_cells,
                                             n_cells_with_zero_count: n_cells_with_zero_count,
                                             name_clus: name_clus,
                                             mean_expression_for_sorting: float_mean_expression
                                            };
                                dict_flag_legend_shown[ name_covid_status ] = 1; // set flag
                                l_trace_covid_status.push( trace );
                            }
                            l_expression_reconstructed_all.push( ... l_expression_reconstructed );
                        }
                        if ( flag_patient_donor ) {
                            // join two numbers of cells to create a label for two joined violin plots.
                            let label_overlay = name_clus + str_separation + '(n=' + l_n_cells[ 0 ] + '/n=' + l_n_cells[ 1 ] + ')'; 
                            l_trace_covid_status[ l_trace_covid_status.length - 1 ].x0_ignore_cells_with_zero_counts__false = label_overlay;
                            l_trace_covid_status[ l_trace_covid_status.length - 2 ].x0_ignore_cells_with_zero_counts__false = label_overlay;
                            let label_overlay_ignore_cells_with_zero_counts = name_clus + str_separation + '(n=' + ( l_n_cells[ 0 ] - l_n_cells_with_zero_count[ 0 ] ) + ' of ' + l_n_cells[ 0 ] + '/n=' + ( l_n_cells[ 1 ] - l_n_cells_with_zero_count[ 1 ] ) + ' of ' + l_n_cells[ 1 ] + ')'; 
                            l_trace_covid_status[ l_trace_covid_status.length - 1 ].x0_ignore_cells_with_zero_counts__true = label_overlay_ignore_cells_with_zero_counts;
                            l_trace_covid_status[ l_trace_covid_status.length - 2 ].x0_ignore_cells_with_zero_counts__true = label_overlay_ignore_cells_with_zero_counts;
                        }
                        let n_cells_all = ArraySum( l_n_cells ), n_cells_with_zero_count_all = ArraySum( l_n_cells_with_zero_count );
                        let l = ArrayFull( n_cells_with_zero_count_all, 0 );
                        l.push( ... l_expression_reconstructed_all );
                        let trace = { ... trace_template,
                                     x0: "", 
                                     y: [ ],
                                     name: name_clus,
                                     line: { color: 'black', width: 2 },
                                     fillcolor: PlotExpression_scRNA_Seq_Get_Color_for_name_clus( name_clus ),
                                     points: false, // do not show outliers since this is reconstructed data and thus a bit inaccurate.
                                     y_ignore_cells_with_zero_counts__true: l_expression_reconstructed_all,
                                     y_ignore_cells_with_zero_counts__false: l,
                                     x0_ignore_cells_with_zero_counts__true: name_clus + str_separation + "(n=" + ( n_cells_all - n_cells_with_zero_count_all ) + ' of ' + n_cells_all + ')',
                                     x0_ignore_cells_with_zero_counts__false: name_clus + str_separation + "(n=" + n_cells_all + ')',
                                     mean_expression_for_sorting: ( flag_patient_donor ? ( l_float_mean_expression[ 0 ] * l_n_cells[ 0 ] + l_float_mean_expression[ 1 ] * l_n_cells[ 1 ] ) / n_cells_all : ArraySum( l_float_mean_expression ) )
                                    };
                        l_trace.push( trace );
                    }
                    dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].data[ index_acc_human ] = { l_trace: l_trace.sort( SortViolinTrace_Expression ), l_trace_covid_status: l_trace_covid_status.sort( SortViolinTrace_Expression ) }; // update data of the cache
                } else { // plot proportion graph using bar graph
                    let l_l_l_data = [ [ ], [ ] ], flag_gene_of_interestion_is_available = dictdictarr[ l_name_clus[ 0 ] ][ l_covid_status[ 0 ] ][ index_acc_human ].split( ',' ).length == 4; // retrieve flag indicating the number of counts are 4 or 2. Also, l_l_l_data contains index in the following order: covid_status > name_clus > [ n_cells ] + [ count data ] + [ proportion data ]
                    for ( let i = 0; i < l_covid_status.length; i ++ ) {
                        let name_covid_status = l_covid_status[ i ], index_covid_status = ( name_covid_status.includes( "Symptomatic" ) | name_covid_status.includes( "Positive" ) ) ? 1 : 0; // negative = index 0, positive = index 1.
                        for ( let j = 0; j < l_name_clus.length; j ++ ) {
                            let name_clus = l_name_clus[ j ], entry = dictdictarr[ name_clus ][ name_covid_status ][ index_acc_human ];
                            let l_count = isNaN( entry ) ? ArrayAsInt( entry.split( ',' ) ) : ( flag_gene_of_interestion_is_available ? [ 0, 0, 0, 0 ] : [ 0, 0 ] ); // parse the string, and put an empty data based on 'flag_gene_of_interestion_is_available'
                            let n_cells = ArraySum( l_count );
                            let l = [ n_cells ];
                            l.push( ... l_count );
                            l.push( ... ArrayMultiply( l_count, 1 / n_cells ) );
                            l_l_l_data[ index_covid_status ].push( l ); // each row contains [ n_cells ] + [ count data ] + [ proportion data ] of a 'name_clus'
                        }
                    }
                    console.log( l_l_l_data );
                    let l_l_data = [ ], l_trace = [ ];
                    if ( flag_patient_donor ) {
                        l_l_data = nj.array( l_l_l_data[ 1 ] ).add( l_l_l_data[ 0 ] ).tolist( ); // sum n_cells for two covid_status
                        let l_l = [ ];
                        for ( let i = 0; i < l_l_data.length; i ++ ) {
                            let l_count = l_l_data[ i ].slice( 1, 5 ), n_cells = l_l_data[ i ][ 0 ];
                            let l = [ n_cells ];
                            l.push( ... l_count );
                            l.push( ... ArrayMultiply( l_count, 1 / n_cells ) );

                            l_l.push(  ) // recalculate proportions
                        }
                        l_l_data = l_l;
                    } else {
                        l_l_data = l_l_l_data[ 0 ];
                    }
                    l_l_data = ArrayTranspose( l_l_data );
                    let l_name_trace = [ ]; // assign names of traces
                    for ( let i = 0; i < l_l_data[ 0 ].length; i ++ ) {
                        l_name_trace.push( l_name_clus[ i ] + str_separation + '(n=' + l_l_data[ 0 ][ i ] + ')' )
                    }
                    l_l_data.push( l_name_trace );
                    console.log( l_l_data );
                    let gene_of_interest = dataset.scrnaseq.setting.gene_of_interest;
                    if ( flag_gene_of_interestion_is_available ) {
                        let l_name_trace = [ 'cells positive for ' + gene_symbol + ' and ' + gene_of_interest, 'cells positive for ' + gene_symbol + ' but negative for ' + gene_of_interest, 'cells negative for ' + gene_symbol + ' but positive for ' + gene_of_interest, 'cells negative for ' + gene_symbol + ' and ' + gene_of_interest ], l_color_face = [ "#ff5736", "#ffcc5e", "#a592b0", "#bababa" ], l_color_line = [ "#a14432", "#9e8857", "#84768c", "#757575" ];
                        let arr_data = ArrayTranspose( ArrayTranspose( l_l_data ).sort( ( a, b ) => { return b[ 6 ] - a[ 6 ]; } ) ); // sort by second proportion
                        for ( let i = 0; i < 4; i ++ ) {
                            l_trace.push( { 
                                x: arr_data[ 9 ], // l_name_trace
                                y: arr_data[ i + 5 ],
                                name: l_name_trace[ i ],
                                type: 'bar',
                                marker: {
                                    color: l_color_face[ i ],
                                    opacity: 0.6,
                                    line: { color: l_color_line[ i ], width: 1.5 } }
                            } );
                        }
                    } else {
                        let l_name_trace = [ 'cells positive for ' + gene_symbol, 'cells negative for ' + gene_symbol ], l_color_face = [ "#ffcc5e", "#bababa" ], l_color_line = [ "#9e8857", "#757575" ];
                        let arr_data = ArrayTranspose( ArrayTranspose( l_l_data ).sort( ( a, b ) => { return b[ 3 ] - a[ 3 ]; } ) ); // sort by second proportion
                        for ( let i = 0; i < 2; i ++ ) {
                            l_trace.push( { 
                                x: arr_data[ 5 ], // l_name_trace
                                y: arr_data[ i + 3 ],
                                name: l_name_trace[ i ],
                                type: 'bar',
                                marker: {
                                    color: l_color_face[ i ],
                                    opacity: 0.6,
                                    line: { color: l_color_line[ i ], width: 1.5 } }
                            } );
                        }
                    }
                    dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].data[ index_acc_human ] = { l_trace: l_trace }; // update data of the cache
                }
            } else { 
                console.log( "[PlotExpression_scRNA_Seq] cached data is available ... using cached data" );
            }
            if ( ! dataset.scrnaseq.option.proportion ) { // plot expression data
                dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].metadata.time[ index_acc_human ] = time_current; // update metadata of the cache
                let layout = {
                    margin: { l: 50, r: 65, b: 120, t: 50, pad: 4 },
                    yaxis: { title : "Normalized Expression", rangemode: "nonnegative" },
                    legend: { tracegroupgap: 0 },
                    violingap: 0, // split violin plot for two covid statuses
                    violingroupgap: 0,
                    violinmode: "overlay",
                }
                let data = dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].data[ index_acc_human ];
                let l_trace = dataset.scrnaseq.option.covid_status ? data.l_trace_covid_status : data.l_trace;
                for ( let i = 0; i < l_trace.length; i ++ ) { // swap y and x0 values based on the 'dataset.scrnaseq.option.ignore_cells_with_zero_counts' setting
                    l_trace[ i ].x0 = dataset.scrnaseq.option.ignore_cells_with_zero_counts ? l_trace[ i ].x0_ignore_cells_with_zero_counts__true : l_trace[ i ].x0_ignore_cells_with_zero_counts__false ;
                    l_trace[ i ].y = dataset.scrnaseq.option.ignore_cells_with_zero_counts ? l_trace[ i ].y_ignore_cells_with_zero_counts__true : l_trace[ i ].y_ignore_cells_with_zero_counts__false ;
                }
                Plotly.newPlot( plotscrnaseq, l_trace, layout, { ... config, filename: '3M_of_SARS-CoV-2__scRNA_seq__' + metadata_dataset.tissue + '__Expression_of_' + gene_symbol, height: 750, width: 1100 } );
            } else { // plot proportion data
                dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].metadata.time[ index_acc_human ] = time_current; // update metadata of the cache
                let layout = { barmode: 'stack',
                               margin: { l: 50, r: 65, b: 120, t: 50, pad: 4 },
                               yaxis: { title : "Proportion of cells in each cluster", range: [ 0, 1 ] }, };
                let data = dataset.scrnaseq.dict_dir_file_to_cached_data[ dir_file ].data[ index_acc_human ];
                Plotly.newPlot( plotscrnaseq, data.l_trace, layout, { ... config, filename: '3M_of_SARS-CoV-2__scRNA_seq__' + metadata_dataset.tissue + '__Proportion_of_' + gene_symbol, height: 750, width: 1100 } );
            }
        }); 
    }
    async function ClickCallBack_BCellCrossReactivity( index ) { // a click callback function for a B-cell cross reactivity prediction result
        let name_dataset = object_plot_BCellCrossReactivity.dict_data[ "name_dataset" ][ index ],
            dataset = object_data.main.dataset[ name_dataset ]; // retrieve namespace for a dataset
        Toggle_Exclusive_Tabs( "hide_all" ); // hide all supplementary tabs
        clicked_record = object_plot_BCellCrossReactivity.arr_data[ index ]; // retrieve a clicked record
        object_data.main.expression = { name_dataset: name_dataset, int_index_acc_human: clicked_record.query_accession }; // setting for showing expression of a gene of interest
        UpdatePlotExpression( ); // Plot mRNA expression data
        console.log( "[plotMolecularMimicryMap] clicked record belongs to BCellCrossReactivity data:", clicked_record );
        arr_data_clicked = [ ]; // empty the array containing data of the clincked record
        // define tag of datatypes
        let str_tag_human = ( object_data.flag.human_label_represents_virus ) ? "Coronavirus" : "Human",
            str_tag_virus = ( object_data.flag.human_label_represents_virus ) ? "SARS-CoV-2" : "Virus";
        if ( object_data.flag.alignment_to_virus ) { // add information of representative virus protein
            let representative_virus_protein = dataset.arr_data_acc_virus_representative[ clicked_record.representative_accession ];
            arr_data_clicked.push( { "Data Name": `[${str_tag_virus}] representative protein`, Value: representative_virus_protein.name + " (" + representative_virus_protein.accession + ") from " + clicked_record.target_representative_start + " to " + clicked_record.target_representative_end, URL: "https://www.ncbi.nlm.nih.gov/protein/" + representative_virus_protein.accession } );
        }
        if ( ! object_data.flag.human_label_represents_virus ) {
            arr_data_clicked.push( { "Data Name": `[${str_tag_human}] protein name`, Value: dataset.arr_data_acc_human[ clicked_record.query_accession ].name, URL: "https://www.google.com/search?q=" + dataset.arr_data_acc_human[ clicked_record.query_accession ].description.split( "OS=" )[ 0 ] } ); // add human protein description with a link to a google search
        }
        arr_data_clicked.push( { "Data Name": `[${str_tag_virus}] protein accession`, Value: dataset.arr_data_acc_virus[ clicked_record.target_accession ].value + " from " + clicked_record.target_start + " to " + clicked_record.target_end, URL: ( ( name_dataset.includes( "gisaid" ) ) ? "https://www.gisaid.org/" : "https://www.ncbi.nlm.nih.gov/protein/" + dataset.arr_data_acc_virus[ clicked_record.target_accession ].value ) } ); 
        arr_data_clicked.push( { "Data Name": `[${str_tag_human}] protein accession`, Value: dataset.arr_data_acc_human[ clicked_record.query_accession ].value + " from " + clicked_record.query_start + " to " + clicked_record.query_end, URL: ( ( object_data.flag.human_label_represents_virus ) ? "https://www.ncbi.nlm.nih.gov/protein/" : "https://www.uniprot.org/uniprot/" ) + dataset.arr_data_acc_human[ clicked_record.query_accession ].value } );
        let flag_structure_exist_for_human_sequence = clicked_record.structure_id_query != -1, 
            flag_structure_exist_for_virus_sequence = clicked_record.structure_id_target != -1, // retrieve flag for structure property data availability for human and virus sequence
            str_label_human = `${str_tag_human} (----)`, // default labels
            str_label_virus = `${str_tag_virus} (----)`,
            tag_pdb_human = document.getElementById( "text_protein_structure_human" ),
            tag_pdb_virus = document.getElementById( "text_protein_structure_virus" );

        if ( flag_structure_exist_for_virus_sequence ) { 
            let str_id_pdb = dataset.arr_data_acc_pdb[ clicked_record.structure_id_target ].id_pdb.toUpperCase( ),
                url_pdb = ( str_id_pdb.includes( "_SOURCE_" ) ) ? `${object_data.file.base_url}data/custom_cif/${str_id_pdb}.cif` : "https://www.rcsb.org/structure/" + str_id_pdb; // update link to protein structure (for both modeling results and pdb structures)
            
            arr_data_clicked.push( { "Data Name": `[${str_tag_virus}] PDB structure`, Value: dataset.arr_data_acc_pdb[ clicked_record.structure_id_target ].value + " (" + dataset.arr_data_acc_virus[ clicked_record.target_accession ].value + " from " + clicked_record.target_structure_start + " to " + clicked_record.target_structure_end + ")", URL: url_pdb, style: "font-family:Arial" } );
            str_label_virus = `${str_tag_virus} (${str_id_pdb})`; // update protein id label (to increse interactivity)
            tag_pdb_virus.href = url_pdb;
        } else {
            arr_data_clicked.push( { "Data Name": `[${str_tag_virus}] PDB structure`, Value: "unavailable", URL: null, style: "font-family:Arial" } );
            tag_pdb_virus.removeAttribute( 'href' );
        }
        if ( flag_structure_exist_for_human_sequence ) { 
            let str_id_pdb = dataset.arr_data_acc_pdb[ clicked_record.structure_id_query ].id_pdb.toUpperCase( ),
                url_pdb = ( str_id_pdb.includes( "_SOURCE_" ) ) ? `${object_data.file.base_url}data/custom_cif/${str_id_pdb}.cif` : "https://www.rcsb.org/structure/" + str_id_pdb; // update link to protein structure (for both modeling results and pdb structures)
            
            arr_data_clicked.push( { "Data Name": `[${str_tag_human}] PDB structure`, Value: dataset.arr_data_acc_pdb[ clicked_record.structure_id_query ].value + " (" + dataset.arr_data_acc_human[ clicked_record.query_accession ].value + " from " + clicked_record.query_structure_start + " to " + clicked_record.query_structure_end + ")", URL: url_pdb, style: "font-family:Arial" } );
            str_label_human = `${str_tag_human} (${str_id_pdb})`; // update protein id label (to increse interactivity)
            tag_pdb_human.href = url_pdb;
        } else {
            arr_data_clicked.push( { "Data Name": `[${str_tag_human}] PDB structure`, Value: "unavailable", URL: null, style: "font-family:Arial" } );
            tag_pdb_human.removeAttribute( 'href' );
        }
        tag_pdb_human.innerText = str_label_human
        tag_pdb_virus.innerText = str_label_virus

        arr_data_clicked.push( { "Data Name": "E-value (significance) of full-length alignment", Value: clicked_record.e_value, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "identity (similarity) of full-length alignment", Value: clicked_record.identity, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "number of redundant alignments", Value: clicked_record.duplicate_counts, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "correl. coeffi. of accessibility (p-value)", Value: clicked_record.correl_coeffi_acc + " (" + String( clicked_record.correl_p_value_acc ) + ")", URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "correl. coeffi. of torsion angle (phi) (p-value)", Value: clicked_record.correl_coeffi_phi + " (" + String( clicked_record.correl_p_value_phi ) + ")", URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "correl. coeffi. of torsion angle (psi) (p-value)", Value: clicked_record.correl_coeffi_psi + " (" + String( clicked_record.correl_p_value_psi ) + ")", URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "score_blosum", Value: clicked_record.score_blosum, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "score_blosum_weighted", Value: clicked_record.score_blosum_weighted, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "score_similarity_ss8", Value: clicked_record.score_similarity_ss8, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "prop_pdb_evidence_query", Value: clicked_record.prop_pdb_evidence_query, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "prop_pdb_evidence_target", Value: clicked_record.prop_pdb_evidence_target, URL: null, style: "font-family:Arial" } );
        arr_data_clicked.push( { "Data Name": "sum_of_weights", Value: clicked_record.sum_of_weights, URL: null, style: "font-family:Arial" } );

        DrawD3Table_for_Record_Details( arr_data_clicked );
        document.getElementById( "title_d3_table_metrics" ).innerHTML = "B-Cell Cross-Reactivity Prediction data"; // update table title for 'd3_table_metrics' table
        document.getElementById( "footnote_d3_table_metrics" ).innerHTML = ""; // update table footnote for 'd3_table_metrics' table

        // draw interactive table displaying structural properties of aligned regions
        let alignment_BCellCrossReactivity = dataset.arr_data_alignment_human_virus[ clicked_record.id_alignment ], structure_property_human_protein = dataset.arr_data_structural_property_human[ clicked_record.query_accession ], structure_property_virus_protein = dataset.arr_data_structural_property_virus[ clicked_record.target_accession ];
        let alignment_start = clicked_record.alignment_start - 1, alignment_end = clicked_record.alignment_end, query_start = clicked_record.query_start - 1, query_end = clicked_record.query_end, target_start = clicked_record.target_start - 1, target_end = clicked_record.target_end; // 1-based coordinates to 0-based coordinates // initial start and end positions
        let len_discarded_sequence_alignment = RetrieveDiscardedLength( alignment_BCellCrossReactivity.discarded_regions, alignment_start ), len_discarded_sequence_human = RetrieveDiscardedLength( structure_property_human_protein.discarded_regions, query_start ), len_discarded_sequence_virus = RetrieveDiscardedLength( structure_property_virus_protein.discarded_regions, target_start );
        alignment_start -= len_discarded_sequence_alignment; alignment_end -= len_discarded_sequence_alignment; query_start -= len_discarded_sequence_human; query_end -= len_discarded_sequence_human; target_start -= len_discarded_sequence_virus; target_end -= len_discarded_sequence_virus; // retrieve coordinates excluding discarded regions
        let query_aligned_sequence = alignment_BCellCrossReactivity.query_alignment__compact__for_web_application.slice( alignment_start, alignment_end ), target_aligned_sequence = alignment_BCellCrossReactivity.target_alignment__compact__for_web_application.slice( alignment_start, alignment_end );
        let len_alignment = query_aligned_sequence.length;
        let structure_property_human_sequence = { }, structure_property_virus_sequence = { }; // retrieve and parse structural property of aligned sequences
        structure_property_human_sequence.rsa = Unpack_String_rsa( structure_property_human_protein[ "rsa_combined___ascii_encoding_1_character_from_33_to_126__from_0_to_1__for_web_application__compact__for_web_application" ].slice( query_start, query_end ) )
        structure_property_human_sequence.ss8 = Unpack_String_ss8( structure_property_human_protein[ "ss8_combined___ascii_encoding_1_character_from_33_to_41__states_G_H_I_E_B_T_S_C__compact__for_web_application" ].slice( query_start, query_end ) )
        structure_property_human_sequence.datatype = Unpack_String_datatype( structure_property_human_protein[ "rsa_datatype_combined___ascii_encoding_1_character_from_33_to_36__states_Pred_Model_PDB__compact__for_web_application" ].slice( query_start, query_end ) )
        if ( flag_structure_exist_for_human_sequence ) { 
            structure_property_human_sequence.phi = Unpack_String_torsion_angle( structure_property_human_protein[ ( object_data.flag.human_label_represents_virus ) ? "phi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" : "phi___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( query_start, query_end ) );
            structure_property_human_sequence.psi = Unpack_String_torsion_angle( structure_property_human_protein[ ( object_data.flag.human_label_represents_virus ) ? "psi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" : "psi___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( query_start, query_end ) );
            structure_property_human_sequence.structure_id = Unpack_String_structure_id( structure_property_human_protein[ "structure_id__compact__for_web_application" ] ).slice( query_start, query_end );
        }
        structure_property_virus_sequence.rsa = Unpack_String_rsa( structure_property_virus_protein[ "rsa_combined___ascii_encoding_1_character_from_33_to_126__from_0_to_1__for_web_application__compact__for_web_application" ].slice( target_start, target_end ) )
        structure_property_virus_sequence.ss8 = Unpack_String_ss8( structure_property_virus_protein[ "ss8_combined___ascii_encoding_1_character_from_33_to_41__states_G_H_I_E_B_T_S_C__compact__for_web_application" ].slice( target_start, target_end ) )
        structure_property_virus_sequence.datatype = Unpack_String_datatype( structure_property_virus_protein[ "rsa_datatype_combined___ascii_encoding_1_character_from_33_to_36__states_Pred_Model_PDB__compact__for_web_application" ].slice( target_start, target_end ) )
        if ( flag_structure_exist_for_virus_sequence ) { 
            structure_property_virus_sequence.phi = Unpack_String_torsion_angle( structure_property_virus_protein[ "phi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( target_start, target_end ) );
            structure_property_virus_sequence.psi = Unpack_String_torsion_angle( structure_property_virus_protein[ "psi_combined___ascii_encoding_1_character_from_33_to_126__from_-180_to_180__for_web_application__compact__for_web_application" ].slice( target_start, target_end ) );
            structure_property_virus_sequence.structure_id = Unpack_String_structure_id( structure_property_virus_protein[ "structure_id__compact__for_web_application" ] ).slice( target_start, target_end );
        }
        // represent structural property with color 
        structure_property_human_sequence.color_rsa = Color_for_rsa( structure_property_human_sequence.rsa )
        structure_property_human_sequence.color_ss8 = Color_for_ss8( structure_property_human_sequence.ss8 )
        structure_property_human_sequence.color_datatype = Color_for_datatype( structure_property_human_sequence.datatype )
        if ( flag_structure_exist_for_human_sequence ) { 
            structure_property_human_sequence.color_phi = Color_for_torsion_angle( structure_property_human_sequence.phi )
            structure_property_human_sequence.color_psi = Color_for_torsion_angle( structure_property_human_sequence.psi )
            structure_property_human_sequence.color_structure_id = Color_for_structure_id( structure_property_human_sequence.structure_id )
        }

        structure_property_virus_sequence.color_rsa = Color_for_rsa( structure_property_virus_sequence.rsa )
        structure_property_virus_sequence.color_ss8 = Color_for_ss8( structure_property_virus_sequence.ss8 )
        structure_property_virus_sequence.color_datatype = Color_for_datatype( structure_property_virus_sequence.datatype )
        if ( flag_structure_exist_for_virus_sequence ) { 
            structure_property_virus_sequence.color_phi = Color_for_torsion_angle( structure_property_virus_sequence.phi )
            structure_property_virus_sequence.color_psi = Color_for_torsion_angle( structure_property_virus_sequence.psi )
            structure_property_virus_sequence.color_structure_id = Color_for_structure_id( structure_property_virus_sequence.structure_id )
        }

        // align retrieved structure property using the alignment
        structure_property_human_sequence = Align_Structural_Property( structure_property_human_sequence, query_aligned_sequence );
        structure_property_virus_sequence = Align_Structural_Property( structure_property_virus_sequence, target_aligned_sequence );
        structure_property_human_sequence.seq = query_aligned_sequence.split( "" ); // add aligned sequence to the data
        structure_property_virus_sequence.seq = target_aligned_sequence.split( "" );
        let l_score_blosum = [ ], l_score_blosum_human = [ ], l_score_blosum_virus = [ ], pos_virus = clicked_record.target_start - 1, pos_human = clicked_record.query_start - 1;
        object_pdb_human.dict_index_alignment_to_pos_human = { }, object_pdb_virus.dict_index_alignment_to_pos_virus = { };
        for ( let i = 0; i < query_aligned_sequence.length; i ++ ) { 
            let score_blosum62 = Math.round( object_data.main.dict_blosum62[ query_aligned_sequence[ i ] + target_aligned_sequence[ i ] ] ), residue_human = query_aligned_sequence[ i ], residue_virus = target_aligned_sequence[ i ]; // round the blosum score so that step become 1
            l_score_blosum.push( score_blosum62 );
            // retrieve blosum score for human and virus sequence
            if ( residue_human == '-' ) {
                pos_virus += 1;
                l_score_blosum_virus.push( score_blosum62 );
                object_pdb_virus.dict_index_alignment_to_pos_virus[ i ] = pos_virus;
            } else if ( residue_virus == '-' ) {
                pos_human += 1;
                l_score_blosum_human.push( score_blosum62 );
                object_pdb_human.dict_index_alignment_to_pos_human[ i ] = pos_human;
            } else {
                pos_human += 1; pos_virus += 1;
                l_score_blosum_human.push( score_blosum62 );
                l_score_blosum_virus.push( score_blosum62 );
                object_pdb_virus.dict_index_alignment_to_pos_virus[ i ] = pos_virus;
                object_pdb_human.dict_index_alignment_to_pos_human[ i ] = pos_human;
            }
        }
        let l_color_score_blosum = Color_for_score_blosum( l_score_blosum ), l_color_score_blosum_human = Color_for_score_blosum( l_score_blosum_human ), l_color_score_blosum_virus = Color_for_score_blosum( l_score_blosum_virus ); // retrieve colors for blosum scores

        console.log( "structural property human sequence:", structure_property_human_sequence );
        console.log( "structural property virus sequence:", structure_property_virus_sequence );
        // draw Plotly table for aligned sequences
        object_data_tableSequence.flag_data_type = "B-Cell";
        let colors = [ ], values = [ ], header = [ ], l_col = [ ];
        if ( flag_structure_exist_for_virus_sequence ) { 
            l_col.push( ... [ `${str_tag_virus}<br>structure_id`, `${str_tag_virus}<br>psi`, `${str_tag_virus}<br>phi` ] );
            values.push( ... [ structure_property_virus_sequence.structure_id, structure_property_virus_sequence.psi, structure_property_virus_sequence.phi ] );
            colors.push( ... [ structure_property_virus_sequence.color_structure_id, structure_property_virus_sequence.color_psi, structure_property_virus_sequence.color_phi ] );
        }
        l_col.push( ... [ `${str_tag_virus}<br>datatype`, `${str_tag_virus}<br>ss8`, `${str_tag_virus}<br>rsa`, `${str_tag_virus}<br>seq` ] );
        values.push( ... [ structure_property_virus_sequence.datatype, structure_property_virus_sequence.ss8, structure_property_virus_sequence.rsa, structure_property_virus_sequence.seq ] );
        colors.push( ... [ structure_property_virus_sequence.color_datatype, structure_property_virus_sequence.color_ss8, structure_property_virus_sequence.color_rsa, ArrayFull( len_alignment, "#ffffff" ) ] );
        l_col.push( 'BLOSUM62' );
        values.push( l_score_blosum );
        colors.push( l_color_score_blosum );
        l_col.push( ... [ `${str_tag_human}<br>seq`, `${str_tag_human}<br>rsa`, `${str_tag_human}<br>ss8`, `${str_tag_human}<br>datatype` ] );
        values.push( ... [ structure_property_human_sequence.seq, structure_property_human_sequence.rsa, structure_property_human_sequence.ss8, structure_property_human_sequence.datatype ] );
        colors.push( ... [ ArrayFull( len_alignment, "#ffffff" ), structure_property_human_sequence.color_rsa, structure_property_human_sequence.color_ss8, structure_property_human_sequence.color_datatype ] );
        if ( flag_structure_exist_for_human_sequence ) { 
            l_col.push( ... [ `${str_tag_human}<br>phi`, `${str_tag_human}<br>psi`, `${str_tag_human}<br>structure_id` ] );
            values.push( ... [ structure_property_human_sequence.phi, structure_property_human_sequence.psi, structure_property_human_sequence.structure_id ] );
            colors.push( ... [ structure_property_human_sequence.color_phi, structure_property_human_sequence.color_psi, structure_property_human_sequence.color_structure_id ] );
        }
        for ( let i = 0; i < l_col.length; i ++ ) { header.push( [ "<b>" + l_col[ i ] + "</b>" ] ); } // build header from 'l_col'
        let data = [{
            type: 'table', 
            header: { values: header, align: "center", height: 30, line: {width: 1, color: '#506784'}, fill: {color: '#f0f0f0'}, font: {family: "Arial", size: 12, color: "black"} },
            cells: {values: values, align: "center", height: 20, line: {color: colors, width: 1}, fill: {color: colors }, font: {family: "Arial", size: 12, color: ["#3d3d3d"] }}
        }]

        document.getElementById( "plotly_table_sequence" ).style.height = String( Math.min( 20 * int_n_residues_per_window_table_sequence + 30 + 10, parseInt( l_score_blosum.length * 20 + 30 + 10 ) ) ) + "px" // set height of table according to the length of alignment # max height is 640
        object_data_tableSequence.len_alignment = l_score_blosum.length; // retrieve the length of the alignment
        str_jquery_container = "#container_plotly_table_sequence";
        if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { Plotly.newPlot( tableSequence, data, lodash.cloneDeep( layout_tableSequence ), config_MolecularMimicryMap ); Add_Click_Callback_Aligned_Sequence_Table( ); // draw Plotly plot synchronously if the container is currently shown
        } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { Plotly.newPlot( tableSequence, data, lodash.cloneDeep( layout_tableSequence ), config_MolecularMimicryMap ); Add_Click_Callback_Aligned_Sequence_Table( ); } ); } // draw Plotly plot once the container is shown if the container is currently hidden

        // Render molecular structures using the Mol* JS application
		str_url_coordinate_server = "https://webchem.ncbr.muni.cz/CoordinateServer/"
        str_jquery_container = "#container_PDB";
        let pos_protein = 0, pos_pdb = 0;
        if ( flag_structure_exist_for_human_sequence ) { 
            object_pdb_human = Object.assign( object_pdb_human, dataset.arr_data_acc_pdb[ clicked_record.structure_id_query ] );
            object_pdb_human.id_chain = String( object_pdb_human.id_chain ) // 'auth_asym_id' should be a string
            object_pdb_human.start_pdb = clicked_record.structure_id_query_start;
            object_pdb_human.end_pdb = clicked_record.structure_id_query_end;
            object_pdb_human.alignment = { data: dataset.arr_data_alignment_human_pdb[ clicked_record.id_alignment_structure_query ], start: clicked_record.alignment_structure_query_start - 1, end: clicked_record.alignment_structure_query_end } // retrieve alignment data // 0-based coordinates
            object_pdb_human.alignment.data.len_discarded_sequence = RetrieveDiscardedLength( object_pdb_human.alignment.data.discarded_regions, object_pdb_human.alignment.start );
            object_pdb_human.alignment.start -= object_pdb_human.alignment.data.len_discarded_sequence;
            object_pdb_human.alignment.end -= object_pdb_human.alignment.data.len_discarded_sequence;
            object_pdb_human.aligned_sequence_pdb = object_pdb_human.alignment.data.target_alignment__compact__for_web_application.slice( object_pdb_human.alignment.start, object_pdb_human.alignment.end );
            object_pdb_human.aligned_sequence_protein = object_pdb_human.alignment.data.query_alignment__compact__for_web_application.slice( object_pdb_human.alignment.start, object_pdb_human.alignment.end );
            object_pdb_human.start_protein = clicked_record.query_structure_start;
            object_pdb_human.end_protein = clicked_record.query_structure_end;
            object_pdb_human.l_color_score_blosum_protein = l_color_score_blosum_human.slice( clicked_record.query_start - clicked_record.query_structure_start, l_color_score_blosum_human.length - ( clicked_record.query_end - clicked_record.query_structure_end ) );

            object_pdb_human.dict_pos_human_to_pos_pdb_human = { }, object_pdb_human.dict_index_alignment_to_pos_pdb_human = { };
            pos_protein = - 1, pos_pdb = object_pdb_human.start_pdb - 1, object_pdb_human.l_color_score_blosum_pdb = [ ];
            for ( let i = 0; i < object_pdb_human.aligned_sequence_pdb.length; i ++ ) {
                if ( object_pdb_human.aligned_sequence_pdb[ i ] == '-' ) { 
                    pos_protein += 1;
                    object_pdb_human.dict_pos_human_to_pos_pdb_human[ pos_protein + object_pdb_human.start_protein ] = pos_pdb;
                }
                else if ( object_pdb_human.aligned_sequence_protein[ i ] == '-' ) { 
                    pos_pdb += 1;
                    object_pdb_human.l_color_score_blosum_pdb.push( null );
                } // if there is a gap in the protein (so the residue in pdb does not exist in the protein sequence, push null value representing an invalid color)
                else { 
                    pos_protein += 1; pos_pdb += 1;
                    object_pdb_human.l_color_score_blosum_pdb.push( object_pdb_human.l_color_score_blosum_protein[ pos_protein ] );
                    object_pdb_human.dict_pos_human_to_pos_pdb_human[ pos_protein + object_pdb_human.start_protein ] = pos_pdb;
                }
            }
            for ( let i = 0; i < object_data_tableSequence.len_alignment; i ++ ) {
                object_pdb_human.dict_index_alignment_to_pos_pdb_human[ i ] = object_pdb_human.dict_pos_human_to_pos_pdb_human[ object_pdb_human.dict_index_alignment_to_pos_human[ i ] ];
            }
            object_pdb_human.option_update = { landscape: true, bgColor: {r:255,g:255,b:255}, hideControls: true, hideStructure: [ 'water', 'carbs' ] };
            if ( object_pdb_human.value.includes( "_source_" ) ) { object_pdb_human.option_update.customData = { url: object_data.file.base_url + "data/custom_cif/" + object_pdb_human.value + ".cif", format: 'cif', binary: false }; } // if structure is structural model, retrieve data from github
            else { // use coordinate server to retrieve coordinates of a specific chain if the structure belongs to RCSB PDB db
                object_pdb_human.option_update.customData = { url: str_url_coordinate_server + object_pdb_human.id_pdb + "/chains?entityId=" + object_pdb_human.id_entity + "&authAsymId=" + object_pdb_human.id_chain + "&encoding=bcif", binary: true, format: 'cif' }; 
                if ( object_pdb_human.id_model != null ) { object_pdb_human.option_update.customData.url += "&modelId=" + object_pdb_human.id_model; } // use id_model to retrieve specific coordinates if it is available
            } 
            object_pdb_human.selection_showing_side_chain = [ ], object_pdb_human.selection = [ ];
            for ( let i = 0; i < object_pdb_human.l_color_score_blosum_pdb.length; i ++ ) {
                let color = object_pdb_human.l_color_score_blosum_pdb[ i ], pos = object_pdb_human.start_pdb + i;
                if ( color === null ) { continue; }
                object_pdb_human.selection_showing_side_chain.push( { auth_asym_id: object_pdb_human.id_chain, start_residue_number: pos, end_residue_number: pos, sideChain: true, color: color } );
                object_pdb_human.selection.push( { auth_asym_id: object_pdb_human.id_chain, start_residue_number: pos, end_residue_number: pos, color: color } );
            }
            object_pdb_human.bool_flag_selected = false, object_pdb_human.bool_flag_focused = false; // set viewer setting
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
                pdbHumanProtein.visual.update( object_pdb_human.option_update );
                MolStarRenderCompletePromise( pdbHumanProtein ).then( Select_View_of_PDB_Human_Protein ); // render coordinates synchronously if the container is currently shown // then select the subsequence once loading is completed
            } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                pdbHumanProtein.visual.update( object_pdb_human.option_update );
                MolStarRenderCompletePromise( pdbHumanProtein ).then( Select_View_of_PDB_Human_Protein );
            } ); } // render coordinates once the container is shown if the container is currently hidden // then select the subsequence once loading is completed
        } else {  // show dummy if coordinates are not available
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { // render coordinates synchronously if the container is currently shown
                pdbHumanProtein.visual.update( option_initialization_molstar );
            } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                pdbHumanProtein.visual.update( option_initialization_molstar );
            } ); } // render coordinates once the container is shown if the container is currently hidden
        }
        if ( flag_structure_exist_for_virus_sequence ) { 
            object_pdb_virus = Object.assign( object_pdb_virus, dataset.arr_data_acc_pdb[ clicked_record.structure_id_target ] );
            object_pdb_virus.id_chain = String( object_pdb_virus.id_chain ) // 'auth_asym_id' should be a string
            object_pdb_virus.start_pdb = clicked_record.structure_id_target_start;
            object_pdb_virus.end_pdb = clicked_record.structure_id_target_end;
            object_pdb_virus.alignment = { data: dataset.arr_data_alignment_virus_pdb[ clicked_record.id_alignment_structure_target ], start: clicked_record.alignment_structure_target_start - 1, end: clicked_record.alignment_structure_target_end } // retrieve alignment data // 0-based coordinates
            object_pdb_virus.alignment.data.len_discarded_sequence = RetrieveDiscardedLength( object_pdb_virus.alignment.data.discarded_regions, object_pdb_virus.alignment.start );
            object_pdb_virus.alignment.start -= object_pdb_virus.alignment.data.len_discarded_sequence;
            object_pdb_virus.alignment.end -= object_pdb_virus.alignment.data.len_discarded_sequence;
            object_pdb_virus.aligned_sequence_pdb = object_pdb_virus.alignment.data.target_alignment__compact__for_web_application.slice( object_pdb_virus.alignment.start, object_pdb_virus.alignment.end );
            object_pdb_virus.aligned_sequence_protein = object_pdb_virus.alignment.data.target_alignment__compact__for_web_application.slice( object_pdb_virus.alignment.start, object_pdb_virus.alignment.end );
            object_pdb_virus.start_protein = clicked_record.target_structure_start;
            object_pdb_virus.end_protein = clicked_record.target_structure_end;
            object_pdb_virus.l_color_score_blosum_protein = l_color_score_blosum_virus.slice( clicked_record.target_start - clicked_record.target_structure_start, l_color_score_blosum_virus.length - ( clicked_record.target_end - clicked_record.target_structure_end ) );

            object_pdb_virus.dict_pos_virus_to_pos_pdb_virus = { }, object_pdb_virus.dict_index_alignment_to_pos_pdb_virus = { };
            pos_protein = - 1, pos_pdb = object_pdb_virus.start_pdb - 1, object_pdb_virus.l_color_score_blosum_pdb = [ ];
            for ( let i = 0; i < object_pdb_virus.aligned_sequence_pdb.length; i ++ ) {
                if ( object_pdb_virus.aligned_sequence_pdb[ i ] == '-' ) { 
                    pos_protein += 1;
                    object_pdb_virus.dict_pos_virus_to_pos_pdb_virus[ pos_protein + object_pdb_virus.start_protein ] = pos_pdb;
                }
                else if ( object_pdb_virus.aligned_sequence_protein[ i ] == '-' ) { 
                    pos_pdb += 1;
                    object_pdb_virus.l_color_score_blosum_pdb.push( null );
                } // if there is a gap in the protein (so the residue in pdb does not exist in the protein sequence, push null value representing an invalid color)
                else { 
                    pos_protein += 1; pos_pdb += 1;
                    object_pdb_virus.l_color_score_blosum_pdb.push( object_pdb_virus.l_color_score_blosum_protein[ pos_protein ] );
                    object_pdb_virus.dict_pos_virus_to_pos_pdb_virus[ pos_protein + object_pdb_virus.start_protein ] = pos_pdb;
                }
            }
            for ( let i = 0; i < object_data_tableSequence.len_alignment; i ++ ) {
                object_pdb_virus.dict_index_alignment_to_pos_pdb_virus[ i ] = object_pdb_virus.dict_pos_virus_to_pos_pdb_virus[ object_pdb_virus.dict_index_alignment_to_pos_virus[ i ] ];
            }
            object_pdb_virus.option_update = { landscape: true, bgColor: {r:255,g:255,b:255}, hideControls: true, hideStructure: [ 'water', 'carbs' ] };
            if ( object_pdb_virus.value.includes( "_source_" ) ) { object_pdb_virus.option_update.customData = { url: object_data.file.base_url + "data/custom_cif/" + object_pdb_virus.value + ".cif", format: 'cif', binary: false }; } // if structure is structural model, retrieve data from github
            else { // use coordinate server to retrieve coordinates of a specific chain if the structure belongs to RCSB PDB db
                object_pdb_virus.option_update.customData = { url: str_url_coordinate_server + object_pdb_virus.id_pdb + "/chains?entityId=" + object_pdb_virus.id_entity + "&authAsymId=" + object_pdb_virus.id_chain + "&encoding=bcif", binary: true, format: 'cif' }; 
                if ( object_pdb_virus.id_model != null ) { object_pdb_virus.option_update.customData.url += "&modelId=" + object_pdb_virus.id_model; } // use id_model to retrieve specific coordinates if it is available
            } 
            object_pdb_virus.selection_showing_side_chain = [ ], object_pdb_virus.selection = [ ];
            for ( let i = 0; i < object_pdb_virus.l_color_score_blosum_pdb.length; i ++ ) {
                let color = object_pdb_virus.l_color_score_blosum_pdb[ i ], pos = object_pdb_virus.start_pdb + i;
                if ( color === null ) { continue; }
                object_pdb_virus.selection_showing_side_chain.push( { auth_asym_id: object_pdb_virus.id_chain, start_residue_number: pos, end_residue_number: pos, sideChain: true, color: color } );
                object_pdb_virus.selection.push( { auth_asym_id: object_pdb_virus.id_chain, start_residue_number: pos, end_residue_number: pos, color: color } );
            }
            object_pdb_virus.bool_flag_selected = false, object_pdb_virus.bool_flag_focused = false; // set viewer setting
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
                pdbVirusProtein.visual.update( object_pdb_virus.option_update );
                MolStarRenderCompletePromise( pdbVirusProtein ).then( Select_View_of_PDB_Virus_Protein ); // render coordinates synchronously if the container is currently shown // then select the subsequence once loading is completed
            } else { 
                BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                    pdbVirusProtein.visual.update( object_pdb_virus.option_update );
                    MolStarRenderCompletePromise( pdbVirusProtein ).then( Select_View_of_PDB_Virus_Protein );
                } );
            } // render coordinates once the container is shown if the container is currently hidden // then select the subsequence once loading is completed
        } else {  // show dummy if coordinates are not available
            if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
                pdbVirusProtein.visual.update( option_initialization_molstar ); // render coordinates synchronously if the container is currently shown
            } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { 
                pdbVirusProtein.visual.update( option_initialization_molstar );
            } ); } // render coordinates once the container is shown if the container is currently hidden
        }
        document.getElementById( "description_clicked_position__table_sequence" ).innerHTML = "";
    }
    
    var color_pdb_highlight = {r:255,g:255,b:0};
    function Highlight_PDB_Residue__Click_Callback__Aligned_Sequence_Table( event ) {
        let height_cell_value = 20, height_cell_header = 47, n_extra_pixels = 4; // it seems a couple of extra pixels added to the top of the slider. To account this, the silder height will be expanded by 2 * this_value // height cell header (1 line = 30px, 2 line = 47px)
        let str_description = "";
        let object_slider_boundary = object_data_tableSequence.object_slider.getBoundingClientRect( );
        let object_table_boundary = tableSequence.getBoundingClientRect( );
        object_data_tableSequence.object_slider_boundary = object_slider_boundary;
        object_data_tableSequence.object_table_boundary = object_table_boundary;
        object_data_tableSequence.mouse_event = event;
        object_data_tableSequence.table_body_range = { top: object_table_boundary.top + height_cell_header + layout_tableSequence.margin.t, bottom: object_table_boundary.bottom - layout_tableSequence.margin.b };
        object_data_tableSequence.table_body_range.height = object_data_tableSequence.table_body_range.bottom - object_data_tableSequence.table_body_range.top;
        object_data_tableSequence.table_body_range.n_rows_per_window = object_data_tableSequence.table_body_range.height / height_cell_value;
        if ( Math.round( object_data_tableSequence.table_body_range.n_rows_per_window ) < object_data_tableSequence.len_alignment ) { // if slider is present, calculate hidden height above the currently shown window.
            object_data_tableSequence.silder_range = { top: object_data_tableSequence.table_body_range.top + n_extra_pixels, bottom: object_data_tableSequence.table_body_range.bottom - object_slider_boundary.height - n_extra_pixels }; 
            object_data_tableSequence.silder_relative_position = ( object_slider_boundary.top - object_data_tableSequence.silder_range.top ) / ( object_data_tableSequence.silder_range.bottom - object_data_tableSequence.silder_range.top ); 
            object_data_tableSequence.hidden_height = ( object_data_tableSequence.len_alignment - object_data_tableSequence.table_body_range.n_rows_per_window ) * height_cell_value * object_data_tableSequence.silder_relative_position;
        } else {
            object_data_tableSequence.hidden_height = 0;
        }
        object_data_tableSequence.clicked_pos_alignment = parseInt( ( object_data_tableSequence.mouse_event.clientY - object_data_tableSequence.table_body_range.top + object_data_tableSequence.hidden_height ) / height_cell_value );
        str_description += "position in the alignment: " + String( object_data_tableSequence.clicked_pos_alignment );
        // retrieve position of human and virus protein structure of the clicked residue in the alignment table
        object_data_tableSequence.clicked_pos_pdb_human = parseInt( object_pdb_human.dict_index_alignment_to_pos_pdb_human[ object_data_tableSequence.clicked_pos_alignment ] ); 
        object_data_tableSequence.clicked_pos_pdb_virus = parseInt( object_pdb_virus.dict_index_alignment_to_pos_pdb_virus[ object_data_tableSequence.clicked_pos_alignment ] );
        object_data_tableSequence.clicked_pos_human = parseInt( object_pdb_human.dict_index_alignment_to_pos_human[ object_data_tableSequence.clicked_pos_alignment ] ); 
        object_data_tableSequence.clicked_pos_virus = parseInt( object_pdb_virus.dict_index_alignment_to_pos_virus[ object_data_tableSequence.clicked_pos_alignment ] );

        if( ! isNaN( object_data_tableSequence.clicked_pos_pdb_human ) ) {
            pdbHumanProtein.visual.highlight( { data: [ { auth_asym_id: object_pdb_human.id_chain, start_residue_number: object_data_tableSequence.clicked_pos_pdb_human, end_residue_number: object_data_tableSequence.clicked_pos_pdb_human } ], color: color_pdb_highlight } )
            str_description += ", position on the human protein (structure): " + String( object_data_tableSequence.clicked_pos_human ) + " (" + String( object_data_tableSequence.clicked_pos_pdb_human ) + ")";
        }
        if( ! isNaN( object_data_tableSequence.clicked_pos_pdb_virus ) ) {
            pdbVirusProtein.visual.highlight( { data: [ { auth_asym_id: object_pdb_virus.id_chain, start_residue_number: object_data_tableSequence.clicked_pos_pdb_virus, end_residue_number: object_data_tableSequence.clicked_pos_pdb_virus } ], color: color_pdb_highlight } )
            str_description += ", position on the virus protein (structure): " + String( object_data_tableSequence.clicked_pos_virus ) + " (" + String( object_data_tableSequence.clicked_pos_pdb_virus ) + ")";
        }
        document.getElementById( "description_clicked_position__table_sequence" ).innerHTML = str_description; // update description
        console.log( "[Add_Click_Callback_Aligned_Sequence_Table] position in alignment is : ", object_data_tableSequence.clicked_pos_alignment );
    }
    function Add_Click_Callback_Aligned_Sequence_Table( ) {
        if ( "removeAllListeners" in tableSequence ) { tableSequence.removeAllListeners( "click" ); } // remove previous listeners if a listener exists
        object_data_tableSequence.object_slider = $( "#plotly_table_sequence g.table g.scrollbar-slider" )[ 0 ]; // retrieve slider
        tableSequence.addEventListener( "click", Highlight_PDB_Residue__Click_Callback__Aligned_Sequence_Table ); // add callbacks
    }
    function Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( event ) { // a callback function to adjust Aligned_Sequence_Table for TCellCrossReactivity record when web page width was changed
        if ( object_data_tableSequence.flag_data_type != "T-Cell" ) { return; } // only resize table when tableSequence object is for T-Cell CrossReactivity record
        let width_col_seq = 100, width_max_col_score = 300; // width of columns containing a.a. sequence in pixels
        let width_window = tableSequence.getBoundingClientRect( ).width;
        arr_width_col = nj.array( [ width_col_seq, Math.min( width_window - 2 * width_col_seq, width_max_col_score ), width_col_seq ] );
        let margin_horizontal = ( width_window - arr_width_col.sum( ) ) / 2;
        object_data_tableSequence.data[ 0 ].columnwidth = arr_width_col.divide( arr_width_col.sum( ) ).tolist( );
        Plotly.newPlot( tableSequence, object_data_tableSequence.data, { margin: { l: Math.max( margin_horizontal - 7.5, 0 ), r: Math.max( margin_horizontal + 7.5, 15 ), t: layout_tableSequence.margin.t, b: layout_tableSequence.margin.b } }, config_MolecularMimicryMap );
    }
    // trigger functions when window size changes
    $(window).resize( function( ) {
        Responsive_Column_Width_Aligned_Sequence_Table_TCellCrossReactivity( );
    });
    function Retrieve_Selection_Mode_Using_Keydown_Status_VaccineDesign( ) { // retrieve selection mode using keydown status
        let key_include = 'a', key_exclude = 'r';
        let bool_flag_include = key_include in object_data_keydown.dict_status && object_data_keydown.dict_status[ key_include ] != 'keyup';
        let bool_flag_exclude = key_exclude in object_data_keydown.dict_status && object_data_keydown.dict_status[ key_exclude ] != 'keyup';
        if ( bool_flag_include && ! bool_flag_exclude ) { return "Include"; }
        else if ( ! bool_flag_include && bool_flag_exclude ) { return "Exclude"; }
        else { return "Show_Info"; }
    }
    
    function Set_Visibility_of_Consensus_Protein_Sequence( ) { // set visibility of consensus protein sequence based on number of residues displayed on the window
        object_data.plot.consensus_sequence.window_width = plotMolecularMimicryMap.offsetWidth; // retrieve the width of the "molecular mimicry map" plot in number of pixels 
        let x_range = plotMolecularMimicryMap.layout.xaxis.range;
        object_data.plot.consensus_sequence.n_residues_displayed = x_range[ 1 ] - x_range[ 0 ]; // retrieve number of plotted residues
        object_data.plot.consensus_sequence.show = object_data.plot.consensus_sequence.n_residues_displayed / object_data.plot.consensus_sequence.window_width <= ( 160 / 1270 ) // if more than 160residues/1270pixels are displayed, hide the protein sequence trace
        let index_trace = object_data.plot.consensus_sequence.index_trace_start; // only trace for 'object_data.plot.consensus_sequence' is consensus sequence trace
        if ( plotMolecularMimicryMap.data[ index_trace ].visible != object_data.plot.consensus_sequence.show ) { // if current visibility is different with previous visibility, update the visibility
            Plotly.restyle( plotMolecularMimicryMap, { visible: object_data.plot.consensus_sequence.show }, index_trace );
        }
    }
    // Modification of plots using buttons and functions
    function Toggle_Hovermode_MolecularMimicryMap( ) { // toggle hovermode
        console.log( object_plot_MolecularMimicryMap.hovermode );
        object_plot_MolecularMimicryMap.hovermode = object_plot_MolecularMimicryMap.hovermode == false ? "closest" : false; // toggle hovermode
        if ( ! ( "data" in plotMolecularMimicryMap ) ) { return; } // if a plot has not been drawn, do not modify layout
        let hovermode_previous = plotMolecularMimicryMap.data[ 0 ].hovermode, hovermode_current = object_plot_MolecularMimicryMap.hovermode;
        console.log( "hovermode is being set to ", hovermode_current, "..." );
        if ( ( hovermode_previous == undefined && hovermode_current == false ) || ( hovermode_previous != hovermode_current ) ) { Plotly.relayout( plotMolecularMimicryMap, { hovermode: hovermode_current } ); }
        console.log( "done." );
    }
    function Toggle_ProteinAnnotation_MolecularMimicryMap( flag_function_call_within_script = null ) { // toggle SARS-CoV-2 VirusProteinAnnotation
        // if this function is called within another script and not by onclick event, set 'flag_function_call_within_script' to true
        object_data.plot.annotation_protein.show = ! $( "#toggle_ProteinAnnotation_MolecularMimicryMap" ).hasClass( "active" ); // inverse the flag (works in practice when called by the onclick event)
        if ( flag_function_call_within_script == true ) {
            object_data.plot.annotation_protein.show = ! object_data.plot.annotation_protein.show; // if the function is called by another script, do not inverse the flag
        }
        if ( object_data.plot.annotation_protein.data.length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: object_data.plot.annotation_protein.show }, nj.arange( object_data.plot.annotation_protein.index_trace_start, object_data.plot.consensus_sequence.index_trace_end ).tolist( ) ); } // set visibility based on the toggled flag for the visibiligy of the track
        Set_Visibility_of_Consensus_Protein_Sequence( ); // set visibility of consensus protein sequence
    }
    function Toggle_IEDB_Epitope_MolecularMimicryMap( flag_function_call_within_script = null ) {
        let dict_data = object_data.plot.iedb_epitope.dict_data,
            n_residues = object_data.plot.consensus_sequence.accumulated_length;
        object_data.plot.iedb_epitope.show = ! $( "#toggle_iedb_epitope_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of IEDB epitopes of SARS-CoV-2 // inversing the toggled status works in practice (modification class label takes time)
        if ( flag_function_call_within_script == true ) {
            object_data.plot.iedb_epitope.show = ! object_data.plot.iedb_epitope.show; // if the function is called by another script, do not inverse the flag
        }
        if ( ! object_data.flag.iedb_epitope_drawn ) {
            // retrieve a trace IEDB epitope records of virus proteins
            console.log( '[Toggle_IEDB_Epitope_MolecularMimicryMap] Processing of data started' );
            // initialize 
            let l_start = [ ],
                l_end = [ ],
                float_floor = - 4, // floor of the trace
                float_height = 1; // height of the trace
            
            if ( object_data.flag.alignment_to_virus ) {
                let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // use first dataset for virus protein annotations
                l_start = nj.array( dict_data[ "start_accumulated" ] ).subtract( 1 ).tolist( ), 
                l_end = dict_data[ "end_accumulated" ]; // 0-based coordinate 
                dict_data[ "start" ] = nj.array( ArrayMap( l_start, object_data.plot.consensus_sequence.dict_accumulated_coord_to_individual_coord ) ).add( 1 ).tolist( ); // 1-based coordinates
                dict_data[ "end" ] = ArrayMap( l_end, object_data.plot.consensus_sequence.dict_accumulated_coord_to_individual_coord );
                dict_data[ "protein_name" ] = ArrayApply( dict_data[ "accession_representative" ], acc => dataset.arr_data_acc_virus_representative[ acc ].name );
                float_floor = - 4, 
                float_height = 1;  
            } else {
                dict_data[ "start" ] = dict_data[ "start_human" ].map( ( start ) => { return start - 1; } ); 
                dict_data[ "end" ] = dict_data[ "end_human" ]; // 0-based coordinate 
                l_start = dict_data[ "start" ];
                l_end = dict_data[ "end" ];
                dict_data[ "protein_name" ] = dict_data[ "humen_gene_symbol" ];
                float_floor = - 2.5,
                float_height = 1.5;
            }
            dict_data[ "error_x" ] = nj.array( l_end ).subtract( l_start ).divide( 2 ).tolist( );
            let arr_y = nj.array( ArrayCap( nj.array( dict_data[ "number_of_positive_B_cell_assay" ] ).add( dict_data[ "number_of_positive_T_cell_assay" ] ).multiply( dict_data[ "percent_identity" ] ).divide( 100 ).tolist( ), 5 ) ); // retrieve combined score for IEDB epitopes (y-axis)
            dict_data[ "x" ] = nj.array( l_start ).add( l_end ).divide( 2 ).tolist( );
            dict_data[ "y" ] = arr_y.divide( arr_y.max( ) / ( 0.75 * float_height ) ).subtract( 0.05 - float_floor ).tolist( );
            object_data.plot.iedb_epitope.dict_data = dict_data;
            
            object_data.plot.iedb_epitope.hovertemplate = ["IEDB Epitope #%{customdata[0]:.0f}",
                                                            "        seq: %{customdata[6]}",
                                                            "<b>%{customdata[5]}</b> from <b>%{customdata[3]:.0f}</b> to <b>%{customdata[4]:.0f}</b>",
                                                            "(%{customdata[7]:.0f}% identical, %{customdata[8]:.0f} mismatch, %{customdata[9]:.0f} gaps)",
                                                            "",
                                                            "number of positive B-cell assays: <b>%{customdata[1]:.0f}</b>",
                                                            "number of positive T-cell assays: <b>%{customdata[2]:.0f}</b>",
                                                            "<extra></extra>" ].join( "<br>" );
            object_data.plot.iedb_epitope.customdata = ArrayTranspose( DictArrayToArray( dict_data, [ "accession_iedb", "number_of_positive_B_cell_assay", "number_of_positive_T_cell_assay", "start", "end", "protein_name", "iedb_epitope_sequence", "percent_identity", "mismatch", "gapopen" ] ) );
            
    
            // retrieve mask for IEDB epitopes with b-cell assay count larger than t-cell assay count
            let l_b_cell_assay_count = dict_data[ "number_of_positive_B_cell_assay" ], 
                l_t_cell_assay_count = dict_data[ "number_of_positive_T_cell_assay" ], 
                l_bool_flag_b_cell_epitope = [ ]; 
            for ( let i = 0; i < l_b_cell_assay_count.length; i ++ ) { l_bool_flag_b_cell_epitope.push( l_b_cell_assay_count[ i ] >= l_t_cell_assay_count[ i ] ); }
            object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope = l_bool_flag_b_cell_epitope;
            object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope = ArrayBoolNOT( l_bool_flag_b_cell_epitope );

            let trace_iedb_epitope_b_cell_assay = { visible: object_data.plot.iedb_epitope.show, name: "IEDB_Epitopes__Positive_B_Cell_Assays", x: ArrayBooleanIndexing( dict_data[ "x" ], object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), y: ArrayBooleanIndexing( dict_data[ "y" ], object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), type: 'scattergl', mode: "markers", error_x: { type: 'data', array: ArrayBooleanIndexing( dict_data[ "error_x" ], object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), visible: true, width: 0, thickness: 1 }, customdata: ArrayBooleanIndexing( object_data.plot.iedb_epitope.customdata, object_data.plot.iedb_epitope.l_bool_flag_b_cell_epitope ), hovertemplate: object_data.plot.iedb_epitope.hovertemplate, showlegend: false, marker: { symbol: "star-open", size: 10, opacity: 0.5, line: { width: 2 }, color: "#00ff08" } };
            let trace_iedb_epitope_t_cell_assay = { visible: object_data.plot.iedb_epitope.show, name: "IEDB_Epitopes__Positive_T_Cell_Assays", x: ArrayBooleanIndexing( dict_data[ "x" ], object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), y: ArrayBooleanIndexing( dict_data[ "y" ], object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), type: 'scattergl', mode: "markers", error_x: { type: 'data', array: ArrayBooleanIndexing( dict_data[ "error_x" ], object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), visible: true, width: 0, thickness: 1 }, customdata: ArrayBooleanIndexing( object_data.plot.iedb_epitope.customdata, object_data.plot.iedb_epitope.l_bool_flag_t_cell_epitope ), hovertemplate: object_data.plot.iedb_epitope.hovertemplate, showlegend: false, marker: { symbol: "star-open", size: 10, opacity: 0.5, line: { width: 2 }, color: "#f003fc" } };
            let trace_iedb_epitope_lower_bound = { x : [ 0, n_residues ], y : [ float_floor + float_height - 0.01, float_floor + float_height - 0.01 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "iedb_epitope__lower_bound" }, trace_iedb_epitope_upper_bound = { x : [ 0, n_residues ], y : [ float_floor, float_floor ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "iedb_epitope__upper_bound" };
            object_data.plot.iedb_epitope.data = [ trace_iedb_epitope_lower_bound, trace_iedb_epitope_upper_bound , trace_iedb_epitope_b_cell_assay, trace_iedb_epitope_t_cell_assay ];

            // draw IEDB epitopes of virus with positive assays
            console.log( '[Toggle_IEDB_Epitope_MolecularMimicryMap] plotting "IEDB epitopes of SARS-CoV-2 virus" traces...' )
            object_data.plot.iedb_epitope.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
            Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( object_data.plot.iedb_epitope.data ) );
            object_data.plot.iedb_epitope.index_trace_end = plotMolecularMimicryMap.data.length;
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; } // update trace_name - index mapping
            object_data.flag.iedb_epitope_drawn = true; // update the flag
        }
        if ( object_data.plot.iedb_epitope.data.length > 0 ) { 
            Plotly.restyle( plotMolecularMimicryMap, { visible: object_data.plot.iedb_epitope.show }, nj.arange( object_data.plot.iedb_epitope.index_trace_start, object_data.plot.iedb_epitope.index_trace_end ).tolist( ) );
        } // set visibility based on the toggled flag for the visibiligy of the track
    }
    async function Toggle_VaccineDesign_MolecularMimicryMap( ) {
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        dataset.vaccine_design.show = ! $( "#toggle_vaccine_design_MolecularMimicryMap" ).hasClass( "active" ); // set visibility of the vaccine design trace // inversing the read toggled status works in practice
        if ( ! dataset.flag.vaccine_design_optivax_loaded ) {
            console.log( "[Toggle_VaccineDesign_MolecularMimicryMap] downloading and drawing peptide vaccine candidates" );
            await LoadOptiVax( );
            object_data.flag.vaccine_design_drawn = true;
        } else if ( ! object_data.flag.vaccine_design_drawn ) {
            Draw_DesignedVaccineTrace( "new_trace" );
            object_data.flag.vaccine_design_drawn = true;
        }
        if ( dataset.vaccine_design.data.length > 0 ) { 
            Plotly.restyle( plotMolecularMimicryMap, { visible: dataset.vaccine_design.show }, nj.arange( dataset.vaccine_design.index_trace_start, dataset.vaccine_design.index_trace_end ).tolist( ) );
        } // set visibility based on the toggled flag for the visibiligy of the track
    }
    function Toggle_Legend_MolecularMimicryMap( ) { // toggle the legend of the molecular mimicry map graph
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        let l_name_trace = [ ];
        if ( ! dataset.object_plot_BCellCrossReactivity.flag_bool_mode_is_lines ) {
            l_name_trace.push( "B Cell Cross-Reactivity Prediction" ); // add legend of B Cell Cross-reactivity prediction data only when drawing mode is not line
        }
        l_name_trace = l_name_trace.concat( [
            "IEDB_Epitopes__Positive_B_Cell_Assays",
            "IEDB_Epitopes__Positive_T_Cell_Assays",
            "T Cell Cross-Reactivity Prediction (Human)",
            "T Cell Cross-Reactivity Prediction (Virus)",
            "vaccine_design" ] );
        if ( 'vaccine_metric' in dataset ) {
            l_name_trace.push( ... dataset.vaccine_metric.l_name_data );
        }
        let l_index_trace = [ ]; // list of indices for toggling legend labels
        for ( let i = 0; i < l_name_trace.length; i ++ ) {
            let name_trace = l_name_trace[ i ];
            if ( name_trace in dict_name_plot_to_trace_index__MolecularMimicryMap ) {
                l_index_trace.push( dict_name_plot_to_trace_index__MolecularMimicryMap[ name_trace ] );
            }
        }
        if ( l_index_trace.length == 0 ) { console.log( "[Toggle_Legend_MolecularMimicryMap] no traces drawn. exiting." ); return; }
        object_plot_MolecularMimicryMap.showlegend = ! plotMolecularMimicryMap.data[ 0 ].showlegend; // retrieve toggled 'showlegend' status
        Plotly.restyle( plotMolecularMimicryMap, { showlegend : object_plot_MolecularMimicryMap.showlegend }, l_index_trace ); // toggle legend labels
        console.log( "[Toggle_Legend_MolecularMimicryMap] legend labels " + ( object_plot_MolecularMimicryMap.showlegend? "shown" : "hidden" ) );
    }
    
    function Toggle_BCellCrossReactivityPrediction_MolecularMimicryMap( ) { // toggle BCellCrossReactivityPrediction data
        object_plot_BCellCrossReactivity.show = ! $( "#toggle_BCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // since it takes some time to modify class label, inversing the toggled state identified here works practically
        console.log( "[Toggle_BCellCrossReactivityPrediction_MolecularMimicryMap] setting visibility to", object_plot_BCellCrossReactivity.show );
        // retrieve indices of traces for the BCellCrossReactivity data
        let l_index_trace_BCellCrossReactivity = [ ];
        for ( let index_trace = object_plot_BCellCrossReactivity.index_trace_start; index_trace < object_plot_BCellCrossReactivity.index_trace_end; index_trace ++ ) { 
            l_index_trace_BCellCrossReactivity.push( index_trace );
        } 
        if ( object_plot_BCellCrossReactivity.dict_data[ "error_x" ].length > 0 ) { 
            if ( ( ! object_plot_BCellCrossReactivity.show ) & object_plot_TCellCrossReactivity.show & ( l_index_trace_BCellCrossReactivity.length == 1 ) ) {
                // will trigger an annoying error with no apparent direct solution (setting visibility of point-type B-cell record to false at AlignmentToHuman mode only trigger the error)
                // one roundabout is turning off Tcell record prior to Bcell records (somehow works)
                let l_index_trace_TCellCrossReactivity = [ ];
                for ( let index_trace = object_plot_TCellCrossReactivity.index_trace_start; index_trace < object_plot_TCellCrossReactivity.index_trace_end; index_trace ++ ) { 
                    l_index_trace_TCellCrossReactivity.push( index_trace );
                } 
                Plotly.restyle( plotMolecularMimicryMap, { visible: false }, l_index_trace_TCellCrossReactivity );
                Plotly.restyle( plotMolecularMimicryMap, { visible: false }, l_index_trace_BCellCrossReactivity );
                Plotly.restyle( plotMolecularMimicryMap, { visible: true }, l_index_trace_TCellCrossReactivity );
            } else {
                Plotly.restyle( plotMolecularMimicryMap, { visible: object_plot_BCellCrossReactivity.show }, l_index_trace_BCellCrossReactivity );
            }
        } // set visibility 
    }
    function Toggle_TCellCrossReactivityPrediction_MolecularMimicryMap( ) { // toggle BCellCrossReactivityPrediction data
        object_plot_TCellCrossReactivity.show = ! $( "#toggle_TCellCrossReactivityPrediction_MolecularMimicryMap" ).hasClass( "active" ); // since it takes some time to modify class label, inversing the toggled state identified here works practically
        console.log( "[Toggle_TCellCrossReactivityPrediction_MolecularMimicryMap] setting visibility to", object_plot_TCellCrossReactivity.show );
        let l_index_trace_TCellCrossReactivity = [ dict_name_plot_to_trace_index__MolecularMimicryMap[ "T Cell Cross-Reactivity Prediction (Human)" ], dict_name_plot_to_trace_index__MolecularMimicryMap[ "T Cell Cross-Reactivity Prediction (Virus)" ] ];
        if ( object_plot_TCellCrossReactivity.dict_data[ "error_x" ].length > 0 ) { Plotly.restyle( plotMolecularMimicryMap, { visible: object_plot_TCellCrossReactivity.show }, l_index_trace_TCellCrossReactivity ); } // set visibility 
    }
    
    object_data.flag.gene_highlighted = false; // flag indicating whether a gene is being highlighted on the plot or not
    // setting for highlight
    var float_line_width_when_highlighting = 2, float_line_width_when_not_highlighting = 0, color_when_highlighting = 'black'; // settings for highlighting
    
    object_data.main.highlight = { str_entry: "" }; // storing variables for highlighting records
    function Highlight_Records_MolecularMimicryMap( str_entry, name_dict_str_entry_to_l_index ) { // highlight records according to the given 'l_index', which can be retrieved using 'str_entry' and 'dict_str_entry_to_l_index' with a given 'name_dict_str_entry_to_l_index' at 'object_plot_BCellCrossReactivity' and 'object_plot_TCellCrossReactivity'
        if ( str_entry == object_data.main.highlight.str_entry ) {
            object_data.main.highlight.str_entry = ""; // clear current highlighting
            delete object_plot_BCellCrossReactivity.mask_selected_highlighting; // remove filters
            delete object_plot_TCellCrossReactivity.mask_selected_highlighting;
            Filter_BCellCrossReactivity( ); // update graph
            Filter_TCellCrossReactivity( );
            return;
        } else if ( str_entry.length > 0 ) { // if previous highlighting exists
            
        }
        object_data.main.highlight.str_entry = str_entry; // update entry being highlighted
        
        // update filter for highlighting
        // if str_entry does not exists, use an empty array to build a boolean index
        object_plot_BCellCrossReactivity.mask_selected_highlighting = ArrayBroadCasting( ArrayFull( object_plot_BCellCrossReactivity.arr_data.length, false ), ( str_entry in object_plot_BCellCrossReactivity[ name_dict_str_entry_to_l_index ] ) ? object_plot_BCellCrossReactivity[ name_dict_str_entry_to_l_index ][ str_entry ] : [ ], true ); 
        if ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) {
            object_plot_TCellCrossReactivity.mask_selected_highlighting = ArrayBroadCasting( ArrayFull( object_plot_TCellCrossReactivity.arr_data.length, false ), ( str_entry in object_plot_TCellCrossReactivity[ name_dict_str_entry_to_l_index ] ) ? object_plot_TCellCrossReactivity[ name_dict_str_entry_to_l_index ][ str_entry ] : [ ], true ); 
        }
        Filter_BCellCrossReactivity( ); // update graph
        Filter_TCellCrossReactivity( );
    }
    
    function VaccineMetrics_Update_Visibility( ) { // update visibility_for_each_trace and general visibility for current setting
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        let l_name_data = dataset.vaccine_metric.l_name_data, visibility_for_each_trace = ArrayFull( l_name_data.length, false ), dict_name_data_to_index = dataset.vaccine_metric.dict_name_data_to_index; // set visibility of each trace based on the given settings 
        visibility_for_each_trace[ dict_name_data_to_index[ "count_iedb_epitope_with_tcell_assay" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_iedb_t_cell_assay" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "count_iedb_epitope_with_bcell_assay" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_iedb_b_cell_assay" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "avg_processing_score_mhc_i" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_mhc_i_processing_score" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "score_linear_bcell_epitope_prediction__bepipred" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_bepipred" ).checked;
        visibility_for_each_trace[ dict_name_data_to_index[ "relative_accessible_surface_area" ] ] = document.getElementById( "checkbox_toggle_vaccine_metric_relative_accessible_surface_area" ).checked;
        if ( document.getElementById( "checkbox_toggle_vaccine_metric_count_non_consensus_residue" ).checked ) { visibility_for_each_trace[ dict_name_data_to_index[ document.getElementById( "select_vaccine_metric_count_non_consensus_residue" ).value ] ] = true; }
        if ( document.getElementById( "checkbox_toggle_vaccine_metric_mhc_i_binding_prediction" ).checked ) { visibility_for_each_trace[ dict_name_data_to_index[ document.getElementById( "select_vaccine_metric__mhc_i_binding_peptide_count" ).value ] ] = true; }
        if ( document.getElementById( "checkbox_toggle_vaccine_metric_mhc_ii_binding_prediction" ).checked ) { visibility_for_each_trace[ dict_name_data_to_index[ document.getElementById( "select_vaccine_metric__mhc_ii_binding_peptide_count" ).value ] ] = true; }
        dataset.vaccine_metric.visibility_for_each_trace = visibility_for_each_trace;
    }
    function VaccineMetrics_Apply_Visibility( flag_function_call_within_script = null ) { // apply updated visibility for each trace
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ]; // retrieve dataset
        dataset.vaccine_metric.show = ! $( "#toggle_vaccine_metrics_MolecularMimicryMap" ).hasClass( "active" ); // set general visibility of all vaccine metric traces // inversing the read toggled status works in practice
        if ( flag_function_call_within_script == true ) {
            dataset.vaccine_metric.show = ! dataset.vaccine_metric.show; // if the function is called by another script, do not inverse the flag
        }
        let n_residues = dataset.consensus_sequence_virus.accumulated_length;
        if ( ! object_data.flag.vaccine_metric_drawn ) { // draw metrics for vaccine design
            // parse data for displaying vaccine metrics
            console.log( "[VaccineMetrics_Apply_Visibility] Preprocessing of data started" );
            let l_col = Object.keys( dataset.arr_data_acc_virus_representative[ 0 ] ); // retrieve list of columns of 'dataset.arr_data_acc_virus_representative'
            for ( let i = 0; i < l_col.length; i ++ ) {
                let col = l_col[ i ], l_data = [ ];
                if ( col.slice( 0, 2 ) == 'l_' ) {
                    for ( let j = 0; j < dataset.arr_data_acc_virus_representative.length; j ++ ) { l_data.push( ... Unpack_String_Numbers( dataset.arr_data_acc_virus_representative[ j ][ col ] ) ); }
                    dataset.vaccine_metric.dict_data[ col.slice( 2 ) ] = l_data;
                } else if ( col.includes( "___ascii_encoding_" ) ) { // concatanate structural data
                    let name_data = col.split( "___ascii_encoding_" )[ 0 ];
                    for ( let j = 0; j < dataset.arr_data_acc_virus_representative.length; j ++ ) { 
                        let seq_data = dataset.arr_data_acc_virus_representative[ j ][ col ], l_value = [ ];
                        switch ( name_data ) {
                            case "rsa_combined" : 
                                l_value = Unpack_String_rsa_encoded_by_two_char( seq_data );
                                break;
                            case "rsa_datatype_combined" : 
                                l_value = Unpack_String_datatype( seq_data );
                                break;
                            case "ss8_combined" : 
                                l_value = Unpack_String_ss8( seq_data );
                                break;
                        }
                        l_data.push( ... l_value );
                    }
                    dataset.vaccine_metric.dict_data[ { rsa_combined: "relative_accessible_surface_area", rsa_datatype_combined: "type_of_structural_data", ss8_combined: "secondary_structure_classification__dssp_8_states" }[ name_data ] ] = l_data;
                } else { continue; } // only concatanate data from columns starting with 'l_' or containing '___ascii_encoding_'
                dataset.consensus_sequence_virus.accumulated_length = l_data.length; // retrieve the length of concatanated virus proteins
            }
            dataset.consensus_sequence_virus.seq_consensus_concatenated = unpack( dataset.arr_data_acc_virus_representative, 'seq_consensus' ).join( '' ); // retrieve concatanated consensus_sequence of virus proteins
            let l_name_data = Object.keys( dataset.vaccine_metric.dict_data ); // retrieve list of data tracks
            dataset.vaccine_metric.l_name_data = l_name_data;
            let dict_name_data_to_index = { }, dict_name_data_to_color = { }; // map name_data to index and set colors
            for ( let i = 0; i < l_name_data.length; i ++ ) { 
                let name_data = l_name_data[ i ], color = '#A9A9A9'; // set default color  //'DarkGray'
                dict_name_data_to_index[ name_data ] = i;
                if ( name_data.includes( "count_non_consensus_residue" ) ) { color = "#0000FF"; // "Blue";
                } else if ( name_data.includes( "count_peptide_binding_common_mhc_i_alleles" ) ) { color = "#B22222"; // "FireBrick";
                } else if ( name_data.includes( "count_peptide_binding_common_mhc_ii_alleles" ) ) { color = "#228B22"; // "ForestGreen";
                } else {
                    switch( name_data ) {
                        case "avg_processing_score_mhc_i": color = "#F08080"; break; // "LightCoral"
                        case "score_linear_bcell_epitope_prediction__bepipred": color = "#90EE90"; break; // "LightGreen"
                        case "count_iedb_epitope_with_tcell_assay": color = "#DC143C"; break; // "Crimson"
                        case "count_iedb_epitope_with_bcell_assay": color = "#7FFF00"; break; // "Chartreuse"
                        case "relative_accessible_surface_area": color = "#949494"; // grey
                    }
                }
                dict_name_data_to_color[ name_data ] = color;
            }
            dataset.vaccine_metric.dict_name_data_to_index = dict_name_data_to_index;
            dataset.vaccine_metric.dict_name_data_to_color = dict_name_data_to_color; // set trace color for each name_data

            console.log( "[VaccineMetrics_Apply_Visibility] Preprocessing of data completed" );
            // retrieve traces of vaccine metrics
            VaccineMetrics_Update_Visibility( ) // update visibility from current settings
            let visibility_for_each_trace = dataset.vaccine_metric.visibility_for_each_trace, n_residues = dataset.consensus_sequence_virus.accumulated_length; // set visibility of each trace based on the given settings 
            let trace_vaccine_metric_lower_bound = { x : [ 0, n_residues ], y : [ -3, -3 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "vaccine_metric__lower_bound" }, trace_vaccine_metric_upper_bound = { x : [ 0, n_residues ], y : [ -1, -1 ], type : "scattergl", mode : 'lines', line : { color: '#000000', width: 1 }, showlegend : false, name: "vaccine_metric__upper_bound" };
            dataset.vaccine_metric.data = [ trace_vaccine_metric_lower_bound, trace_vaccine_metric_upper_bound ];  // traces for boundary of vaccine design traces
            let x = nj.arange( n_residues ).tolist( ) // 0-based coordinates
            for ( let i = 0; i < l_name_data.length; i ++ ) {
                let trace = { }, name_data = l_name_data[ i ];
                let l_data = dataset.vaccine_metric.dict_data[ name_data ]; 
                if ( name_data.includes( "count_non_consensus_residue" ) ) { l_data = ArrayCap( l_data, 50 ); } // cap 'count_non_consensus_residue' with a threshold 50 
                let arr_value = nj.array( l_data ); // numjs array of data values
                trace.name = name_data;
                trace.x = x;
                trace.y = arr_value.divide( arr_value.max( ) / 2 ).subtract( 3 ).tolist( ); // vaccine metric traces at ( - 1, -3  )
                trace.customdata = ArrayTranspose( [ ArrayApply( dataset.vaccine_metric.dict_data[ name_data ], String ), nj.array( ArrayMap( x, dataset.consensus_sequence_virus.dict_accumulated_coord_to_individual_coord ) ).add( 1 ).tolist( ), ArrayApply( x, function( x ) { return dataset.arr_data_acc_virus_representative[ dataset.consensus_sequence_virus.dict_accumulated_coord_to_acc_rep[ x ] ].name; } ) ] ); // display actual values on hover
                trace.mode = 'lines';
                trace.type = 'scattergl';
                trace.showlegend = false;
                trace.visible = visibility_for_each_trace[ i ]; // set visibility of traces
                trace.line = { color: dataset.vaccine_metric.dict_name_data_to_color[ name_data ], width: 1 } // set color of traces
                trace.hovertemplate = name_data + ":<br><b>%{customdata[0]}</b><br>at %{customdata[1]:.0f}-th residue of <b>%{customdata[2]}</b><br><extra></extra>"; // set hovertemplate
                dataset.vaccine_metric.data.push( trace );
            }
            console.log( '[VaccineMetrics_Apply_Visibility] plotting vaccine metric traces...' )
            VaccineMetrics_Update_Visibility( ); // update visibility of vaccine metric traces
            l = dataset.vaccine_metric.visibility_for_each_trace;
            for ( let i = 0; i < l.length; i ++ ) { dataset.vaccine_metric.data[ i + 2 ].visible = l[ i ]; } // first two traces are lower and upper boundary of vaccine metric traces
            dataset.vaccine_metric.index_trace_start = plotMolecularMimicryMap.data.length; // record index_start and index_end of traces
            Plotly.addTraces( plotMolecularMimicryMap, lodash.cloneDeep( dataset.vaccine_metric.data ) );
            dataset.vaccine_metric.index_trace_end = plotMolecularMimicryMap.data.length;
            object_data.flag.vaccine_metric_drawn = true; // update the flag
            for( let i = 0; i < plotMolecularMimicryMap.data.length; i ++ ) { dict_name_plot_to_trace_index__MolecularMimicryMap[ plotMolecularMimicryMap.data[ i ].name ] = i; } // update trace_name - index mapping
        }
        VaccineMetrics_Update_Visibility( ) // update visiblity for current settings
        let l_name_data = lodash.cloneDeep( dataset.vaccine_metric.l_name_data );
        l_name_data.push( ... [ 'vaccine_metric__lower_bound', 'vaccine_metric__upper_bound' ] );
        let l_visibility = dataset.vaccine_metric.show ? dataset.vaccine_metric.visibility_for_each_trace.concat( [ true, true ] ) : ArrayFull( l_name_data.length, false ), l_index_trace = [ ];
        for ( let i = 0; i < l_name_data.length; i ++ ) { l_index_trace.push( dict_name_plot_to_trace_index__MolecularMimicryMap[ l_name_data[ i ] ] ); } // retrieve index_trace of VaccineMetrics traces.
        for ( let i = 0; i < l_index_trace.length; i ++ ) {
            let index_trace = l_index_trace[ i ], visibility = l_visibility[ i ];
            if ( plotMolecularMimicryMap.data[ index_trace ].visible != visibility ) { Plotly.restyle( plotMolecularMimicryMap, { visible: visibility }, index_trace ); } // update visibility of individual traces when current visibility is different from updated visibility
        }
    }
            
    
    // named event handlers
    function EventHandler_plotly_relayout_MolecularMimicryMap( data ) {
        console.log( "plotMolecularMimicryMap, plotly_relayout event triggered:", data );
        Set_Visibility_of_Consensus_Protein_Sequence( );
        Adjust_Layout_MolecularMimicryMap( );
    }
    function EventHandler_plotly_restyle_MolecularMimicryMap( data ) {
        console.log( "plotMolecularMimicryMap, plotly_restyle event triggered:", data );
        Adjust_Layout_MolecularMimicryMap( );
    }
    
    async function Adjust_Layout_MolecularMimicryMap( mode ) { // adjust layout of molecular mimicry graph based on plot height and y-axis range
        let dataset = object_data.main.dataset[ object_data.main.l_name_dataset[ 0 ] ];
        return new Promise ( async function( resolve, reject ) {
            // retrieve 0-based coodinates
            let l_y_range = plotMolecularMimicryMap.layout.yaxis.range, 
                y_floor = l_y_range[ 0 ], 
                y_ceiling = l_y_range[ 1 ], 
                y_axis_size = y_ceiling - y_floor, 
                l_anno = [ ], 
                bool_flag_y_axis_changed = ( object_plot_MolecularMimicryMap.layout.y_floor != y_floor ) || ( object_plot_MolecularMimicryMap.layout.y_ceiling != y_ceiling );
            let l_x_range = plotMolecularMimicryMap.layout.xaxis.range, 
                x_left = parseInt( Math.max( 0, l_x_range[ 0 ] ) ),
                x_right = parseInt( Math.min( l_x_range[ 1 ], object_data.plot.consensus_sequence.accumulated_length - 1 ) ), 
                x_axis_size = x_right - x_left, 
                bool_flag_x_axis_changed = ( object_plot_MolecularMimicryMap.layout.x_left != x_left ) || ( object_plot_MolecularMimicryMap.layout.x_right != x_right );
            if ( true && ( object_plot_BCellCrossReactivity.show || object_plot_TCellCrossReactivity.show ) ) { // if Cross-Reactivity prediction data are being shown and y-axis range has been changed or y-axis-label has not been drawn, adjust y-axis label
                console.log( "[Adjust_Layout_MolecularMimicryMap] change in y-axis detected. Adjusting annotations in the layout" );
                object_plot_MolecularMimicryMap.layout.y_floor = y_floor; // update y axis range
                object_plot_MolecularMimicryMap.layout.y_ceiling = y_ceiling;    
                l_anno.push( {
                        font: { size: 15 },
                        xanchor: "left",
                        yanchor: "middle",
                        xref: "paper", x: 0,
                        yref: 'paper', y: ( 1 + ( - y_floor ) / y_axis_size ) / 2,
                        textangle: - 90,
                        xshift: - layout_MolecularMimicryMap.margin.l - 5,
                        text: ( object_data.flag.cross_reactive_mhc_ligand_data_exist ) ? `(B Cell) ${dataset.object_plot_BCellCrossReactivity.y_axis.label}<br>(T Cell) ${dataset.object_plot_TCellCrossReactivity.y_axis.label}` : `(B Cell) ${dataset.object_plot_BCellCrossReactivity.y_axis.label}`,
                        showarrow: false
                      } ); // update y-axis labal annotation
            }
            if ( true ) {
                console.log( "[Adjust_Layout_MolecularMimicryMap] change in x-axis detected. Adjusting annotations in the layout" );
                // show start and end position of the window
                let str_anno = "";
                object_plot_MolecularMimicryMap.layout.x_left = x_left; // update x axis range
                object_plot_MolecularMimicryMap.layout.x_right = x_right;    
                if ( object_data.flag.alignment_to_virus ) {
                    let anno_protein_virus_left = dataset.arr_data_acc_virus_representative[ dataset.consensus_sequence_virus.dict_accumulated_coord_to_acc_rep[ x_left ] ], 
                        anno_protein_virus_right = dataset.arr_data_acc_virus_representative[ dataset.consensus_sequence_virus.dict_accumulated_coord_to_acc_rep[ x_right ] ];
                    let pos_protein_virus_left = dataset.consensus_sequence_virus.dict_accumulated_coord_to_individual_coord[ x_left ] + 1, 
                        pos_protein_virus_right = dataset.consensus_sequence_virus.dict_accumulated_coord_to_individual_coord[ x_right ] + 1;
                    str_anno = ( anno_protein_virus_left.name == anno_protein_virus_right.name ) ? anno_protein_virus_left.name + " " + pos_protein_virus_left + "-" + pos_protein_virus_right + "/" + anno_protein_virus_left.length : anno_protein_virus_left.name + " " + pos_protein_virus_left + "/" + anno_protein_virus_left.length + " ... " + anno_protein_virus_right.name + " " + pos_protein_virus_right + "/" + anno_protein_virus_right.length; 
                } else {
                    str_anno = `${object_plot_MolecularMimicryMap.human_gene_symbol_of_interest} ${x_left + 1}-${x_right}`; // 1-based coodinates
                }
                l_anno.push( {
                        font: { size: 18 },
                        xanchor: "left",
                        yanchor: "top",
                        xref: "paper", x: 0,
                        yref: 'paper', y: 1,
                        textangle: 0,
                        xshift: 0,
                        text: str_anno,
                        showarrow: false
                      } ); // update y-axis labal annotation
            }
            if ( ( "vaccine_design" in dict_name_plot_to_trace_index__MolecularMimicryMap ) && dataset.vaccine_design.show ) { // while vaccine_design trace is on display
                let index_trace_vaccine_design = dict_name_plot_to_trace_index__MolecularMimicryMap[ "vaccine_design" ], name_y_value = dataset.vaccine_design.name_y_axis;
                if ( true || mode == "vaccine_design_y_axis_updated" || name_y_value != dataset.vaccine_design.plotly.name_y_value || bool_flag_y_axis_changed ) {
                    console.log( "[Adjust_Layout_MolecularMimicryMap] change of y-axis name of vaccine_design trace or change of y-axis range was detected while vaccine_design trace is on display. Adjusting annotations in the layout" );
                    dataset.vaccine_design.plotly.name_y_value = name_y_value; // update name_y_value
                    if ( ! ( "dict_max_value" in dataset.vaccine_design.plotly ) ) { dataset.vaccine_design.plotly.dict_max_value = { }; }
                    if ( ! ( name_y_value in dataset.vaccine_design.plotly.dict_max_value ) || mode == "vaccine_design_y_axis_updated" ) { // retrieve the max_value of the values of 'name_y_value' data if the data does not exist of y_axis values have been updated.
                        dataset.vaccine_design.plotly.dict_max_value[ name_y_value ] = Math.max( ... dataset.vaccine_design.plotly.y );
                    }
                    let y_value_max = dataset.vaccine_design.plotly.dict_max_value[ name_y_value ];
                    l_anno.push( ... [{
                        font: { size: 12 },
                        xref: 'paper', yref: 'paper',
                        x: 0,
                        xanchor: 'left',
                        y: ( - 4 - y_floor ) / y_axis_size,
                        yanchor: 'top',
                        text: 'Max = ' + ( CheckInt( y_value_max ) ? String( y_value_max ) : y_value_max.toFixed( 3 ) ),
                        xshift: - 30,
                        showarrow: false
                      }, {
                        font: { size: 12 },
                        xref: 'paper', yref: 'paper',
                        x: 0,
                        xanchor: 'left',
                        y: ( - 6 - y_floor ) / y_axis_size,
                        yanchor: 'bottom',
                        text: 'Min = ' + String( 0 ),
                        xshift: - 30,
                        showarrow: false
                      }] );
                }
            }
//             if ( l_anno.length == 0 ) { return; } // if no relavant change was detected, do not update layout
            plotMolecularMimicryMap.removeAllListeners( "plotly_relayout" ); // remove event listeners to avoid infinite event propagation
            plotMolecularMimicryMap.removeAllListeners( "plotly_restyle" ); 
            await Plotly.relayout( plotMolecularMimicryMap, { annotations: l_anno });
            plotMolecularMimicryMap.on( "plotly_relayout", EventHandler_plotly_relayout_MolecularMimicryMap );
            plotMolecularMimicryMap.on( "plotly_restyle", EventHandler_plotly_restyle_MolecularMimicryMap );
            console.log( "[Adjust_Layout_MolecularMimicryMap] annotations adjusted." ); // add listeners back
            resolve( "[Adjust_Layout_MolecularMimicryMap] annotations adjusted." );
        }); 
    }

    // Mol* JS molecule renderer
    //Create plugin instance
    var pdbHumanProtein = new PDBeMolstarPlugin( );
    var pdbVirusProtein = new PDBeMolstarPlugin( );

    //Get element from HTML/Template to place the viewer 
    var pdbHumanProteinContainer = document.getElementById( 'PDB_Viewer_Human_Protein' );
    var pdbVirusProteinContainer = document.getElementById( 'PDB_Viewer_Virus_Protein' );
    //Call render method to display the 3D view
    str_jquery_container = "#container_PDB";
    if ( $( str_jquery_container ).hasClass( "collapse" ) && $( str_jquery_container ).hasClass( "show" ) ) { 
        pdbHumanProtein.render( pdbHumanProteinContainer, option_initialization_molstar ); pdbVirusProtein.render( pdbVirusProteinContainer, option_initialization_molstar ); // draw Plotly plot synchronously if the container is currently shown
        pdbHumanProtein.visual.setColor( { highlight: color_pdb_highlight } ); pdbVirusProtein.visual.setColor( { highlight: color_pdb_highlight } ); // set highlight colors
    } else { BootstrapCollapseShownPromise( str_jquery_container ).then( ( ) => { // draw Plotly plot once the container is shown if the container is currently hidden
        pdbHumanProtein.render( pdbHumanProteinContainer, option_initialization_molstar ); 
        pdbVirusProtein.render( pdbVirusProteinContainer, option_initialization_molstar );
        Promise.all( [ MolStarRenderCompletePromise( pdbHumanProtein ), MolStarRenderCompletePromise( pdbVirusProtein ) ] ).then( ( ) => { $( "#container_PDB" ).collapse( 'show' ); pdbHumanProtein.visual.setColor( { highlight: color_pdb_highlight } ); pdbVirusProtein.visual.setColor( { highlight: color_pdb_highlight } ); } ); // // hide Mol* viewers once initialization on both viewer instances are completed
    } ); }  
    var l_exclusive_tab = [ "#plotly_graph_b_cell_cross_reactivity", "#plotly_graph_t_cell_cross_reactivity", "#plotly_graph_human_protein", "#container_datatable_panel_MolecularMimicryMap" ], 
        target_tab_among_exclusive_tabs = "";
    function Toggle_Exclusive_Tabs( tab_target ) { 
        target_tab_among_exclusive_tabs = tab_target; // make the target tab name globaly available
        if ( tab_target == "hide_all" ) { for ( let tab of l_exclusive_tab ) { $( tab ).collapse( 'hide' ); } return; } // hide all tabs if tab_target == "hide_all"
        let l_bool_flag_need_change = [ ];
        for ( let tab of l_exclusive_tab ) {
            l_bool_flag_need_change.push( tab == tab_target ? ! ( $( tab ).hasClass( "show" ) ) : $( tab ).hasClass( "show" ) );
        }
        if ( ArraySum( l_bool_flag_need_change ) > 0 ) { // if tab_target is not opened, open the tab
            for ( let tab of l_exclusive_tab ) {
                if( tab == tab_target ) { 
                    BootstrapCollapseShownPromise( tab )
                        .then( ( ) => { 
                        // draw plot if not drawn ofter a dataset has been loaded.
                        switch( target_tab_among_exclusive_tabs ) {
                            case "#plotly_graph_b_cell_cross_reactivity" :
                                if ( ! object_data.flag.bcellmetrics_plot_is_drawn ) {
                                    DrawBCellCrossReactivityPredMetricsPlot( );
                                    object_data.flag.bcellmetrics_plot_is_drawn = true;
                                }
                                break;
                            case "#plotly_graph_t_cell_cross_reactivity" :
                                if ( ! object_data.flag.tcellmetrics_plot_is_drawn ) {
                                    DrawTCellCrossReactivityPredMetricsPlot( );
                                    object_data.flag.tcellmetrics_plot_is_drawn = true;
                                }
                                break;
                            case "#plotly_graph_human_protein" :
                                if ( ! object_data.flag.humanproteinmetrics_plot_is_drawn ) {
                                    DrawHumanProteinMetricsPlot( );
                                    object_data.flag.humanproteinmetrics_plot_is_drawn = true;
                                }
                                break;
                            case "#container_datatable_panel_MolecularMimicryMap" :
                                break;
                        }
                        window.dispatchEvent( new Event( 'resize' ) ); // trigger resize events to allow Plotly plot to resize its plot
                    } );
                } 
                else { $( tab ).collapse( 'hide' ); }
            }
        } else { $( tab_target ).collapse( 'hide' ); } // if tab_target is already opened, close the tab
         
    }
    var target_tab_being_toggled = "";
    function Toggle_Panel( tab, flag_function_call_within_script = null ) { // toggle a collapsable panel containing Plotly plots
        target_tab_being_toggled = tab 
        if ( ! ( $( tab ).hasClass( "show" ) ) ) {
            BootstrapCollapseShownPromise( tab ).then( ( ) => { 
                // draw plot if not drawn ofter a dataset has been loaded.
                switch( target_tab_being_toggled ) {
                    case "#container_expression_panel_MolecularMimicryMap" :
                    case "#container_plotly_scrnaseq" :
                    case "#container_plotly_gtex" :
                        UpdatePlotExpression( ); // update plots showing expression of genes when collapse/show status of the containers are changed
                        break;
                }
                window.dispatchEvent( new Event( 'resize' ) );
            } );
        } // trigger resize events to allow Plotly plot to resize its plot
        else { $( tab ).collapse( 'hide' ); } // if the tab is already opened, close the tab
    }
    function Toggle_div( id_div ) {
        var div = document.getElementById( id_div );
        if ( div.style.display == "none" ) { div.style.display = "block"; } 
        else { div.style.display = "none"; }
    }
    var flag_tooltip_active_Toggle_Tooltips = true;
    function Toggle_Tooltips(  ) {
        console.log( "[Toggle_Tooltips] Tooltips toggled to ", flag_tooltip_active_Toggle_Tooltips )
        flag_tooltip_active_Toggle_Tooltips = ! flag_tooltip_active_Toggle_Tooltips; // toggle the flag
        if ( flag_tooltip_active_Toggle_Tooltips ) { $('[data-tooltip="tooltip"]').tooltip( 'enable' ); }
        else { $('[data-tooltip="tooltip"]').tooltip( 'disable' ); }
    }
    
    var color_non_selected = "#fcfcfc"; // color of residues that are not selected
    function Select_View_of_PDB_Virus_Protein( ) {
        switch ( document.getElementById( "select_PDB_virus_protein_structure" ).value ) {
            case "Clear" : 
                pdbVirusProtein.visual.clearSelection( );
                break;
            case "BLOSUM62 Score" : 
                pdbVirusProtein.visual.select( { data: object_pdb_virus.selection, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            case "BLOSUM62 Score with Side Chains" : 
                pdbVirusProtein.visual.select( { data: object_pdb_virus.selection_showing_side_chain, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            default : break;
        }
    }
    function Select_View_of_PDB_Human_Protein( ) {
        switch ( document.getElementById( "select_PDB_human_protein_structure" ).value ) {
            case "Clear" : 
                pdbHumanProtein.visual.clearSelection( );
                break;
            case "BLOSUM62 Score" : 
                pdbHumanProtein.visual.select( { data: object_pdb_human.selection, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            case "BLOSUM62 Score with Side Chains" : 
                pdbHumanProtein.visual.select( { data: object_pdb_human.selection_showing_side_chain, nonSelectedColor: { r:255, g:255, b:255 } } );
                break;
            default : break;
        }
    }
    
    // Get the button_scroll_to_the_top:
    button_scroll_to_the_top = document.getElementById( "button_scroll_to_the_top" );
    // When the user scrolls down 20px from the top of the document, show the button
    window.onscroll = function( ) { scrollFunction( ) };
    function scrollFunction( ) {
      if ( document.body.scrollTop > 20 || document.documentElement.scrollTop > 20 ) { button_scroll_to_the_top.style.display = "block"; }
      else { button_scroll_to_the_top.style.display = "none"; }
    }
    // When the user clicks on the button, scroll to the top of the document
    function Scroll_to_the_Top() {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    }
    function Scroll_to_the_Bottom() {
      $( document ).scrollTop( $( document ).height( ) ); // scroll to the bottom
    }

</script>
</body>
</html>
